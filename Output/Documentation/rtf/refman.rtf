{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment Daves Coding Paradise  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0.1.1 \par
}}Daves Coding Paradise}
{\comment Generated by doxygen 1.11.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Daves Coding Paradise}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 0.1.1\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
00_Introduction Introduction\par \pard\plain 
{\tc\tcl1 \v 00_Introduction Introduction}
{\xe \v 00_Introduction Introduction}
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Welcome to DCP's documentation!} \par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 What is it?} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
DCP is an abbreviation for {\b D} ave's {\b C} ode {\b P} aradise.

DCP is a collection of dynamic libraries, static libraries and executable projects which link to them.

DCP has a solution file for Visual Studio, found in the root directory called "DCP.sln", which contains a main static library project and multiple executable projects which link to it.

The main static library is called "DavesCodeLibrary" or {\b DCL} for short.

The executables are used to develop {\b DCL}, show examples of how to use it, test various parts out to make sure they're working as expected. Some are also custom created tools such as font file generation.

{\b DCL} is a collection of code which includes (or will do) features such as...
- Opening a window.
- Access to input devices such as keyboard, mouse and various joysticks.
- AI, including neural networks, finite state machines and steering/flocking.
- Audio playback and maybe recording with various effects such as reverb, delay etc.
- Graphics rendering using either OpenGL, Software based or Vulkan.
- Image handling (loading/saving/manipulation with filters etc)
- Mathematics for vectors, matricies, planes, quaternions etc
- Networking, both TCP and UDP
- Physics, probably using other people's physics engines such as Box2D and Bullet and then later, my own rigid/soft body simulation.
- Spatial partitioning for both 2D (Quad tree) and 3D (Oct tree)

{\b DCL} is being created to allow me to create all kinds of cool stuff such as 2D and 3D hardware accelerated games and applications.

To get started, I recommend viewing the {\b Getting Started.} page which can be viewed by clicking on it on the tree view to the left, or of course the reference link generated by Doxygen.
\par}
 \par
}}
\par \pard\plain 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Getting Started.\par \pard\plain 
{\tc\tcl1 \v Getting Started.}
{\xe \v Getting Started.}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
To get started, I recommend building everything by following the instructions below which will enable you to run the various executables which can be found in the /Output/Executables directory to get to see
the whole thing running in action!
Then with the solution still loaded inside Visual studio, look at the various example projects which show how to do various stuff such as simple things, like opening a window.
One you've messed around a bit, come back to this documentation and look at {\b DCL} for more details.
\par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Getting DCP} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Download or obtain the project and uncompress somewhere, a nice fast SSD would be a lovely location, or a RAM disk would be awesome :)
\par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Building DCP} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Here, I explain how to setup your system to build everything.
\par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Install Microsoft's Visual Studio} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Install Microsoft's free community edition of Visual Studio, or a more expensive version if you prefer ;p
At the time of this being typed, you can goto {\f2 https://visualstudio.microsoft.com/downloads/}
\par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Install the Vulkan SDK} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Now we have to install the Vulkan SDK onto our system.
Go goto {\f2 https://vulkan.lunarg.com/} and download the latest Vulkan SDK for Windows.
Or you can use the pre-downloaded file located in /Other/SDKs/VulkanSDK-1.3.290.0-Installer.exe
Click next, next, next, next, accept the license, next and finally Install button.
Once that's done, close the window.

We install the Vulkan SDK so that the various debug layers work. Without installation, they will not.

It would be nice to not have to do this because I like all my libraries offline and the installer isn't.
However, get over it David! If the internet goes down for some reason, then I think there's more to worry about than "My project can't download files". Problems such as
"Holy crap! The internet has gone down! What has happened to the world!?"
I really need to adjust my way of thinking, hating online requirements. I think it's because I grew up in an offline world. Don't be an old fuddy duddy!

The installer adds a system path called "VK_SDK_PATH" Which points to where ever the SDK was installed. Looking at my system right now, that is "C://VulkanSDK//1.3.290.0". We could 
use C:\\VulkanSDK\\1.3.290.0 in the various project settings pages to reference this directory when adding include files and libs.
The installer also enables usage of the Vulkan debug layers which is usefull indeed. Please remember that this stuff isn't available on end-users' machines unless they also install the SDK,
which should NOT be a requirement for them to use my software. Therefore the SDK installation is required for the debug stuff to work, that's why we install it.

Now you just have to click on the menu item of Visual studio "Build" and select "Batch Build...", "Select All" and hit "Build".
After that's done (It'll take a while, longer than expected probably because I chose to NOT use precompiled headers (I have my reasons!)), you can go to your file browser, navigate into
the /Output/Executables directory and run all those little things :)
Done!
\par}
 \par
}}
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Directory Layout.\par \pard\plain 
{\tc\tcl1 \v Directory Layout.}
{\xe \v Directory Layout.}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Directory layout.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Here's some information of DCP's directory layout.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
The root directory containing a Microsoft Visual Studio solution file "DCP.sln" containing all projects found in /ProjectFiles/.
Load this solution file to build all libraries, documentation and executables.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /BuildTemp/} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Where the temporary build files such as .obj, .log, .lastbuildstate, get placed.
It's just nice and tidy to have all the temporary files placed here for easy deletion.
The folder has four subfolders for each of the project types and those are...
/BuildTemp/Documentation Files related to Doxygen generated documentation
/BuildTemp/DynamicLibs Files related to dynamic libraries used by DCP
/BuildTemp/Executables Files related to executable projects of DCP
/BuildTemp/StaticLibs Files related to static library projects of DCP
Each of the projects located inside the /ProjectFiles directory use the above folders when they are being built.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /Other/} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Contains a few sub directories...
/Other/Reference/ Reference material is located such as articles, books etc which I read and use whilst learning new stuff to add to DCP.
/Other/SDKs/ Software development kit installers such as the VulkanSDK
/Other/Support/ Contains support files, for things like Blender project files for creating images etc.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /Output/} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Contains four subfolders for each of the project types and those are...
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 /Output/Documentation/} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Contains the documentation which is generated from the comments inside the sourcecode for {\b DCL}, as well as several files which are located inside /ProjectFiles/Documentation/BuildDoxygenDocs/pages/
See {\b Doxygen Documentation.} page for more information of why I chose to use Doxygen.
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 /Output/DynamicLibs} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Where dynamic libraries are output to once built.
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 /Output/Executables} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Where executables are output to once built.
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 /Output/Executables/Data} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Data required by the various executables at their runtime are stored here. Files such as .mp3/.ogg/.wav/.png/.jpg etc.
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 /Output/StaticLibs} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Where static libraries are output to once built.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /ProjectFiles/} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Contains each project file used to compile either documentation, dlls, executables or static libraries.
Each project folder contains each project's source files and the project file itself.
They are placed inside one of the four folder types depending upon what type of project they are. These four sub folders are...
/ProjectFiles/Documentation Files related to Doxygen generated documentation
/ProjectFiles/DynamicLibs Files related to dynamic libraries used by DCP
/ProjectFiles/Executables Files related to executable projects of DCP
/ProjectFiles/StaticLibs Files related to static library projects of DCP
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /ProjectFiles/GLFW} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
GLFW is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan development on the desktop. It provides a simple API for creating windows, contexts and surfaces, receiving input and events.
GLFW is written in C and supports Windows, macOS, Wayland and X11.

\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /ProjectFiles/OpenGL} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
OpenGL (Open Graphics Library) is a cross-platform application programming interface (API) used for rendering 2D and 3D vector graphics.
Essentially, it's a set of tools that allows programmers to communicate with a computer's graphics hardware (like a GPU) to create visual content.

\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /ProjectFiles/SDL2-2.30.6} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
About SDL

Simple DirectMedia Layer is a cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and
graphics hardware via OpenGL and Direct3D. It is used by video playback software, emulators, and popular games including Valve's award winning catalog and many Humble Bundle games. 

\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /external_libs/VulkanSDK} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
The Vulkan SDK is a collection of essential tools used by developers to assist in development and debugging of Vulkan applications.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /projects/DCL/} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Dave's Code Library.
A static library containing the bulk of all my code which the other executable projects link to.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /projects/ExampleCLog/} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
An executable to show usage and test the {\b DCL} lib's CLog class used for logging.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 /projects/DCLDevApp/} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
An executable project used whilst developing the static library project {\b DCL}.
\par}
 \par
}}
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Doxygen Documentation.\par \pard\plain 
{\tc\tcl1 \v Doxygen Documentation.}
{\xe \v Doxygen Documentation.}
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Why I chose to use Doxygen} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
I decided to use Doxygen for this as not only have I been using it for years, therefore feeling pretty comfortable with the thing, but also,
the required changes to the source code which Doxygen uses to generate the code is minimal and clean looking and the syntax allows for some pretty cool
control of the generation of the docs.
It's really nice having the documentation generated from the source file comments as we only have to keep the comments up to date, instead of having to seperately create and modify external 
documentation files.
The todo keyword is incredibly usefull for creating a todo list for things to check/implement etc.
We simply add something like...

/// \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid Whatever we need to fix\par
}
\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid whereever we need to do something and the generated Doxygen documentation creates a nice todo page for us to keep track of what needs doing.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid I used this feature incredibly early one when I first started the DCP/DCL project and started adding code from my existing code. An early example of this
was when I was adding the CColour class over from my old X project, splitting it up into multiple data types. Originally within the X project, there was only
one data type for this class, a float for each colour component, but whilst adding the code over, I thought it'd be a great idea to add another CColour class using the unsigned char
data type. However, when looking through the interpolate() method which is used to "blend" between two values, I was unsure of whether the new data type changed the behaviour, so I added a
"todo Check this class!" tag to the top of the class and, there we have it, an awesome feature of the Doxygen todo tag :)\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Another reason is that the documentation generated by Doxygen is actually quite helpful. Especially if you are not me. With a little extra effort on my part, this solution, projects and source code
comes with complete, easy to navigate documentation.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid And another reason is that the documentation generated by Doxygen can have images placed within it. I've always wished that I could add images to the source code comments to help explain
certain concepts and thanks to the magic of Doxygen, now I can!
Certain concepts really benefit from having images to help show and explain certain concepts. All these images are located in /ProjectFiles/Documentation/BuildDoxygenDocs/images/
\par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 How the documentation is generated} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
The BuildDoxygenDocs project found in /ProjectFiles/Documentation/ has a custom build step which automatically builds the documentation for us.
Right click on the project file in the solution explorer found under Documentation filter, select "properties" and then navigate to
"Configuration Properties/Build Events/Post-Build event" and notice the text inside the "Command Line" setting which currently reads...

cmd.exe /C "$(SolutionDir)\\ProjectFiles\\Documentation\\BuildDoxygenDocs\\doxygen\\build_docs_visualstudio_buildevent.bat"

This batch file calls the doxygen.exe located in /ProjectFiles/Documentation/BuildDoxygenDocs/ passing the file /ProjectFiles/Documentation/BuildDoxygenDocs/Doxyfile_config

The documentation is created inside "/Output/Documentation/html/index.html"
\par}
 \par
}}
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Adding New Projects.\par \pard\plain 
{\tc\tcl1 \v Adding New Projects.}
{\xe \v Adding New Projects.}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Adding new projects to the main DCP solution file.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
This text file details steps on how we add new project files to the main DavesCodingParadise Visual studio solution file.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 The main solution file which builds everything.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
The root directory contains a Microsoft Visual Studio solution file "DCP.sln" containing all projects found in /ProjectFiles/.
Load this solution file and perform a batch build to build all libraries, documentation and executables.
The solution file has four filters/folders Documentation, DynamicLibs, Executables and StaticLibs.
When adding a new project to the solution, you can choose to create a project where ever you like, but when adding a project, depending upon it's type, should be placed inside one of those filters to keep things tidy.
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 Adding a new executable project.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Right click upon the Executables filter found within the solution explorer window, "Add...New Project" and select "Empty Project".
Place new project in "/ProjectFiles/Executables" directory.
Right click upon the new project in solution explorer, click upon "Properties"
Make sure "Configuration" in the top left of the window is set to "All configurations" and set...
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     Configuration Properties/General/ {\cf22 "Output Directory"} set to $(SolutionDir)Output\\Executables\\\par
    Configuration Properties/General/ {\cf22 "Intermediate Directory"} set to $(SolutionDir)BuildTemp\\Executables\\$(ProjectName)\\$(Platform)\\$(Configuration)\\\par
    Configuration Properties/General/ set {\cf22 "C++ Language Standard"} to {\cf22 "ISO C++20 Standard (/std:c++20)"}\par
    Configuration Properties/General/ set {\cf22 "C Language Standard"} to {\cf22 "ISO C17 (2018) Standard (/std:c17)"}\par
    Configuration Properties/Debugging/ {\cf22 "Working Directory"} set to $(SolutionDir)Output\\Executables\\\par
    Configuration Properties/Linker/System{\cf22 " set "}SubSystem{\cf22 " from console to Windows}\par
{\cf22 Make sure "}Configuration{\cf22 " in the top left of the window is set to "}Debug{\cf22 " and set...}\par
{\cf22     Configuration Properties/General/ "}Target Name{\cf22 " set to $(ProjectName)_DEBUG this is so that when performing a batch build and building both debug and release builds,}\par
{\cf22     the debug executable doesn't overwrite the release build and both are available.}\par
}

Make the executable depend upon all required static library projects so they are built first.
Right click on the project name and select "Build Dependencies/Project Dependencies" and add...
    DavesCodeLib
This is all we have to set the project depend upon, as DavesCodeLib depends upon other libraries which are built before DavesCodeLib.

There's no need to set additional library links to "Linker/Input" set "Additional Dependencies" as we use Visual studio's
preprocessor pragma comment(lib, "name_of_lib.lib") to link the libraries.

Remove the "Header Files" and "Source Files" filters, unless you wish to keep them.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Remove the 32bit configurations.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Right click upon the DCP solution at the top of the solution explorer and select "Configuration Manager."
For each "Active Solution Configuration", within "Active Solution Platform", select "Edit" and remove the Win32 platform.
\par}
 \par
}}
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
SDL library.\par \pard\plain 
{\tc\tcl1 \v SDL library.}
{\xe \v SDL library.}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 SDL - Simple Directmedia Layer library} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
This page explains why we use the SDL library and how it was obtained and how it's used.
Here's what SDL has to say about itself...

Simple DirectMedia Layer is a cross-platform development library designed
to provide low level access to audio, keyboard, mouse, joystick, and graphics
hardware via OpenGL and Direct3D. It is used by video playback software,
emulators, and popular games including Valve's award winning catalog
and many Humble Bundle games.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Source code download} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
All the SDL libraries' source code, including the main one itself was downloaded from {\f2 https://github.com/libsdl-org}
We chose to use the source code instead of the pre-compiled libraries as, although it is more effort to compile the things ourselves, gives us more control over the configuration of the library and
makes sure that in the future, if we update our compiler/linker/etc, the source will recompile specifically for those tools.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Source code setup} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
We download the sourcecode for the library, extract and place in /ProjectFiles/DynamicLibs/SDL2-2.30.6/ (Or similar depending upon version)
The same is done for the other various SDL libs such as SDL_Mixer and friends.
The downloaded source folder actually has precompiled .lib and .dll files which we could use, but 
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Automatic copying of compiled dlls to executable folder} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
For our applications to run, the SDL2.dll needs to be located next to the compiled executables. We tell Visual studio to copy that dll file found in /Output/DynamicLibs/SDL3/SDL2.dll to the
executable directory by adding the dll file inside the resources filter in the solution explorer of the DCLDevApp project, right clicking and setting the "item type" to Copy file.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Additional SDL libs} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
We also use several other SDL "support" libraries. These are...
SDL_image-release-2.8.2 = Image file format loading/saving
SDL_mixer-release-2.8.0 = Audio mixer playback
SDL_net-release-2.2.0 = TCP/IP network code
SDL_ttf-release-2.22.0 = True type font
SDL_rtf-main = Rich Text Format file rendering
\par}
 \par
}}
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Dave's Thoughts.\par \pard\plain 
{\tc\tcl1 \v Dave's Thoughts.}
{\xe \v Dave's Thoughts.}
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Notes for myself to help development} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
This text file is here for me to write down random thoughts about anything and everything.
It's just here for me to think out aloud as I find typing thoughts down helps me to think about things in more detail.
You can safely ignore this page, it's really just for myself, but you never know, something in here might be interesting, who knows!?
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Cleaning everything after building stuff.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
We can delete the /BuildTemp dir as they're no longer needed.
We can delete the everything in the /Output/ folder EXCEPT the /Output/Executables/Data/ directory as that folder contains all the external data files such as images used by the various executables.
There should be no files generated inside the /ProjectFiles/ directory if I've set each project's output/intermediate settings up properly.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Changes to coding style} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Use _m for members as it makes it obvious that the member is a member.
Use pre-pended type (for example fSomeFloat) as although the IDE shows the type of a member/variable, it's great to have the info in the variable name
Use _ underscore for private members as although the IDE shows that a member is private, it's nice to have the info in the var itself.
Use a descriptive, non abbreviated name for a variable/member/method/function. Abbreviation makes things less clear and although generally longer, autocomplete makes adding names easy with less typing.
Add "C" to beginning of class declarations, it's a class, it's obvious, but again, nice to have the info and makes everything more clear without having to depend upon the IDE telling us things.
With any singleton classes, add "SC" to the beginning of class declarations.
Camel style casing, someFileWhichDoesSomething. It's easy to read and quite sparse.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Error handling} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Use exceptions. They greatly simplify error handling
In {\b DavesCodeLib/Core/Exceptions.h}, there's a few usefull macros in there which simplify using exceptions and reduces the amount of text we have to type, namely...
{\b ThrowIfMemoryNotAllocated()} and
{\b ThrowIfTrue()} / {\b ThrowIfFalse()}
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Precompiled headers} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
The main advantage of using PCHs is obviously the reduced compile times.
Disadvantages of using PCHs is that each header file doesn't include the required header files there, instead they'ye in the PCH and that is included instead and this gives us less information.
I like the required header files being included where needed, instead of in some single global precompiled header file.
Sure there's a speed increase, but this lack of information in each header file is kinda annoying.
I could add a comment to each header file telling us which headers are used, but these comments could become outdated or wrong and would add more work to keep things updated correctly.
Instead, we simply include the required header files to each of the files.
This gives us more control of where things are included, allows us to include certain headers inside the .c/cpp file instead and when combined with the private implementation (pimple/Cheshire cat),
can keep compilation times down and prevent unnecessary header inclusion into other files which include a header file.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Singleton pattern.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Do not use unless appropriate.
Singletons are great for allowing quick access to a "global" object, but as their name implies, prevents creation of multiple instances.
Their initialisation order can be messy.
Use globals instead, or pass pointers/references to objects.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Strings.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Use wide strings as it's the default setting, they are recommended for many positive reasons (IE some user with a weird character is now supported)
and it's easier to work with than multibyte.
Sure, the L"bloody L!" is kinda annoying having to add Ls everywhere, but calm down, it's only a single character to add. Relax! :D
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Source code file naming and location.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Uppercase for the first character, then camel.
Use sub directories, using them gives orgainisation into groups which is nice, but orgainising groups can be troublesome as some things can be shared, however, if this is
the case, then it might be a sign that the shared files/code should be placed elsewhere, perhaps inside it's own folder or another.
It does mean more typing and knowing where files are, but the orgainization is totally worth it.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Filenames, paths and whether to use forward or backward slashes.} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Windows supports both types, but for possible future crossplatformedness, use forward slashes.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Windows and crossplatformedness} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
I have always tried to make my code as crossplatform as possible whilst developing the stuff on Windows using Visual studio,
using practices such as using cross platform libraries such as OpenGL and avoiding Microsoft specific code such as preprocessor directives such as pragma comment(lib, "somelib.lib") etc.
This has always been done with the intention of me being able to make minimal changes to get the stuff running on Linux in the future.
The problem is, I hardly ever actually use Linux and never develop my stuff on both OSes at the same time and the whole project ends up being Windows only and converting a project over would be alot of work.
Also, making a project compile on both OSs ends up making a huge mess, lots of complexity and adds lots of extra work.
In the unlikely event that Microsoft somehow messes up Windows which forces me to make the switch, then and only then, write a new Linux only project taking code from my Windows only code.
This allows me to focus on the project, without half arsingly adding semi-crossplatformedness which probably wouldn't work anyway.
\par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 Multithreading} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
I've only briefly played with threading when I got my first dual core CPU around about in the year 2000 and haven't really explored further.
As CPUS have continued to have more and more cores and are now pretty much commonplace, I really need to up my game!!
I mean, on an eight core CPU, being able to potentially increase performance of something by eight times is pretty darn cool!
Below contains comments to help explain threading and possibly helper code.
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 Benefits of threading} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Improved performance : Leverage your hardware's capabilities by running tasks concurrently.
Responsiveness : Maintain UI responsiveness while performing CPU - intensive tasks in the background.
Simplified code : Modern C++ threading tools have a cleaner and more expressive syntax compared to older approaches.
Portable applications : Write thread - safe code once and run it on different platforms without modification if using the modern C++ 11 or above stuff.

Use modern C++ features such as...
std::thread which makes it so we no longer have to use platform specific API calls such as pthreads, Boost.threads or the Windows API.
Lookup Tasks: C++20 introduces tasks, providing a higher-level abstraction for scheduling and managing work units.
Lookup Parallel algorithms: The standard library offers parallel algorithms like std::async and std::parallel_for for efficient use of multicore processors.
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 Creating threads} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Example 1 using function pointers...

void someFunction(const std::vector<int> &v, int someVar)
\{
    // Do stuff here
\}

// Create a vector and fill it with stuff (omitted)
std::vector<int> v;

// Create the thread
std::thread t1(someFunction, std::ref(v), 7);

// Wait for the thread to finish 
t1.join();

All parameters are passed by value, unless we wrap them in std::ref(theVariable)
Threads created this way, do not have return values.
If we wish to return something, we need to store it in one of the function's parameters passed by reference.

Example 2 using functors (Function objects)...

First, what is a functor?
A functor is a class or struct which acts like a function.
Overloads the function call operator (): This allows you to invoke the functor as if it were a function.
Can hold member variables: Functors can store data internally, giving them capabilities beyond simple functions.
Here's an example of a functor...

struct Multiplier
\{
    int factor;
    int operator()(int x)
    \{
        return x * factor;  // Apply the multiplication using the stored factor
    \}
\};

int main()
\{
    Multiplier triple\{ 3 \};  // Create a functor that multiplies by 3
    int result = triple(5);  // Call the functor like a function
    // result will be 15
\}

Now we know what a functor is, let's see how to create a thread using one...

class CSomeClassFunctor
\{
public:
    void operator()(const std::vector<int>& v,  unsigned int beginIndex, unsigned int endIndex)
    \{
        _acm = 0;
        for (unsigned int i = beginIndex; i < endIndex; ++i)
        \{
            _acm += v[i];
        \}
    \}
    unsigned long long _acm;
\};

\{
    CAccumulatorFunctor3 accumulator1 = CAccumulatorFunctor3();
    CAccumulatorFunctor3 accumulator2 = CAccumulatorFunctor3();
    std::thread t1(std::ref(accumulator1), std::ref(v), 0, v.size() / 2);
    std::thread t2(std::ref(accumulator2), std::ref(v), v.size() / 2, v.size());
    t1.join();
    t2.join();
    std::cout << "acm1: " << accumulator1._acm << endl;
    std::cout << "acm2: " << accumulator2._acm << endl;
    std::cout << "accumulator1._acm + accumulator2._acm : " << accumulator1._acm + accumulator2._acm << endl;
\}

To get the maximum number of cores you can call: std::thread::hardware_concurrency()
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 Mutexes (Syncronization primitive)} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
These help prevent corruption of data when being accessed by multiple threads.
The idea is to lock a mutex inside a thread, then access/modify the data, then unlock the mutex when done.
This guarantees that the data is only being read/written to by one thread at a time.

Here's an example using a mutex, manually using lock and unlock...

std::mutex g_display_mutex;
thread_function()
\{
    g_display_mutex.lock();
    std::thread::id this_id = std::this_thread::get_id();
    std::cout << "My thread id is: " << this_id << endl;
    g_display_mutex.unlock();
\}

This is not recommended as we have to remember to call unlock and if we forget, can cause issues.
Instead use...
Here's an example using lock guards

std::mutex g_display_mutex;
thread_function()
\{
    std::lock_guard<std::mutex> guard(g_display_mutex);
    std::thread::id this_id = std::this_thread::get_id();
    std::cout << "From thread " << this_id << endl;
\}

This way, lock and unlock are automatically called for us when the function exits.
There's no need to remember to call unlock.
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 Vulkan} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Why use Vulkan?
It's very verbose and gives lots of options to set, which could be seen as a negative as it's a lot of effort to work with.
However, try to think of this as a good thing, as it gives us lots of "dials and knobs" to play with.
Instead of "Argh! Too much to setup!", think of the options as a good thing instead.
Instead of "Argh! I'm gonna make something really buggy!", concentrate and get it stable and working.
The main reason is that the new features of GPUs are only supported with either Vulkan or DirectX12.
These features are really cool, namely Raytracing but also upscaling and frame generation.
I've always hated how shadows are rendered. Stencil buffer shadows were accurate, but looked too sharp and were really CPU heavy.
Texture based shadows always felt hacky, mainly because of their very nature of using textures with their limited resolution and having to determine where the depth
buffer/shadow texture is rendered from, always adds artifacts. Even in modern games such as Gran Turismo 7, I still look at the shadows and see the artifacts.
I also really don't like how screen based reflections are rendered either. As soon as something, such as the top of a mountain goes offscreen, it's no longer rendered and
if there's reflective water, the top of the mountain dissapears and it breaks the illusion and again, I see this in all modern games, it's nasty.
So then, ray tracing to the rescue! With it, we can get decent shadows, reflections, refractions and the awesome, awesome global illumination.
The only downside to raytracing is that it's really demanding on current GPUs as of 2024. My current machine has an AMD 6800xt GPU and, I know it's raytracing performance
is inferiour compared to the top of the line NVidia 4090 cards, which cost stupid amounts of money (\'A31500!!!), enabling full ray tracing in games such as Cyberpunk 2077, drop
framerates from +100 to around 10-15. Which is totally unplayable, near non-interactive. But with time, I'm hoping NVidia, AMD and Intel continue to crank up the performance of
their future cards and games/graphics apps can finally have real time global illumination with lovely shadows and reflections.
I don't want to tie my code to Windows, so DX12 is off the table. Also, DirectX versions keep increasing and their APIs change! The last time I used DirectX was when it was version 9.
OpenGL, with some really hacky shaders and code can kinda do ray tracing, but it's not perfect and as already mentioned, the other features of modern GPUs can't be done either (Such as frame generation/ AI upscaling).
So this all leaves us with our API option, Vulkan.
Another reason to not use OpenGL has become a teeny bit messy what with the deprecation of so much stuff (Which is slow anyway) and it's core profile features and extensions.
Vulkan is cleaner in this regard.
However, saying this, I have chosen to write an OpenGL renderer too, as it'd be great to be able to compare the speed differences between the two APIs and as Vulkan is difficult for me to use,
what with all those syncronization fences and such, I feel that an OpenGL renderer will be like a sanity check for stability and having an OpenGL renderer option will be great if I ever decide
to release some software to the world, the OpenGL renderer will be a great way of saying to people, who experience crashes "Try the OpenGL renderer, it's probably more stable"
\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 Using external libraries} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
We use external libraries for the following reasons...

1. Gain cool features which are either too time consuming to learn how to code ourselves and aren't really interested in learning such as jpeg image loading/saving
2. To use already existing, efficient and easy to use code for dealing with labourious/boring stuff such as creating windows for various OSes.
    I mean, do I really want to delve into the X window system for input/window creation and write the Windows code and deal with messages myself? Not really.

How do we handle these in our project then?
We could download the source and add it directly into the DavesCodeLibrary static library, which on one hand would be nice as it's all compiled in by our compiler.
But this might not be ideal as some external libraries, due to their licenses, require us to dynamically link to their dlls.
Also, these libs can have warnings such as sprintf etc as they use unsafe deprecated code which makes a mess of things with us having to modify their code ourselves to
remove these warnings.
So instead, we create additional projects where needed for each library and within those, compile the libraries, ignoring all the warnings. The mess is contained within that lib's project.

Their source code will be kept in /ProjectFiles/DynamicLibs/SOME_LIB so that we get a nice single location so we can see which libs are using.
\par}
 \par
}}
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Todo List\par \pard\plain 
{\tc\tcl1 \v Todo List}
{\xe \v Todo List}
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
File {\b DavesCodeLibrary.h}  \par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
Go through ALL code and modify the comments so that duplicate "returns this or that" and mentioning of parameters in either \\brief or main stuff too. \par
Add to and check FileManager from X code project \par
Add Renderers from DCP_old \par
Add SDL2 and SDL2_Mixer \par
Check Doxygen build system is working WITHOUT having to have the thing installed.  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Member {\b DCL::CAABB::getAABBintersects}  (const {\b CAABB} &aabb) const\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
test this  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Member {\b DCL::CAABB::resizeArea}  (float fMultiplier)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
Test this \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Class {\b DCL::CAudioManager}  \par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
Lots to add and check here.  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Class {\b DCL::CFileManager}  \par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
Check and modify, lots to add here!  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Member {\b DCL::CFrustum::computeFromViewProjection}  (const {\b CMatrix} &cameraViewMatrix, const {\b CMatrix} &cameraProjectionMatrix)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
Check this  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Member {\b DCL::CFrustum::isAABBIntersecting}  (const {\b CAABB} &aabb) const\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
Check this  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Member {\b DCL::CFrustum::isPointInside}  (const {\b CVector3f} &vPosition) const\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
Check this  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Class {\b DCL::CGeneticsTraining}  \par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
Re-read chapter five (Building a better genetic algorithm) of the "AI techniques for game programming" book to get some better methods  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Class {\b DCL::CGenome}  \par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
Check constness. I was concentrating on the code and forgot about it!  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Member {\b DCL::CImage::greyscale}  (float fRedSensitivity=0.299f, float fGreenSensitivity=0.587f, float fBlueSensitivity=0.144f)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
Isn't working properly.  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Member {\b DCL::COctTree::getEntitiesWithinFrustum}  (const {\b CFrustum} &frustum) const\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
check this  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Page {\b Doxygen Documentation.}  \par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
Whatever we need to fix\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b DCL} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::StringUtils} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various functions for messing around with strings })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
DCL::CAABB\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CAudioManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CAudioSample\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CColourf\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CColouruc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CException\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CFileManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CFileMemory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CFiniteStateBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CFiniteStateMachine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CFrustum\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CGeneticsTraining\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CGenome\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CImage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CImageAtlasDetails\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CImageAtlasPacker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CLog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CLogEntry\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CMatrix\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CNeuralNetworkFeedForward\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CNeuron\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CNeuronLayer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CNewClassTemplate\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::COctTree\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::COctTreeEntity\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::COctTreeNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CPlane\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CProfiler\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CQuadTree\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CQuadTreeEntity\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CQuadTreeNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CQuaternion\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CRay\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CRect\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CRendererBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
DCL::CRendererOpenGL\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CRendererVulkan\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
DCL::CRendererManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CSingleton< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CTimer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CTimerMinimal\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CVector2f\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CVector3f\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CVector4f\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::SMemInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::SMemInfo::SMemOS\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::SMemInfo::SMemProcess\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::SProfilerResults\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CProfiler::SSection\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DCL::CImageAtlasDetails::STexCoords\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b DCL::CAABB} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Axis Aligned Bounding Box })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CAudioManager} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CAudioSample} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Audio sample for playback with the {\b CAudioManager} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CColourf} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using a float for each colour component RGBA, totalling 16 bytes (4 bytes per float * 4 components) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CColouruc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using an unsigned char for each colour component RGBA, totalling 4 bytes (1 byte per unsigned char * 4 components) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CException} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception containing information about what went wrong })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CFileManager} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File manager responsible for dealing with files })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CFileMemory} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FileMemory object holds the entirety of a file in memory })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CFiniteStateBase} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finite state base class with which to derive our FSM state classes from for use with the {\b CFiniteStateMachine} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CFiniteStateMachine} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a generic finite state machine used alongside classes derived from {\b CFiniteStateBase} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CFrustum} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A frustum which is defined by six planes })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CGeneticsTraining} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the genetics training class which is used with the neural network class to train the weights of that class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CGenome} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is used with the {\b CGeneticsTraining} class with methods which are used to create an entire new population of networks from an existing one })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CImage} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class for creating/loading/saving/modifying 2D images })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CImageAtlasDetails} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds information about each packed image inside an atlas image })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CImageAtlasPacker} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Image atlas class used to pack many smaller images into as few as possible larger atlas images })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CLog} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logging of text to a text file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CLogEntry} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Log entry object which holds information about a single log entry. Used by the {\b CLog} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CMatrix} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Matrix class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CNeuralNetworkFeedForward} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a "feed forward" neural network })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CNeuron} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron of a neural network })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CNeuronLayer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron layer })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CNewClassTemplate} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::COctTree} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D spatial partitioning class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::COctTreeEntity} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into an {\b COctTreeNode} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::COctTreeNode} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b COctTree} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CPlane} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A representation of a plane in 3D space })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CProfiler} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to deal with time profiling })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CQuadTree} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a 2D spatial partitioning class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CQuadTreeEntity} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into a {\b CQuadTreeNode} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CQuadTreeNode} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b CQuadTree} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CQuaternion} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Quaternion class to represent rotations })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CRay} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A ray class used to represent a ray })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CRect} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a non-uniform cube aka a rectangle })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CRendererBase} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for the various renderers })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CRendererManager} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renderer manager class for creating and holding a renderer })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CRendererOpenGL} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CRendererVulkan} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CSingleton< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton class to inherit from })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CTimer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with additional features compared to {\b CTimerMinimal} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CTimerMinimal} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with minimal features compared to {\b CTimer} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CVector2f} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 2 floats })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CVector3f} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 3 floats })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CVector4f} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 4 floats })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::SMemInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds system memory information which is set by {\b getMemInfo()} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::SMemInfo::SMemOS} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds OS memory usage })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::SMemInfo::SMemProcess} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds process memory usage })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::SProfilerResults} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used by {\b CProfiler} class to return a vector of this struct containing the profiler's results })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CProfiler::SSection} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Members needed by each code section })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DCL::CImageAtlasDetails::STexCoords} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds texture coordinates for each of the four corners of an image })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/{\b DavesCodeLibrary.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/{\b DavesCodeLibrary.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Master include header file for the entire {\b DCL} library meant to be included by any applications which wish to access all the code inside {\b DCL} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/{\b NewFileTemplate.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/{\b NewFileTemplate.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b FiniteStateMachine.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b FiniteStateMachine.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains finite state machine stuff })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b GeneticAlgorithm.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b GeneticAlgorithm.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Genetic algorithm training for neural networks })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b NeuralNetFeedForward.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b NeuralNetFeedForward.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Feed forward neural network })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/{\b AudioManager.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/{\b AudioManager.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Audio manager })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/{\b AudioSample.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/{\b AudioSample.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Colourf.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Colourf.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CColourf class for representing a colour using a float for each colour component RGBA, totalling 16 bytes (4 bytes per float * 4 components) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Colouruc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Colouruc.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CColouruc class for representing a colour using an unsigned char for each colour component RGBA, totalling 4 bytes (1 byte per unsigned char * 4 components) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Exceptions.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Exceptions.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains error handling code and macros to deal with errors, warnings and logging of information to a log file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Logging.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Logging.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various logging code })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Multithreading.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Multithreading.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains multithreaded related code })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Profiler.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Profiler.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a simple profiler for timing various sections of code })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Singleton.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the template class CSingleton which to derive any classes we wish to act as singletons })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b StringUtils.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b StringUtils.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various string utility functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Timer.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Timer.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CTimer class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b TimerMinimal.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b TimerMinimal.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CTimerMinimal class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Utilities.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Utilities.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various utility functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/{\b FileManager.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/{\b FileManager.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/{\b FileMemory.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/{\b FileMemory.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/{\b Image.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/{\b Image.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2D Image loading/saving })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/{\b ImageAtlas.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/{\b ImageAtlas.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Packing of images into larger images })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b AABB.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b AABB.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Axis Aligned Bounding Box })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Frustum.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Frustum.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frustum })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Matrix.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Matrix.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D Matrix class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Plane.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Plane.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Plane })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Quaternion.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Quaternion.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Quaternions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Rect.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Rect.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Vector2f.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Vector2f.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2D Vector })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Vector3f.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Vector3f.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A three component floating point vector })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Vector4f.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Vector4f.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A four component floating point vector })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/{\b Ray.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/{\b Ray.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds a ray class for ray tracing })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererBase.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererBase.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererManager.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererManager.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererOpenGL.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererOpenGL.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererVulkan.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererVulkan.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b OctTree.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b OctTree.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D space partitioning })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAES \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b OctTreeEntity.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b OctTreeEntity.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b OctTreeNode.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b OctTreeNode.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b QuadTree.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b QuadTree.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b QuadTreeEntity.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b QuadTreeEntity.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b QuadTreeNode.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b QuadTreeNode.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL Namespace Reference\par \pard\plain 
{\tc\tcl2 \v DCL}
{\xe \v DCL}
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b StringUtils}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various functions for messing around with strings. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CAABB}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Axis Aligned Bounding Box. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CAudioManager}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CAudioSample}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Audio sample for playback with the {\b CAudioManager} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CColourf}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using a float for each colour component RGBA, totalling 16 bytes (4 bytes per float * 4 components) }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CColouruc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using an unsigned char for each colour component RGBA, totalling 4 bytes (1 byte per unsigned char * 4 components) }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CException}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception containing information about what went wrong. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFileManager}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File manager responsible for dealing with files. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFileMemory}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FileMemory object holds the entirety of a file in memory. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFiniteStateBase}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finite state base class with which to derive our FSM state classes from for use with the {\b CFiniteStateMachine} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFiniteStateMachine}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a generic finite state machine used alongside classes derived from {\b CFiniteStateBase}. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFrustum}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A frustum which is defined by six planes. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CGeneticsTraining}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the genetics training class which is used with the neural network class to train the weights of that class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CGenome}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is used with the {\b CGeneticsTraining} class with methods which are used to create an entire new population of networks from an existing one. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CImage}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class for creating/loading/saving/modifying 2D images. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CImageAtlasDetails}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds information about each packed image inside an atlas image. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CImageAtlasPacker}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Image atlas class used to pack many smaller images into as few as possible larger atlas images. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLog}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logging of text to a text file. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLogEntry}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Log entry object which holds information about a single log entry. Used by the {\b CLog} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CMatrix}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Matrix class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CNeuralNetworkFeedForward}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a "feed forward" neural network. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CNeuron}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron of a neural network. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CNeuronLayer}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron layer. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CNewClassTemplate}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COctTree}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D spatial partitioning class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COctTreeEntity}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into an {\b COctTreeNode}. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COctTreeNode}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b COctTree} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPlane}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A representation of a plane in 3D space. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CProfiler}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to deal with time profiling. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuadTree}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a 2D spatial partitioning class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuadTreeEntity}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into a {\b CQuadTreeNode}. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuadTreeNode}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b CQuadTree} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuaternion}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Quaternion class to represent rotations. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRay}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A ray class used to represent a ray. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRect}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a non-uniform cube aka a rectangle. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRendererBase}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for the various renderers. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRendererManager}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renderer manager class for creating and holding a renderer. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRendererOpenGL}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRendererVulkan}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CSingleton}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton class to inherit from. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTimer}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with additional features compared to {\b CTimerMinimal}. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTimerMinimal}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with minimal features compared to {\b CTimer}. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CVector2f}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 2 floats. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CVector3f}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 3 floats. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CVector4f}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 4 floats. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SMemInfo}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds system memory information which is set by {\b getMemInfo()} }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SProfilerResults}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used by {\b CProfiler} class to return a vector of this struct containing the profiler's results. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b sortByVal} (const std::pair< std::string, {\b CProfiler::SSection} > &a, const std::pair< std::string, {\b CProfiler::SSection} > &b)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used in getResults() during a call to sort() }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getFileExists} (const std::string &strFilename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given disk filename exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b convertFileToHeader} (const std::string &strFilename, const std::string &strArrayName="data", unsigned int iNumElementsPerRow=20)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the contents of a file into an array, stored inside a text header file, for inclusion of external files, inside the executable of a program. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getHueColour} (float fHueAmount, float &fRed, float &fGreen, float &fBlue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given colour values based on given hue value (between zero and one) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getMemInfo} ({\b SMemInfo} &memInfo)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Places memory information about the process and system into the given {\b SMemInfo} structure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getCPULogicalCores} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns number of logical CPU cores. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b areFloatsEqual} (const float &A, const float &B)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if parsed values have a difference of less than kfEpsilon. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b areDoublesEqual} (const double &A, const double &B)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if parsed values have a difference of less than kdEpsilon. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b interpolate} (float fValA, float fValB, float fPosition)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interpolate between two given values, given a position value between 0.0f and 1.0f. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sigmoid} (double dValue, double dResponse=1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sigmoid function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sigmoid} (double dValue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sigmoid function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Type > bool {\b isNAN} (Type type)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparing a variable when it becomes invalid always returns false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b deg2rad} (float fAngleDegrees)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts degrees to radians. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b rad2deg} (float fAngleRadians)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts radians to degrees. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b acosClamped} (float f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clamps given value within the range of -1 to +1 then performs standard acos function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sincos} (float &outSin, float &outCos, float fScalar)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes both sin and cos of a scalar (Sometime faster to calculate both at same time) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class type > void {\b clamp} (type &valueToClamp, type valueA, type valueB)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clamps a value within given range. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class type > void {\b absolute} (type &value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets given variable to absolute value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class type > type {\b difference} (type valueA, type valueB)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the difference. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b randInt} (int ix, int iy)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random integer between x and y. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b randFloat} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random float between zero and 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b randDouble} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random double between zero and 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b randBool} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random bool. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b randomClamped} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random double in the range -1 < n < 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b randf} (float fMin, float fMax)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random float within the specified range. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b kfEpsilon} = 0.0000001f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Due to floating point errors, we use this to determine whether two floating points are roughly equal. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b kdEpsilon} = 0.000000000000001f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Due to floating point errors with doubles, we use this to determine whether two doubles points are roughly equal. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b kPi} = 3.14159265f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pi constant. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b k2Pi} = {\b kPi} * 2.0f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 * Pi (Radians in a circle) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b kPiOver2} = {\b kPi} / 2.0f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pi divided by 2 (90 degrees in radians) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b k1OverPi} = 1.0f / {\b kPi}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0f divided by PI }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b k1Over2Pi} = 1.0f / {\b k2Pi}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0f divided by 2*PI }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b kPiOver180} = {\b kPi} / 180.0f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PI divided by 180.0f. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b k180OverPi} = 180.0f / {\b kPi}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
180.0f divided by PI }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b kMaxDouble} = (std::numeric_limits<double>::max)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum value for a double. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b kMinDouble} = (std::numeric_limits<double>::min)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum value for a double. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b kMaxFloat} = (std::numeric_limits<float>::max)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum value for a float. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b kMinFloat} = (std::numeric_limits<float>::min)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum value for a float. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b kMaxInt} = (std::numeric_limits<int>::max)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum value for an int. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileManager} {\b gFileManager}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global instance of {\b CFileManager}. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To prevent name clashes between other libraries/code which any application using {\b DCL} may include. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v absolute\:DCL}
{\xe \v DCL\:absolute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class type > void DCL::absolute (type & value){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets given variable to absolute value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value we wish to max absolute (aka, positive) \cell }
{\row }
}
}{
Definition at line {\b 198} of file {\b Utilities.h}.}\par
}
{\xe \v acosClamped\:DCL}
{\xe \v DCL\:acosClamped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::acosClamped (float f){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clamps given value within the range of -1 to +1 then performs standard acos function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{The value to perform the calculation on. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed acos of the given value. \par
}}}{
Definition at line {\b 148} of file {\b Utilities.h}.}\par
}
{\xe \v areDoublesEqual\:DCL}
{\xe \v DCL\:areDoublesEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::areDoublesEqual (const double & A, const double & B){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if parsed values have a difference of less than kdEpsilon. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i A} \cell }{The first double value to compare \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i B} \cell }{The second double point value to compare \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether both given double values are roughly equal (To within kdEpsilon) \par
}}}{
Definition at line {\b 34} of file {\b Utilities.h}.}\par
}
{\xe \v areFloatsEqual\:DCL}
{\xe \v DCL\:areFloatsEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::areFloatsEqual (const float & A, const float & B){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if parsed values have a difference of less than kfEpsilon. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i A} \cell }{The first floating point value to compare \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i B} \cell }{The second floating point value to compare \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether both given floating point values are roughly equal (To within kfEpsilon) \par
}}}{
Definition at line {\b 21} of file {\b Utilities.h}.}\par
}
{\xe \v clamp\:DCL}
{\xe \v DCL\:clamp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class type > void DCL::clamp (type & valueToClamp, type valueA, type valueB){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clamps a value within given range. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i valueToClamp} \cell }{The value we wish to clamp \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i valueA} \cell }{The first value which sets one boundary of the range we wish to clamp the given value to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i valueB} \cell }{The second value which sets one boundary of the range we wish to clamp the given value to. \cell }
{\row }
}
}{
Definition at line {\b 174} of file {\b Utilities.h}.}\par
}
{\xe \v convertFileToHeader\:DCL}
{\xe \v DCL\:convertFileToHeader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::convertFileToHeader (const std::string & strFilename, const std::string & strArrayName = {\f2 "data"}, unsigned int iNumElementsPerRow = {\f2 20})}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the contents of a file into an array, stored inside a text header file, for inclusion of external files, inside the executable of a program. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The name of the file we wish to convert. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strArrayName} \cell }{The name the array variable will be given in the output file \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumElementsPerRow} \cell }{How many elements to fit on a line within the output file \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
False if an error occurred such as the file not being able to be opened. \par
}}}{
Definition at line {\b 31} of file {\b Utilities.cpp}.}\par
}
{\xe \v deg2rad\:DCL}
{\xe \v DCL\:deg2rad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::deg2rad (float fAngleDegrees){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts degrees to radians. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAngleDegrees} \cell }{The angle in degrees \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed angle in radians \par
}}}{
Definition at line {\b 136} of file {\b Utilities.h}.}\par
}
{\xe \v difference\:DCL}
{\xe \v DCL\:difference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class type > type DCL::difference (type valueA, type valueB){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the difference. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i valueA} \cell }{The first value used. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i valueB} \cell }{The second value used. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The difference \par
}}}{
Definition at line {\b 210} of file {\b Utilities.h}.}\par
}
{\xe \v getCPULogicalCores\:DCL}
{\xe \v DCL\:getCPULogicalCores}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::getCPULogicalCores (void )}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns number of logical CPU cores. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The number of logical CPU cores (If we have a single core CPU, with "hyperthreading", this would be 2. \par
}}}{
Definition at line {\b 207} of file {\b Utilities.cpp}.}\par
}
{\xe \v getFileExists\:DCL}
{\xe \v DCL\:getFileExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::getFileExists (const std::string & strFilename)}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given disk filename exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The name of the file to determine whether it exists. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether the file exists or not. \par
}}}{
Definition at line {\b 12} of file {\b Utilities.cpp}.}\par
}
{\xe \v getHueColour\:DCL}
{\xe \v DCL\:getHueColour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::getHueColour (float fHueAmount, float & fRed, float & fGreen, float & fBlue)}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given colour values based on given hue value (between zero and one) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fHueAmount} \cell }{Between zero and one, represents the hue of the desired colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fRed} \cell }{Will hold the red colour intensity of the computed colour between 0.0 and 1.0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fGreen} \cell }{Will hold the green colour intensity of the computed colour between 0.0 and 1.0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fBlue} \cell }{Will hold the blue colour intensity of the computed colour between 0.0 and 1.0 \cell }
{\row }
}
}{
Definition at line {\b 96} of file {\b Utilities.cpp}.}\par
}
{\xe \v getMemInfo\:DCL}
{\xe \v DCL\:getMemInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::getMemInfo ({\b SMemInfo} & memInfo)}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Places memory information about the process and system into the given {\b SMemInfo} structure. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i memInfo} \cell }{Holds the result in an {\b SMemInfo} structure \cell }
{\row }
}
}{
Definition at line {\b 164} of file {\b Utilities.cpp}.}\par
}
{\xe \v interpolate\:DCL}
{\xe \v DCL\:interpolate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::interpolate (float fValA, float fValB, float fPosition){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interpolate between two given values, given a position value between 0.0f and 1.0f. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fValA} \cell }{The first value to interpolate between \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fValB} \cell }{The second value to interpolate between \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fPosition} \cell }{The position between fValA and fValB ranging from 0.0 and 1.0 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The interpolated value \par
}}}{
Definition at line {\b 45} of file {\b Utilities.h}.}\par
}
{\xe \v isNAN\:DCL}
{\xe \v DCL\:isNAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Type > bool DCL::isNAN (Type type){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparing a variable when it becomes invalid always returns false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{The variable we wish to determine whether is NAN. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
False if the given type is a number, else true\par
}}Nice easy way to check if I've done something stupid with a zero and a division somewhere \par
}{
Definition at line {\b 127} of file {\b Utilities.h}.}\par
}
{\xe \v rad2deg\:DCL}
{\xe \v DCL\:rad2deg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::rad2deg (float fAngleRadians){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts radians to degrees. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAngleRadians} \cell }{The angle in radians \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed angle in degrees \par
}}}{
Definition at line {\b 142} of file {\b Utilities.h}.}\par
}
{\xe \v randBool\:DCL}
{\xe \v DCL\:randBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::randBool (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random bool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The random value \par
}}}{
Definition at line {\b 237} of file {\b Utilities.h}.}\par
}
{\xe \v randDouble\:DCL}
{\xe \v DCL\:randDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DCL::randDouble (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random double between zero and 1. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The random value \par
}}}{
Definition at line {\b 232} of file {\b Utilities.h}.}\par
}
{\xe \v randf\:DCL}
{\xe \v DCL\:randf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::randf (float fMin, float fMax){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random float within the specified range. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fMin} \cell }{The minimum float which species the low end of the range \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fMax} \cell }{The maximum float which species the high end of the range \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed random float which lies within the given range \par
}}}{
Definition at line {\b 253} of file {\b Utilities.h}.}\par
}
{\xe \v randFloat\:DCL}
{\xe \v DCL\:randFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::randFloat (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random float between zero and 1. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The random value \par
}}}{
Definition at line {\b 227} of file {\b Utilities.h}.}\par
}
{\xe \v randInt\:DCL}
{\xe \v DCL\:randInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::randInt (int ix, int iy){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random integer between x and y. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ix} \cell }{The first value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iy} \cell }{The second value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The random value \par
}}}{
Definition at line {\b 222} of file {\b Utilities.h}.}\par
}
{\xe \v randomClamped\:DCL}
{\xe \v DCL\:randomClamped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DCL::randomClamped (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random double in the range -1 < n < 1. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The random value between -1 and 1 \par
}}}{
Definition at line {\b 246} of file {\b Utilities.h}.}\par
}
{\xe \v sigmoid\:DCL}
{\xe \v DCL\:sigmoid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DCL::sigmoid (double dValue){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sigmoid function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dValue} \cell }{The value to position upon an S curve \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed value\par
}}Given a value, takes that and scales it so that the values lie upon an S curve. This does not have the ability to set the shape of the S curve, but it is slightly faster as there is no divide. \par
}{
Definition at line {\b 80} of file {\b Utilities.h}.}\par
}
{\xe \v sigmoid\:DCL}
{\xe \v DCL\:sigmoid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DCL::sigmoid (double dValue, double dResponse = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sigmoid function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dValue} \cell }{The value to position upon an S curve \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dResponse} \cell }{The shape of the S curve \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed value\par
}}Given a value, takes that and scales it so that the values lie upon an S curve. dResponse curve specified the shape of the curve. Higher values, flatten the curve, lower ones tighten it. A default value of 1 is usually used. Do not set it to zero, this'll create a divide by zero error. \par
}{
Definition at line {\b 63} of file {\b Utilities.h}.}\par
}
{\xe \v sincos\:DCL}
{\xe \v DCL\:sincos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::sincos (float & outSin, float & outCos, float fScalar){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes both sin and cos of a scalar (Sometime faster to calculate both at same time) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i outSin} \cell }{The sin of the fScalar \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i outCos} \cell }{The cos of the fScalar \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fScalar} \cell }{The value which to compute sin and cos upon. \cell }
{\row }
}
}{
Definition at line {\b 162} of file {\b Utilities.h}.}\par
}
{\xe \v sortByVal\:DCL}
{\xe \v DCL\:sortByVal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::sortByVal (const std::pair< std::string, {\b CProfiler::SSection} > & a, const std::pair< std::string, {\b CProfiler::SSection} > & b)}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used in getResults() during a call to sort() }}\par
{
Definition at line {\b 84} of file {\b Profiler.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v gFileManager\:DCL}
{\xe \v DCL\:gFileManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CFileManager} DCL::gFileManager}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global instance of {\b CFileManager}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I did originally set this class to be a singleton, but I try to avoid singletons where possible due to them limiting the class only being able to have one instance. So instead, I converted the class to a non-singleton and declared this global instance which is used in various places. \par
}{
Definition at line {\b 11} of file {\b FileManager.cpp}.}\par
}
{\xe \v k180OverPi\:DCL}
{\xe \v DCL\:k180OverPi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::k180OverPi = 180.0f / {\b kPi}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
180.0f divided by PI }}\par
{
Definition at line {\b 113} of file {\b Utilities.h}.}\par
}
{\xe \v k1Over2Pi\:DCL}
{\xe \v DCL\:k1Over2Pi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::k1Over2Pi = 1.0f / {\b k2Pi}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0f divided by 2*PI }}\par
{
Definition at line {\b 111} of file {\b Utilities.h}.}\par
}
{\xe \v k1OverPi\:DCL}
{\xe \v DCL\:k1OverPi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::k1OverPi = 1.0f / {\b kPi}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0f divided by PI }}\par
{
Definition at line {\b 110} of file {\b Utilities.h}.}\par
}
{\xe \v k2Pi\:DCL}
{\xe \v DCL\:k2Pi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::k2Pi = {\b kPi} * 2.0f}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 * Pi (Radians in a circle) }}\par
{
Definition at line {\b 108} of file {\b Utilities.h}.}\par
}
{\xe \v kdEpsilon\:DCL}
{\xe \v DCL\:kdEpsilon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double DCL::kdEpsilon = 0.000000000000001f}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Due to floating point errors with doubles, we use this to determine whether two doubles points are roughly equal. }}\par
{
Definition at line {\b 27} of file {\b Utilities.h}.}\par
}
{\xe \v kfEpsilon\:DCL}
{\xe \v DCL\:kfEpsilon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::kfEpsilon = 0.0000001f}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Due to floating point errors, we use this to determine whether two floating points are roughly equal. }}\par
{
Definition at line {\b 14} of file {\b Utilities.h}.}\par
}
{\xe \v kMaxDouble\:DCL}
{\xe \v DCL\:kMaxDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double DCL::kMaxDouble = (std::numeric_limits<double>::max)()}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum value for a double. }}\par
{
Definition at line {\b 114} of file {\b Utilities.h}.}\par
}
{\xe \v kMaxFloat\:DCL}
{\xe \v DCL\:kMaxFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::kMaxFloat = (std::numeric_limits<float>::max)()}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum value for a float. }}\par
{
Definition at line {\b 116} of file {\b Utilities.h}.}\par
}
{\xe \v kMaxInt\:DCL}
{\xe \v DCL\:kMaxInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int DCL::kMaxInt = (std::numeric_limits<int>::max)()}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum value for an int. }}\par
{
Definition at line {\b 118} of file {\b Utilities.h}.}\par
}
{\xe \v kMinDouble\:DCL}
{\xe \v DCL\:kMinDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double DCL::kMinDouble = (std::numeric_limits<double>::min)()}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum value for a double. }}\par
{
Definition at line {\b 115} of file {\b Utilities.h}.}\par
}
{\xe \v kMinFloat\:DCL}
{\xe \v DCL\:kMinFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::kMinFloat = (std::numeric_limits<float>::min)()}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum value for a float. }}\par
{
Definition at line {\b 117} of file {\b Utilities.h}.}\par
}
{\xe \v kPi\:DCL}
{\xe \v DCL\:kPi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::kPi = 3.14159265f}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pi constant. }}\par
{
Definition at line {\b 107} of file {\b Utilities.h}.}\par
}
{\xe \v kPiOver180\:DCL}
{\xe \v DCL\:kPiOver180}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::kPiOver180 = {\b kPi} / 180.0f}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PI divided by 180.0f. }}\par
{
Definition at line {\b 112} of file {\b Utilities.h}.}\par
}
{\xe \v kPiOver2\:DCL}
{\xe \v DCL\:kPiOver2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float DCL::kPiOver2 = {\b kPi} / 2.0f}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pi divided by 2 (90 degrees in radians) }}\par
{
Definition at line {\b 109} of file {\b Utilities.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::StringUtils Namespace Reference\par \pard\plain 
{\tc\tcl2 \v DCL::StringUtils}
{\xe \v DCL::StringUtils}
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various functions for messing around with strings. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::wstring {\b stringToWide} (const std::string &string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a string to wide string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b wideToString} (const std::wstring &wstring)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a wide string to a string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b getFilesInDir} (const std::string &strDirectory, bool bRecursiveDirs=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of strings holding each filename stored within the given directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b getFilesInDir} (const std::string &strDirectory, const std::string &ext, bool bRecursiveDirs=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of strings holding each filename stored within the given directory which have the given filename extension. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b getDirsInDir} (const std::string &strDirectory, bool bRecursiveDirs=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of strings holding each directory stored within the given directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getCurrentDirectory} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b stringToLowercase} (std::string &str)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given string to lowercase. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b addFilenameExtension} (const std::string &strFilenameExtension, const std::string &strFilename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes the given filename and filename extension and adds the given filename extension to the end of the given filename and returns the result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b appendInt} (std::string &string, int iInt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append an integer to given string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b appendUInt} (std::string &string, unsigned int uiInt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append an integer to given string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b appendFloat} (std::string &string, float fValue, unsigned int uiNumDecimalPoints=2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append float to given string with the given number of decimals. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b appendDouble} (std::string &string, double dValue, unsigned int uiNumDecimalPoints=2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append double to given string with the given number of decimals. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b splitString} (const std::string &string, const std::string &strSplitChars="\\n")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a string, finds each occurrence of strSplitChars and returns a vector of strings which contains strings that are either side of the strSplitChars, with the strSplitChars removed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b representsNumber} (const std::string &string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string has nothing but digits. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b stringWrite} (const std::string &strString, std::ofstream &file)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes out a string to an already opened ofstream. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b stringRead} (std::string &strString, std::ifstream &file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b blenderAnimFilename} (const std::string &strBasename="image", const std::string &strExtension=".png", int iFrameNumber=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blender animation frame filename helper. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b stringToFloat} (const std::string &string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given string to a float. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b stringToInt} (const std::string &string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given string to an int. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various functions for messing around with strings. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v addFilenameExtension\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:addFilenameExtension}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::StringUtils::addFilenameExtension (const std::string & strFilenameExtension, const std::string & strFilename)}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes the given filename and filename extension and adds the given filename extension to the end of the given filename and returns the result. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilenameExtension} \cell }{The filename extension to add. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The filename to add the extension to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The filename with the appended filename extension, all lowercase.\par
}}The returned filename is all lowercase. The filename extension may or may not have the "." at the beginning. If it doesn't exist, it is added. If passed strings are of zero length, an exception occurs. Also, if the strFilename already has an extension, it is removed and replaced with the new one. \par
}{
Definition at line {\b 125} of file {\b StringUtils.cpp}.}\par
}
{\xe \v appendDouble\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:appendDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::StringUtils::appendDouble (std::string & string, double dValue, unsigned int uiNumDecimalPoints = {\f2 2})}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append double to given string with the given number of decimals. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{The string to have the value appended to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dValue} \cell }{The value to append. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiNumDecimalPoints} \cell }{The number of decimal points of the given value to use (can be from 0 to 9)\cell }
{\row }
}
uiNumDecimalPoints can be from 0 to 9, if outside this range, then 2 is used. \par
}{
Definition at line {\b 182} of file {\b StringUtils.cpp}.}\par
}
{\xe \v appendFloat\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:appendFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::StringUtils::appendFloat (std::string & string, float fValue, unsigned int uiNumDecimalPoints = {\f2 2})}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append float to given string with the given number of decimals. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{The string to have the value appended to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fValue} \cell }{The value to append. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiNumDecimalPoints} \cell }{The number of decimal points of the given value to use (can be from 0 to 9)\cell }
{\row }
}
uiNumDecimalPoints can be from 0 to 9, if outside this range, then 2 is used. \par
}{
Definition at line {\b 164} of file {\b StringUtils.cpp}.}\par
}
{\xe \v appendInt\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:appendInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::StringUtils::appendInt (std::string & string, int iInt)}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append an integer to given string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{The string to have the value appended to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iInt} \cell }{The integer to append. \cell }
{\row }
}
}{
Definition at line {\b 154} of file {\b StringUtils.cpp}.}\par
}
{\xe \v appendUInt\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:appendUInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::StringUtils::appendUInt (std::string & string, unsigned int uiInt)}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append an integer to given string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{The string to have the value appended to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiInt} \cell }{The unsigned integer to append. \cell }
{\row }
}
}{
Definition at line {\b 159} of file {\b StringUtils.cpp}.}\par
}
{\xe \v blenderAnimFilename\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:blenderAnimFilename}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::StringUtils::blenderAnimFilename (const std::string & strBasename = {\f2 "image"}, const std::string & strExtension = {\f2 ".png"}, int iFrameNumber = {\f2 0})}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blender animation frame filename helper. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strBasename} \cell }{The base name of all the images \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strExtension} \cell }{The extension of all the images, for example ".png" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iFrameNumber} \cell }{The frame number we wish to create the full filename for. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed filename from all the given parameters.\par
}}Say we create an animation in Blender with 100 frames and we save them out as "image" The first 10 images will be named "image0000.png" through to "image0009.png" The next 90 will be named "image0010.png" through to "image0099.png" What this function does is given, a basename, an integer and extension, it returns a string which holds the correct final name. So for example, passing "image" as the basename, "png" (or ".png") as the extension and "50" for the int will return the string "image0050.png" \par
}{
Definition at line {\b 284} of file {\b StringUtils.cpp}.}\par
}
{\xe \v getCurrentDirectory\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:getCurrentDirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::StringUtils::getCurrentDirectory (void )}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A string holding the current directory \par
}}}{
Definition at line {\b 115} of file {\b StringUtils.cpp}.}\par
}
{\xe \v getDirsInDir\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:getDirsInDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > DCL::StringUtils::getDirsInDir (const std::string & strDirectory, bool bRecursiveDirs = {\f2 false})}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of strings holding each directory stored within the given directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strDirectory} \cell }{The directory which we wish to find all directories within it. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bRecursiveDirs} \cell }{If true, then dirs within sub directories are also added instead of just the ones in the given directory. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of strings holding each directory found.\par
}}If bRecursiveDirs is true, then directories within sub directories are also added instead of just the ones in the given directory. \par
}{
Definition at line {\b 93} of file {\b StringUtils.cpp}.}\par
}
{\xe \v getFilesInDir\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:getFilesInDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > DCL::StringUtils::getFilesInDir (const std::string & strDirectory, bool bRecursiveDirs = {\f2 false})}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of strings holding each filename stored within the given directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strDirectory} \cell }{The directory which we wish to find all files within it. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bRecursiveDirs} \cell }{If true, then files within sub directories are also added instead of just the ones in the given directory. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of strings holding each filename found.\par
}}If bRecursiveDirs is true, then files within sub directories are also added instead of just the ones in the given directory. \par
}{
Definition at line {\b 36} of file {\b StringUtils.cpp}.}\par
}
{\xe \v getFilesInDir\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:getFilesInDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > DCL::StringUtils::getFilesInDir (const std::string & strDirectory, const std::string & ext, bool bRecursiveDirs = {\f2 false})}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of strings holding each filename stored within the given directory which have the given filename extension. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strDirectory} \cell }{The directory which we wish to find all files within it. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bRecursiveDirs} \cell }{If true, then files within sub directories are also added instead of just the ones in the given directory. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ext} \cell }{The filename extension for the files which match this to be added to the returned results. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of strings holding each filename found.\par
}}If bRecursiveDirs is true, then files within sub directories are also added instead of just the ones in the given directory. The parsed filename extension may or may not have the "." character at the start. \par
}{
Definition at line {\b 58} of file {\b StringUtils.cpp}.}\par
}
{\xe \v representsNumber\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:representsNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::StringUtils::representsNumber (const std::string & string)}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string has nothing but digits. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{The string to check. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the given string has nothing but digits \par
}}}{
Definition at line {\b 258} of file {\b StringUtils.cpp}.}\par
}
{\xe \v splitString\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:splitString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > DCL::StringUtils::splitString (const std::string & string, const std::string & strSplitChars = {\f2 "\\n"})}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a string, finds each occurrence of strSplitChars and returns a vector of strings which contains strings that are either side of the strSplitChars, with the strSplitChars removed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{The string to use as input for the operation \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strSplitChars} \cell }{The split chars to use for the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of strings holding the results\par
}}This is usefull for splitting text into multiple lines, using a specified character sequence used to represent the end of the line of text. For example, if the string is "Line1\\nLine2\\nLine3" and the strSpliteChars is "\\n" then the returned vector would have 3 entries, "Line1" "Line2" and "Line3" \par
}{
Definition at line {\b 217} of file {\b StringUtils.cpp}.}\par
}
{\xe \v stringRead\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:stringRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::StringUtils::stringRead (std::string & strString, std::ifstream & file)}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in a string from an already opened ifstream.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strString} \cell }{The string to hold the data read in \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{An allready opened ifstream to read the string from.\cell }
{\row }
}
This reads in the size of the string, resizes it to make room and then loads it in If the file is not open or there was an error during reading, an exception occurs. \par
}{
Definition at line {\b 272} of file {\b StringUtils.cpp}.}\par
}
{\xe \v stringToFloat\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:stringToFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::StringUtils::stringToFloat (const std::string & string)}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given string to a float. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{The string holding a float \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The float value contained within the string \par
}}}{
Definition at line {\b 320} of file {\b StringUtils.cpp}.}\par
}
{\xe \v stringToInt\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:stringToInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::StringUtils::stringToInt (const std::string & string)}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given string to an int. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{The string holding the integer \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The int value contained within the string \par
}}}{
Definition at line {\b 326} of file {\b StringUtils.cpp}.}\par
}
{\xe \v stringToLowercase\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:stringToLowercase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::StringUtils::stringToLowercase (std::string & str)}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given string to lowercase. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{The string who's characters are to be set to all lowercase. \cell }
{\row }
}
}{
Definition at line {\b 120} of file {\b StringUtils.cpp}.}\par
}
{\xe \v stringToWide\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:stringToWide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::wstring DCL::StringUtils::stringToWide (const std::string & string)}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a string to wide string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{The string to convert \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The converted string \par
}}}{
Definition at line {\b 16} of file {\b StringUtils.cpp}.}\par
}
{\xe \v stringWrite\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:stringWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::StringUtils::stringWrite (const std::string & strString, std::ofstream & file)}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes out a string to an already opened ofstream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strString} \cell }{The string to write to the file \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{An allready opened ofstream to write the string to.\cell }
{\row }
}
The writes out the size of the string and then the string itself. It's paired with {\b stringRead()} If the file is not open, an exception occurs \par
}{
Definition at line {\b 263} of file {\b StringUtils.cpp}.}\par
}
{\xe \v wideToString\:DCL::StringUtils}
{\xe \v DCL::StringUtils\:wideToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::StringUtils::wideToString (const std::wstring & wstring)}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a wide string to a string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i wstring} \cell }{The string to convert \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The converted string \par
}}}{
Definition at line {\b 26} of file {\b StringUtils.cpp}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CAABB Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CAABB}
{\xe \v DCL::CAABB}
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Axis Aligned Bounding Box. }}\par
{
{\f2 #include <AABB.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAABB} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets to a 1x1x1 cube centered at origin. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAABB} (const {\b CVector3f} &vMin, const {\b CVector3f} &vMax)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the axis aligned bouding box with given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinMax} (const {\b CVector3f} &vMin, const {\b CVector3f} &vMax)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets box position and dims with given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosDims} (const {\b CVector3f} &vPosition, const {\b CVector3f} &vDimensions)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets box position and dims with given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (const {\b CVector3f} &vNewPosition)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets position of box, leaving dimensions alone. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDimensions} (const {\b CVector3f} &vNewDimensions)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets dimensions of box, leaving position alone. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getDimensions} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns dimensions of the box. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getHalfDimensions} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns half dimensions of the box. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getPosition} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns position of the box. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getPointIsInside} (const {\b CVector3f} &vPoint) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given point is inside of this box. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getAABBintersects} (const {\b CAABB} &aabb) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given AABB intersects with this one. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resizeArea} (float fMultiplier)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the area so that it's dimensions are multiplied by the given float. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getMin} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns _mvMin, the minimum positions of the corners of the box. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getMax} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns _mvMax, the maximum positions of the corners of the box. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Axis Aligned Bounding Box. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AABB is simply a box with it's axis aligned to the world. It is similar to the 2D {\b CRect} class, but in 3D and is used for culling with the {\b COctTree} class \par
}{
Definition at line {\b 17} of file {\b AABB.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CAABB\:DCL::CAABB}
{\xe \v DCL::CAABB\:CAABB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CAABB::CAABB ()}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets to a 1x1x1 cube centered at origin. }}\par
{
Definition at line {\b 5} of file {\b AABB.cpp}.}\par
}
{\xe \v CAABB\:DCL::CAABB}
{\xe \v DCL::CAABB\:CAABB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CAABB::CAABB (const {\b CVector3f} & vMin, const {\b CVector3f} & vMax)}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the axis aligned bouding box with given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vMin} \cell }{The minimum extents of the bounding box \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vMax} \cell }{The maximum extents of the bounding box \cell }
{\row }
}
}{
Definition at line {\b 11} of file {\b AABB.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getAABBintersects\:DCL::CAABB}
{\xe \v DCL::CAABB\:getAABBintersects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CAABB::getAABBintersects (const {\b CAABB} & aabb) const}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given AABB intersects with this one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i aabb} \cell }{The other AABB to test for intersection against this one \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the given AABB intersects this one, else false \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid test this \par
}
}{
Definition at line {\b 88} of file {\b AABB.cpp}.}\par
}
{\xe \v getDimensions\:DCL::CAABB}
{\xe \v DCL::CAABB\:getDimensions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CAABB::getDimensions (void ) const}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns dimensions of the box. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} holding the dimensions of the AABB \par
}}}{
Definition at line {\b 50} of file {\b AABB.cpp}.}\par
}
{\xe \v getHalfDimensions\:DCL::CAABB}
{\xe \v DCL::CAABB\:getHalfDimensions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CAABB::getHalfDimensions (void ) const}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns half dimensions of the box. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} holding the half dimensions of the AABB \par
}}}{
Definition at line {\b 55} of file {\b AABB.cpp}.}\par
}
{\xe \v getMax\:DCL::CAABB}
{\xe \v DCL::CAABB\:getMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CAABB::getMax (void ) const}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns _mvMax, the maximum positions of the corners of the box. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} holding the maximum positions of the corners of the box \par
}}}{
Definition at line {\b 126} of file {\b AABB.cpp}.}\par
}
{\xe \v getMin\:DCL::CAABB}
{\xe \v DCL::CAABB\:getMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CAABB::getMin (void ) const}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns _mvMin, the minimum positions of the corners of the box. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} holding the minimum positions of the corners of the box \par
}}}{
Definition at line {\b 121} of file {\b AABB.cpp}.}\par
}
{\xe \v getPointIsInside\:DCL::CAABB}
{\xe \v DCL::CAABB\:getPointIsInside}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CAABB::getPointIsInside (const {\b CVector3f} & vPoint) const}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given point is inside of this box. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vPoint} \cell }{The point the check \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the given point is inside ths AABB, else false \par
}}}{
Definition at line {\b 71} of file {\b AABB.cpp}.}\par
}
{\xe \v getPosition\:DCL::CAABB}
{\xe \v DCL::CAABB\:getPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CAABB::getPosition (void ) const}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns position of the box. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} holding the centre position of the AABB \par
}}}{
Definition at line {\b 62} of file {\b AABB.cpp}.}\par
}
{\xe \v resizeArea\:DCL::CAABB}
{\xe \v DCL::CAABB\:resizeArea}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CAABB::resizeArea (float fMultiplier)}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the area so that it's dimensions are multiplied by the given float. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fMultiplier} \cell }{The amount to adjust the size of the AABB \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Test this\par
}
Example: If mvMin = (0,0) and mvMax = (10,10) (total dims of (10,10)) and the given float is 2 then the new values would be mvMin = (-5,-5) and mvMax = (15,15) (total dims of (20, 20)) \par
}{
Definition at line {\b 105} of file {\b AABB.cpp}.}\par
}
{\xe \v setDimensions\:DCL::CAABB}
{\xe \v DCL::CAABB\:setDimensions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CAABB::setDimensions (const {\b CVector3f} & vNewDimensions)}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets dimensions of box, leaving position alone. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vNewDimensions} \cell }{The new dimensions of the AABB \cell }
{\row }
}
}{
Definition at line {\b 39} of file {\b AABB.cpp}.}\par
}
{\xe \v setMinMax\:DCL::CAABB}
{\xe \v DCL::CAABB\:setMinMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CAABB::setMinMax (const {\b CVector3f} & vMin, const {\b CVector3f} & vMax)}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets box position and dims with given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vMin} \cell }{The minimum extents of the bounding box \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vMax} \cell }{The maximum extents of the bounding box \cell }
{\row }
}
}{
Definition at line {\b 17} of file {\b AABB.cpp}.}\par
}
{\xe \v setPosDims\:DCL::CAABB}
{\xe \v DCL::CAABB\:setPosDims}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CAABB::setPosDims (const {\b CVector3f} & vPosition, const {\b CVector3f} & vDimensions)}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets box position and dims with given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vPosition} \cell }{The centre position of the box \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vDimensions} \cell }{The total width and height of the box \cell }
{\row }
}
}{
Definition at line {\b 23} of file {\b AABB.cpp}.}\par
}
{\xe \v setPosition\:DCL::CAABB}
{\xe \v DCL::CAABB\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CAABB::setPosition (const {\b CVector3f} & vNewPosition)}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets position of box, leaving dimensions alone. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vNewPosition} \cell }{The new position of the AABB \cell }
{\row }
}
}{
Definition at line {\b 30} of file {\b AABB.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b AABB.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/AABB.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CAudioManager Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CAudioManager}
{\xe \v DCL::CAudioManager}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. }}\par
{
{\f2 #include <AudioManager.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAudioManager} (int iFrequency=44100, int iNumberOfChannels=2, int iChunkSizeInSamples=2048)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, initializes the audio sub system using given params as options. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CAudioManager} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor, cleans up SDL audio subsystem. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isAudioPlaying} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks to see if audio is playing on any channels. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description goes here {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 int} iSomeCode = 0;\par
}
 \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid Lots to add and check here. \par
}
}{
Definition at line {\b 21} of file {\b AudioManager.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CAudioManager\:DCL::CAudioManager}
{\xe \v DCL::CAudioManager\:CAudioManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CAudioManager::CAudioManager (int iFrequency = {\f2 44100}, int iNumberOfChannels = {\f2 2}, int iChunkSizeInSamples = {\f2 2048})}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, initializes the audio sub system using given params as options. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If initialization failed, an exception occurs \par
}{
Definition at line {\b 6} of file {\b AudioManager.cpp}.}\par
}
{\xe \v ~CAudioManager\:DCL::CAudioManager}
{\xe \v DCL::CAudioManager\:~CAudioManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CAudioManager::~CAudioManager (void )}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor, cleans up SDL audio subsystem. }}\par
{
Definition at line {\b 24} of file {\b AudioManager.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isAudioPlaying\:DCL::CAudioManager}
{\xe \v DCL::CAudioManager\:isAudioPlaying}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CAudioManager::isAudioPlaying (void )}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks to see if audio is playing on any channels. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True is anything on any channels is currently playing, else false.\par
}}Please note, that even if a channel is paused, it is still considered being played. \par
}{
Definition at line {\b 30} of file {\b AudioManager.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/{\b AudioManager.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioManager.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CAudioSample Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CAudioSample}
{\xe \v DCL::CAudioSample}
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Audio sample for playback with the {\b CAudioManager} class. }}\par
{
{\f2 #include <AudioSample.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAudioSample} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, audio sample is intially empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CAudioSample} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor, frees any memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b load} (const std::string &sampleFilename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to load the audio sample's audio data from a file on storage device. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b play} (int iWhichChannel=-1, int iNumberOfLoops=-1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Plays the audio sample. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees the audio sample data. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Audio sample for playback with the {\b CAudioManager} class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These are meant for short audio sample playback for sound effects such as explosions and such. For longer audio, intended to be played as music, see CAudioMusic \par
}{
Definition at line {\b 20} of file {\b AudioSample.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CAudioSample\:DCL::CAudioSample}
{\xe \v DCL::CAudioSample\:CAudioSample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CAudioSample::CAudioSample ()}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, audio sample is intially empty. }}\par
{
Definition at line {\b 7} of file {\b AudioSample.cpp}.}\par
}
{\xe \v ~CAudioSample\:DCL::CAudioSample}
{\xe \v DCL::CAudioSample\:~CAudioSample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CAudioSample::~CAudioSample ()}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor, frees any memory. }}\par
{
Definition at line {\b 12} of file {\b AudioSample.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v free\:DCL::CAudioSample}
{\xe \v DCL::CAudioSample\:free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CAudioSample::free (void )}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees the audio sample data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the audio sample is currently playing on any channels they will be stopped. \par
}{
Definition at line {\b 37} of file {\b AudioSample.cpp}.}\par
}
{\xe \v load\:DCL::CAudioSample}
{\xe \v DCL::CAudioSample\:load}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CAudioSample::load (const std::string & sampleFilename)}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to load the audio sample's audio data from a file on storage device. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sampleFilename} \cell }{The filename of the sample's audio data. Can be .wav, .mp3 and .ogg\cell }
{\row }
}
If an error occured, an exception occurs \par
}{
Definition at line {\b 17} of file {\b AudioSample.cpp}.}\par
}
{\xe \v play\:DCL::CAudioSample}
{\xe \v DCL::CAudioSample\:play}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CAudioSample::play (int iWhichChannel = {\f2 -1}, int iNumberOfLoops = {\f2 -1})}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Plays the audio sample. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iWhichChannel} \cell }{Which channel to play the sample on. If the specified channel is -1, play on the first free channel. If a specific channel was requested, and there is a sample already playing there, that sample will be halted and the new sample will take its place. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumberOfLoops} \cell }{If this is greater than zero, loop the sound that many times. If this is - 1, loop "infinitely" (~65000 times) \cell }
{\row }
}
}{
Definition at line {\b 30} of file {\b AudioSample.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/{\b AudioSample.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioSample.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CColourf Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CColourf}
{\xe \v DCL::CColourf}
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using a float for each colour component RGBA, totalling 16 bytes (4 bytes per float * 4 components) }}\par
{
{\f2 #include <Colourf.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CColourf} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets to default values (white with full alpha) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CColourf} (float fRed, float fGreen, float fBlue, float fAlpha)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets to parsed values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (float fRed, float fGreen, float fBlue, float fAlpha)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the colour to the given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromHSB} (float fHueAmount, float fSaturation=1.0f, float fBrightness=1.0f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this colour to RGB using the given the HSB (Hue, Saturation and Brightness) values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getHSB} (float &fHue, float &fSaturation, float &fBrightness) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
From this colour in RGBA format, computes and sets the passed variables to hold the HSB (Hue, saturation and brightness values) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CColourf} {\b interpolate} (const {\b CColourf} other, float fValue) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interpolates between this colour and the one given by the given float and returns the new colour. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b CColourf} &col)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload the == operator to compare colours. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CColourf} {\b operator*} (const {\b CColourf} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload the * operator to multiply two colours together. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b red}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Red colour between 0.0f and 1.0f. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b green}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Green colour between 0.0f and 1.0f. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b blue}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blue colour between 0.0f and 1.0f. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b alpha}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Alpha colour between 0.0f and 1.0f. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using a float for each colour component RGBA, totalling 16 bytes (4 bytes per float * 4 components) \par
}{
Definition at line {\b 12} of file {\b Colourf.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CColourf\:DCL::CColourf}
{\xe \v DCL::CColourf\:CColourf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CColourf::CColourf ()}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets to default values (white with full alpha) }}\par
{
Definition at line {\b 8} of file {\b Colourf.cpp}.}\par
}
{\xe \v CColourf\:DCL::CColourf}
{\xe \v DCL::CColourf\:CColourf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CColourf::CColourf (float fRed, float fGreen, float fBlue, float fAlpha)}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets to parsed values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fRed} \cell }{A value between 0.0f and 1.0f representing the intensity of the red component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fGreen} \cell }{A value between 0.0f and 1.0f representing the intensity of the green component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fBlue} \cell }{A value between 0.0f and 1.0f representing the intensity of the blue component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAlpha} \cell }{A value between 0.0f and 1.0f representing the intensity of the alpha component of this colour. \cell }
{\row }
}
}{
Definition at line {\b 13} of file {\b Colourf.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getHSB\:DCL::CColourf}
{\xe \v DCL::CColourf\:getHSB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CColourf::getHSB (float & fHue, float & fSaturation, float & fBrightness) const}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
From this colour in RGBA format, computes and sets the passed variables to hold the HSB (Hue, saturation and brightness values) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fHue} \cell }{A value between 0.0f and 1.0f representing the hue. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fSaturation} \cell }{A value between 0.0f and 1.0f representing the saturation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fBrightness} \cell }{A value between 0.0f and 1.0f representing the brightness. \cell }
{\row }
}
}{
Definition at line {\b 98} of file {\b Colourf.cpp}.}\par
}
{\xe \v interpolate\:DCL::CColourf}
{\xe \v DCL::CColourf\:interpolate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CColourf} DCL::CColourf::interpolate (const {\b CColourf} other, float fValue) const}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interpolates between this colour and the one given by the given float and returns the new colour. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{The other colour to interpolate between this one. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fValue} \cell }{The interpolation value between this and the other colour. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The resulting colours interpolated between.\par
}}If the float is 0.0f, the returned colour will be this colour. If the float is 0.5f, the returned colour will be half way between this colour and the one given. If the float is 1.0f, the returned colour will be the one given. \par
}{
Definition at line {\b 134} of file {\b Colourf.cpp}.}\par
}
{\xe \v operator*\:DCL::CColourf}
{\xe \v DCL::CColourf\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CColourf} DCL::CColourf::operator* (const {\b CColourf} & other) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload the * operator to multiply two colours together. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{The other colour which is multiplied with this one. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CColourf} object holding the resulting colour. \par
}}}{
Definition at line {\b 80} of file {\b Colourf.h}.}\par
}
{\xe \v operator==\:DCL::CColourf}
{\xe \v DCL::CColourf\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CColourf::operator== (const {\b CColourf} & col){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload the == operator to compare colours. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i col} \cell }{The other colour to compare with this one. \cell }
{\row }
}
}{
Definition at line {\b 69} of file {\b Colourf.h}.}\par
}
{\xe \v set\:DCL::CColourf}
{\xe \v DCL::CColourf\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CColourf::set (float fRed, float fGreen, float fBlue, float fAlpha)}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the colour to the given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fRed} \cell }{A value between 0.0f and 1.0f representing the intensity of the red component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fGreen} \cell }{A value between 0.0f and 1.0f representing the intensity of the green component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fBlue} \cell }{A value between 0.0f and 1.0f representing the intensity of the blue component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAlpha} \cell }{A value between 0.0f and 1.0f representing the intensity of the alpha component of this colour.\cell }
{\row }
}
Clamps the values in the range of 0.0f and 1.0f \par
}{
Definition at line {\b 18} of file {\b Colourf.cpp}.}\par
}
{\xe \v setFromHSB\:DCL::CColourf}
{\xe \v DCL::CColourf\:setFromHSB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CColourf::setFromHSB (float fHueAmount, float fSaturation = {\f2 1.0f}, float fBrightness = {\f2 1.0f})}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this colour to RGB using the given the HSB (Hue, Saturation and Brightness) values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fHueAmount} \cell }{A value between 0.0f and 1.0f representing the hue. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fSaturation} \cell }{A value between 0.0f and 1.0f representing the saturation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fBrightness} \cell }{A value between 0.0f and 1.0f representing the brightness.\cell }
{\row }
}
Leaves the alpha value alone Hue value should be between 0 and 1 (Although it is clamped) Saturation value should be between 0 and 1 (Although it is clamped) Brightness value should be between 0 and 1 (Although it is clamped) \par
}{
Definition at line {\b 30} of file {\b Colourf.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v alpha\:DCL::CColourf}
{\xe \v DCL::CColourf\:alpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CColourf::alpha}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Alpha colour between 0.0f and 1.0f. }}\par
{
Definition at line {\b 88} of file {\b Colourf.h}.}\par
}
{\xe \v blue\:DCL::CColourf}
{\xe \v DCL::CColourf\:blue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CColourf::blue}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blue colour between 0.0f and 1.0f. }}\par
{
Definition at line {\b 87} of file {\b Colourf.h}.}\par
}
{\xe \v green\:DCL::CColourf}
{\xe \v DCL::CColourf\:green}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CColourf::green}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Green colour between 0.0f and 1.0f. }}\par
{
Definition at line {\b 86} of file {\b Colourf.h}.}\par
}
{\xe \v red\:DCL::CColourf}
{\xe \v DCL::CColourf\:red}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CColourf::red}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Red colour between 0.0f and 1.0f. }}\par
{
Definition at line {\b 85} of file {\b Colourf.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Colourf.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colourf.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CColouruc Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CColouruc}
{\xe \v DCL::CColouruc}
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using an unsigned char for each colour component RGBA, totalling 4 bytes (1 byte per unsigned char * 4 components) }}\par
{
{\f2 #include <Colouruc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CColouruc} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets to default values (white with full alpha) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CColouruc} (unsigned char ucRed, unsigned char ucGreen, unsigned char ucBlue, unsigned char ucAlpha)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets to parsed values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (unsigned char ucRed, unsigned char ucGreen, unsigned char ucBlue, unsigned char ucAlpha)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the colour to the given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromHSB} (float fHueAmount, float fSaturation=1.0f, float fBrightness=1.0f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this colour to RGB using the given the HSB (Hue, Saturation and Brightness) values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getHSB} (float &fHue, float &fSaturation, float &fBrightness) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
From this colour in RGBA format, computes and sets the passed variables to hold the HSB (Hue, saturation and brightness values) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CColouruc} {\b interpolate} (const {\b CColouruc} other, float fValue) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interpolates between this colour and the one given by the given float and returns the new colour. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b CColouruc} &col)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload the == operator to compare colours. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CColouruc} {\b operator*} (const {\b CColouruc} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload the * operator to multiply two colours together. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b red}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Red colour between 0 and 255. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b green}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Green colour between 0 and 255. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b blue}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blue colour between 0 and 255. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b alpha}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Alpha colour between 0 and 255. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using an unsigned char for each colour component RGBA, totalling 4 bytes (1 byte per unsigned char * 4 components) \par
}{
Definition at line {\b 12} of file {\b Colouruc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CColouruc\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:CColouruc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CColouruc::CColouruc ()}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets to default values (white with full alpha) }}\par
{
Definition at line {\b 8} of file {\b Colouruc.cpp}.}\par
}
{\xe \v CColouruc\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:CColouruc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CColouruc::CColouruc (unsigned char ucRed, unsigned char ucGreen, unsigned char ucBlue, unsigned char ucAlpha)}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets to parsed values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucRed} \cell }{A value between 0 and 255 representing the intensity of the red component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucGreen} \cell }{A value between 0 and 255 representing the intensity of the green component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucBlue} \cell }{A value between 0 and 255 representing the intensity of the blue component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucAlpha} \cell }{A value between 0 and 255 representing the intensity of the alpha component of this colour. \cell }
{\row }
}
}{
Definition at line {\b 13} of file {\b Colouruc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getHSB\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:getHSB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CColouruc::getHSB (float & fHue, float & fSaturation, float & fBrightness) const}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
From this colour in RGBA format, computes and sets the passed variables to hold the HSB (Hue, saturation and brightness values) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fHue} \cell }{A value between 0.0f and 1.0f representing the hue. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fSaturation} \cell }{A value between 0.0f and 1.0f representing the saturation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fBrightness} \cell }{A value between 0.0f and 1.0f representing the brightness. \cell }
{\row }
}
}{
Definition at line {\b 100} of file {\b Colouruc.cpp}.}\par
}
{\xe \v interpolate\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:interpolate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CColouruc} DCL::CColouruc::interpolate (const {\b CColouruc} other, float fValue) const}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interpolates between this colour and the one given by the given float and returns the new colour. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{The other colour to interpolate between this one. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fValue} \cell }{The interpolation value between this and the other colour. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The resulting colours interpolated between.\par
}}If the float is 0.0f, the returned colour will be this colour. If the float is 0.5f, the returned colour will be half way between this colour and the one given. If the float is 1.0f, the returned colour will be the one given. \par
}{
Definition at line {\b 142} of file {\b Colouruc.cpp}.}\par
}
{\xe \v operator*\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CColouruc} DCL::CColouruc::operator* (const {\b CColouruc} & other) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload the * operator to multiply two colours together. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{The other colour which is multiplied with this one. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CColourf} object holding the resulting colour. \par
}}}{
Definition at line {\b 78} of file {\b Colouruc.h}.}\par
}
{\xe \v operator==\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CColouruc::operator== (const {\b CColouruc} & col){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload the == operator to compare colours. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i col} \cell }{The other colour to compare with this one. \cell }
{\row }
}
}{
Definition at line {\b 67} of file {\b Colouruc.h}.}\par
}
{\xe \v set\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CColouruc::set (unsigned char ucRed, unsigned char ucGreen, unsigned char ucBlue, unsigned char ucAlpha)}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the colour to the given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucRed} \cell }{A value between 0 and 255 representing the intensity of the red component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucGreen} \cell }{A value between 0 and 255 representing the intensity of the green component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucBlue} \cell }{A value between 0 and 255 representing the intensity of the blue component of this colour. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucAlpha} \cell }{A value between 0 and 255 representing the intensity of the alpha component of this colour. \cell }
{\row }
}
}{
Definition at line {\b 18} of file {\b Colouruc.cpp}.}\par
}
{\xe \v setFromHSB\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:setFromHSB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CColouruc::setFromHSB (float fHueAmount, float fSaturation = {\f2 1.0f}, float fBrightness = {\f2 1.0f})}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this colour to RGB using the given the HSB (Hue, Saturation and Brightness) values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fHueAmount} \cell }{A value between 0.0f and 1.0f representing the hue. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fSaturation} \cell }{A value between 0.0f and 1.0f representing the saturation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fBrightness} \cell }{A value between 0.0f and 1.0f representing the brightness.\cell }
{\row }
}
Leaves the alpha value alone Hue value should be between 0 and 1 (Although it is clamped) Saturation value should be between 0 and 1 (Although it is clamped) Brightness value should be between 0 and 1 (Although it is clamped) \par
}{
Definition at line {\b 26} of file {\b Colouruc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v alpha\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:alpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char DCL::CColouruc::alpha}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Alpha colour between 0 and 255. }}\par
{
Definition at line {\b 86} of file {\b Colouruc.h}.}\par
}
{\xe \v blue\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:blue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char DCL::CColouruc::blue}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blue colour between 0 and 255. }}\par
{
Definition at line {\b 85} of file {\b Colouruc.h}.}\par
}
{\xe \v green\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:green}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char DCL::CColouruc::green}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Green colour between 0 and 255. }}\par
{
Definition at line {\b 84} of file {\b Colouruc.h}.}\par
}
{\xe \v red\:DCL::CColouruc}
{\xe \v DCL::CColouruc\:red}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char DCL::CColouruc::red}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Red colour between 0 and 255. }}\par
{
Definition at line {\b 83} of file {\b Colouruc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Colouruc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colouruc.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CException Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CException}
{\xe \v DCL::CException}
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception containing information about what went wrong. }}\par
{
{\f2 #include <Exceptions.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CException} (std::string strExceptionText, std::string strFilename, int iLineNumber)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor accepting a string describing the exceptional circumstance why the unrecoverable error occurred and two additional parameters for the source code file name and line number where the exception is thrown. These can of course be added manually using {\b FILE}  and {\b LINE} , but it's easier to use the various macros which fill these in for us. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b mstrException}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
String holding the complete text of the exception. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception containing information about what went wrong. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets thrown via the ThrowIfFalse/True/ThrowIfMemoryNotAllocated macros below \par
}{
Definition at line {\b 38} of file {\b Exceptions.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CException\:DCL::CException}
{\xe \v DCL::CException\:CException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CException::CException (std::string strExceptionText, std::string strFilename, int iLineNumber){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor accepting a string describing the exceptional circumstance why the unrecoverable error occurred and two additional parameters for the source code file name and line number where the exception is thrown. These can of course be added manually using {\b FILE}  and {\b LINE} , but it's easier to use the various macros which fill these in for us. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strExceptionText} \cell }{A string describing the exceptional circumstance why the unrecoverable error occurred. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{A string holding the filename in which the exception was constructed \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iLineNumber} \cell }{An int holding the line number in the source code in which the exception was constructed \cell }
{\row }
}
}{
Definition at line {\b 48} of file {\b Exceptions.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mstrException\:DCL::CException}
{\xe \v DCL::CException\:mstrException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::CException::mstrException}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
String holding the complete text of the exception. }}\par
{
Definition at line {\b 54} of file {\b Exceptions.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Exceptions.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CFileManager Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CFileManager}
{\xe \v DCL::CFileManager}
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File manager responsible for dealing with files. }}\par
{
{\f2 #include <FileManager.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileManager} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, does nothing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b writeString} (std::ofstream &file, std::string &strString) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper method to write the given string to an already opened ofstream in binary mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readString} (std::ifstream &file, std::string &strString) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper method to read a string from an already opened ifstream in binary mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getFileExists} (const std::string &strFilename) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper method. Returns true if the given filename exists on storage device. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Type > void {\b read} (std::ifstream &file, Type &data)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a type from an already opened ifstream in binary mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Type > void {\b write} (std::ofstream &file, Type &data)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a type to an already opened ofstream in binary mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b deleteFile} (const std::string &strFilenameToDelete) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to delete the given file name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b renameFile} (const std::string &strOldFilename, const std::string &strNewFilename) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to rename the given file name to the new filename. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File manager responsible for dealing with files. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lots of file helper methods in here as well as managing compressed archive files. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid Check and modify, lots to add here! \par
}
}{
Definition at line {\b 19} of file {\b FileManager.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CFileManager\:DCL::CFileManager}
{\xe \v DCL::CFileManager\:CFileManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CFileManager::CFileManager ()}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, does nothing. }}\par
{
Definition at line {\b 13} of file {\b FileManager.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v deleteFile\:DCL::CFileManager}
{\xe \v DCL::CFileManager\:deleteFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CFileManager::deleteFile (const std::string & strFilenameToDelete) const}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to delete the given file name. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilenameToDelete} \cell }{The filename to delete \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the file was deleted, else false.\par
}}If the file still exists after attempting to delete it, this method returns false, else true \par
}{
Definition at line {\b 71} of file {\b FileManager.cpp}.}\par
}
{\xe \v getFileExists\:DCL::CFileManager}
{\xe \v DCL::CFileManager\:getFileExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CFileManager::getFileExists (const std::string & strFilename) const}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper method. Returns true if the given filename exists on storage device. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The filename to check for \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the named file exists, else false. \par
}}}{
Definition at line {\b 52} of file {\b FileManager.cpp}.}\par
}
{\xe \v read\:DCL::CFileManager}
{\xe \v DCL::CFileManager\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Type > void DCL::CFileManager::read (std::ifstream & file, Type & data)}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a type from an already opened ifstream in binary mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{An already opened std::ifstream \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{This will hold the data being read from the stream.\cell }
{\row }
}
If the given ifstream is not opened or an error occurred, an exception occurs returns false if an error occurred. \par
}{
Definition at line {\b 90} of file {\b FileManager.h}.}\par
}
{\xe \v readString\:DCL::CFileManager}
{\xe \v DCL::CFileManager\:readString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileManager::readString (std::ifstream & file, std::string & strString) const}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper method to read a string from an already opened ifstream in binary mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{An already opened std::ifstream \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strString} \cell }{The string to read from the file.\cell }
{\row }
}
If the given ifstream is not opened or an error occurred, an exception occurs The given string is cleared before being set. \par
}{
Definition at line {\b 32} of file {\b FileManager.cpp}.}\par
}
{\xe \v renameFile\:DCL::CFileManager}
{\xe \v DCL::CFileManager\:renameFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CFileManager::renameFile (const std::string & strOldFilename, const std::string & strNewFilename) const}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to rename the given file name to the new filename. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strOldFilename} \cell }{The current name of the file to rename \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strNewFilename} \cell }{The name to be given to the renamed file. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether the operation was a success or not \par
}}}{
Definition at line {\b 77} of file {\b FileManager.cpp}.}\par
}
{\xe \v write\:DCL::CFileManager}
{\xe \v DCL::CFileManager\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Type > void DCL::CFileManager::write (std::ofstream & file, Type & data)}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a type to an already opened ofstream in binary mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{An already opened std::ofstream \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{This is what will be written to the ofstream.\cell }
{\row }
}
If the given ofstream is not opened or an error occurred, an exception occurs returns false if an error occurred. \par
}{
Definition at line {\b 100} of file {\b FileManager.h}.}\par
}
{\xe \v writeString\:DCL::CFileManager}
{\xe \v DCL::CFileManager\:writeString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileManager::writeString (std::ofstream & file, std::string & strString) const}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper method to write the given string to an already opened ofstream in binary mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{An already opened std::ofstream \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strString} \cell }{The string to write to the file.\cell }
{\row }
}
If the given ofstream is not opened or an error occurred, an exception occurs \par
}{
Definition at line {\b 17} of file {\b FileManager.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/{\b FileManager.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileManager.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CFileMemory Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CFileMemory}
{\xe \v DCL::CFileMemory}
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FileMemory object holds the entirety of a file in memory. }}\par
{
{\f2 #include <FileMemory.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileMemory} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. Sets data to 0. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CFileMemory} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. Deletes data if there is any. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees all data and resets everything. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromFile} (const std::string &strFilename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads data from a file stored on storage device into this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromMem} (const char *pData, size_t stDataLength)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets data from given pointer and size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b saveToFile} (const std::string &strFilename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to save the contents of this object to a file on storage device. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b appendToFile} (std::ofstream &file)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to append the contents of this object to an already opened file on storage device. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b getData} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a pointer to the beginning of the file data stored in memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getDataSize} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the size of the data stored in memory in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b seekBegin} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set seek position to the start of the data stored in this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b seekEnd} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set seek position to the end of the data stored in this object, the last byte. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b seekToPos} (size_t stOffsetBytesFromStart)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets seek position by the given offset from the start of this object's data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b seekOffset} (size_t stOffsetBytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Offsets the current seek position from the current position by the specified amount in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b seekGetPos} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current seek position in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Type > bool {\b read} (Type &out)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a type from this object's data and move the seek position forward. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isOK} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether an error occurred either due to seeking to an invalid position or {\b read()} failing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets any errors so {\b isOK()} will return true again and resets seek position to beginning by calling {\b seekBegin()}. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FileMemory object holds the entirety of a file in memory. \par
}{
Definition at line {\b 17} of file {\b FileMemory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CFileMemory\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:CFileMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CFileMemory::CFileMemory ()}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. Sets data to 0. }}\par
{
Definition at line {\b 6} of file {\b FileMemory.cpp}.}\par
}
{\xe \v ~CFileMemory\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:~CFileMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CFileMemory::~CFileMemory ()}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. Deletes data if there is any. }}\par
{
Definition at line {\b 15} of file {\b FileMemory.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v appendToFile\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:appendToFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileMemory::appendToFile (std::ofstream & file)}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to append the contents of this object to an already opened file on storage device. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{An already opened ofstream object. \cell }
{\row }
}
}{
Definition at line {\b 86} of file {\b FileMemory.cpp}.}\par
}
{\xe \v free\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileMemory::free (void )}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees all data and resets everything. }}\par
{
Definition at line {\b 20} of file {\b FileMemory.cpp}.}\par
}
{\xe \v getData\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:getData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * DCL::CFileMemory::getData (void )}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a pointer to the beginning of the file data stored in memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to the data in this object.\par
}}May be 0 if no data exists in the object. \par
}{
Definition at line {\b 100} of file {\b FileMemory.cpp}.}\par
}
{\xe \v getDataSize\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:getDataSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t DCL::CFileMemory::getDataSize (void )}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the size of the data stored in memory in bytes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The size of the data stored inside this object.\par
}}May be 0 if no data exists in the object. \par
}{
Definition at line {\b 105} of file {\b FileMemory.cpp}.}\par
}
{\xe \v isOK\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:isOK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CFileMemory::isOK (void )}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether an error occurred either due to seeking to an invalid position or {\b read()} failing. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if everything has been OK since construction or since last call to {\b reset()} \par
}}}{
Definition at line {\b 158} of file {\b FileMemory.cpp}.}\par
}
{\xe \v read\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Type > bool DCL::CFileMemory::read (Type & out)}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a type from this object's data and move the seek position forward. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out} \cell }{This is a type that will hold the data being read from the file. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
False if the type could not be read.\par
}}If error occurred, sets _mbIsOK to false which can be checked with {\b isOK()}. \par
}{
Definition at line {\b 129} of file {\b FileMemory.h}.}\par
}
{\xe \v reset\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileMemory::reset (void )}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets any errors so {\b isOK()} will return true again and resets seek position to beginning by calling {\b seekBegin()}. }}\par
{
Definition at line {\b 163} of file {\b FileMemory.cpp}.}\par
}
{\xe \v saveToFile\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:saveToFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileMemory::saveToFile (const std::string & strFilename)}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to save the contents of this object to a file on storage device. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The file name to save the data of this object to.\cell }
{\row }
}
If something went wrong, an exception occurs. The named file is overwritten. \par
}{
Definition at line {\b 71} of file {\b FileMemory.cpp}.}\par
}
{\xe \v seekBegin\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:seekBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileMemory::seekBegin (void )}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set seek position to the start of the data stored in this object. }}\par
{
Definition at line {\b 110} of file {\b FileMemory.cpp}.}\par
}
{\xe \v seekEnd\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:seekEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileMemory::seekEnd (void )}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set seek position to the end of the data stored in this object, the last byte. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
So calling this and then calling {\b seekGetPos()} would return the size of the data minus 1. \par
}{
Definition at line {\b 116} of file {\b FileMemory.cpp}.}\par
}
{\xe \v seekGetPos\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:seekGetPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t DCL::CFileMemory::seekGetPos (void )}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current seek position in bytes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current seek position in bytes \par
}}}{
Definition at line {\b 153} of file {\b FileMemory.cpp}.}\par
}
{\xe \v seekOffset\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:seekOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CFileMemory::seekOffset (size_t stOffsetBytes)}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Offsets the current seek position from the current position by the specified amount in bytes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stOffsetBytes} \cell }{The number of bytes to move the seek position in bytes. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
False if the given offset would move the new position past the end of the data of the object.\par
}}If error occurred, sets _mbIsOK to false which can be checked with {\b isOK()} if the new seek position is invalid. \par
}{
Definition at line {\b 140} of file {\b FileMemory.cpp}.}\par
}
{\xe \v seekToPos\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:seekToPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CFileMemory::seekToPos (size_t stOffsetBytesFromStart)}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets seek position by the given offset from the start of this object's data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stOffsetBytesFromStart} \cell }{The offset from the beginning of this object's data in bytes. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
False if the given offset goes past the end, else true.\par
}}If error occurred, sets _mbIsOK to false which can be checked with {\b isOK()} if the new seek position is invalid. \par
}{
Definition at line {\b 124} of file {\b FileMemory.cpp}.}\par
}
{\xe \v setFromFile\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:setFromFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileMemory::setFromFile (const std::string & strFilename)}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads data from a file stored on storage device into this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The name of the filename to load into memory, inside this object.\cell }
{\row }
}
If something went wrong, an exception occurs Use X::getFileExists() to determine whether the file exists prior to calling this \par
}{
Definition at line {\b 33} of file {\b FileMemory.cpp}.}\par
}
{\xe \v setFromMem\:DCL::CFileMemory}
{\xe \v DCL::CFileMemory\:setFromMem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFileMemory::setFromMem (const char * pData, size_t stDataLength)}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets data from given pointer and size. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pData} \cell }{A pointer to an array holding the data to copy to this object \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stDataLength} \cell }{The length of the data to copy from the given pointer. \cell }
{\row }
}
}{
Definition at line {\b 55} of file {\b FileMemory.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/{\b FileMemory.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileMemory.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CFiniteStateBase Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CFiniteStateBase}
{\xe \v DCL::CFiniteStateBase}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finite state base class with which to derive our FSM state classes from for use with the {\b CFiniteStateMachine} class. }}\par
{
{\f2 #include <FiniteStateMachine.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b onEnter} (void)=0{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is called when this state is first entered. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b onExit} (void)=0{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is called when this state is left. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b onActive} ({\b CFiniteStateMachine} *pFSM)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is called whilst the state is active. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finite state base class with which to derive our FSM state classes from for use with the {\b CFiniteStateMachine} class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This represents a single state in a finite state machine and has several pure virtual methods which need to be implemented within any class which is derived from this one. \par
}{
Definition at line {\b 20} of file {\b FiniteStateMachine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v onActive\:DCL::CFiniteStateBase}
{\xe \v DCL::CFiniteStateBase\:onActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CFiniteStateBase::onActive ({\b CFiniteStateMachine} * pFSM){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is called whilst the state is active. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pFSM} \cell }{A pointer to a {\b CFiniteStateMachine} which will manage this state. This is usefull to allow the state to change to another named state by calling pFSM->switchToState() \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b FiniteStateMachine.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CFiniteStateMachine Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a generic finite state machine used alongside classes derived from {\b CFiniteStateBase}. }}\par
{
{\f2 #include <FiniteStateMachine.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CFiniteStateMachine} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees the state pointers which have been added with a call to {\b addState()} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates the state machine, calling the currently set state's onActive() method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b switchToState} (const std::string &strStateName)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Switches to the named state. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addState} (const std::string &strStateName, {\b CFiniteStateBase} *pState)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new uniquely named state. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeState} (const std::string &strStateName)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes a previously added state. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getStateExists} (const std::string &strStateName)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether a named state has already been added or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAllStates} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all previously added states. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getNumberStates} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the number of currently added states. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFiniteStateBase} * {\b getState} (unsigned int uiIndex)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns pointer to the state at the given index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFiniteStateBase} * {\b getState} (const std::string strStateName)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns pointer to the named state. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a generic finite state machine used alongside classes derived from {\b CFiniteStateBase}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Each state has three methods which need to be implemented (See {\b CFiniteStateBase}) First create one or more classes derived from the base class and implement each of the three methods, onEnter(), onExit() and onActive(). We create an object of this class and objects of each of our classes derived from the {\b CFiniteStateBase} class. Then we add each of those objects to this one, specifying a unique name for each state. Initially, the state machine has no state and upon calling {\b update()} will do nothing. We need to call switchToState(std::string strStateName) to set the initial state. Upon doing so, the state's onEnter() method will be called, followed by it's onActive() method, until the state machine is asked to switch to another state with a call of {\b switchToState()} either externally, or from within a state itself. Usage example: First, create a couple of classes derived from the {\b CFiniteStateBase} class which will be used for the FSM's states {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 class }CMyFirstState : {\cf17 public} CFiniteStateBase\par
\{\par
{\cf17 public}:\par
    {\cf18 void} onEnter({\cf18 void})\{ {\cf20 // Do stuff for when this state is entered  \}}\par
    {\cf18 void} onExit({\cf18 void})\{  {\cf20 // Do stuff for when this state is left \}}\par
    {\cf18 void} onActive(CFiniteStateMachine* pFSM)\{ pFSM->switchToState({\cf22 "MySecondState"}); {\cf20 // Switch to the second state \}}\par
\};\par
{\cf17 class }CMySecondState : {\cf17 public} CFiniteStateBase\par
\{\par
{\cf17 public}:\par
    {\cf18 void} onEnter({\cf18 void})\{ {\cf20 // Do stuff for when this state is entered  \}}\par
    {\cf18 void} onExit({\cf18 void})\{  {\cf20 // Do stuff for when this state is left \}}\par
    {\cf18 void} onActive(CFiniteStateMachine* pFSM)\{ {\cf20 // Do stuff in this state \}}\par
\};\par
{\cf20 // Now that the two state classes have been created, we need to create the FSM itself and allocate memory for each of the state classes.}\par
CFiniteStateMachine fsm;\par
CMyFirstState* pStateOne = {\cf17 new} CMyFirstState;\par
CMySecondState* pStateTwo = {\cf17 new} CMySecondState;\par
{\cf20 // Now we need to add each state to the FSM, giving them each a unique name...}\par
fsm.addState({\cf22 "state1"}, pStateOne);\par
fsm.addState({\cf22 "state2"}, pStateTwo);\par
{\cf20 // Note: There's no need to delete either of the states, as this is done for us}\par
{\cf20 // when the FSM is destroyed, or by calling either removeState() or removeAllStates() of the FSM object.}\par
{\cf20 // Now call fsm.update() to call the currently set state's onActive() method.}\par
}
 \par
}{
Definition at line {\b 76} of file {\b FiniteStateMachine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~CFiniteStateMachine\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:~CFiniteStateMachine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CFiniteStateMachine::~CFiniteStateMachine ()}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees the state pointers which have been added with a call to {\b addState()} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
There's no need to delete the states given during a call to {\b addState()} as this is performed here. \par
}{
Definition at line {\b 6} of file {\b FiniteStateMachine.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addState\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:addState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFiniteStateMachine::addState (const std::string & strStateName, {\b CFiniteStateBase} * pState)}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new uniquely named state. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strStateName} \cell }{The name given to a previously added state. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pState} \cell }{A pointer to a class object derived from the {\b CFiniteStateBase} class.\cell }
{\row }
}
If the name already exists, an exception occurs. The {\b CFiniteStateBase} object has to be allocated yourself prior to calling this method. Once the state object has been added here, there's no need to keep it around for deletion later, as this class's {\b removeState()}, {\b removeAllStates()} and destructor will delete them for us. Also note that this method checks to see if the given state pointer is NULL and throws an exception if so. \par
}{
Definition at line {\b 46} of file {\b FiniteStateMachine.cpp}.}\par
}
{\xe \v getNumberStates\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:getNumberStates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CFiniteStateMachine::getNumberStates (void )}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the number of currently added states. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current number of added states. \par
}}}{
Definition at line {\b 95} of file {\b FiniteStateMachine.cpp}.}\par
}
{\xe \v getState\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:getState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CFiniteStateBase} * DCL::CFiniteStateMachine::getState (const std::string strStateName)}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns pointer to the named state. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strStateName} \cell }{The name given to a previously added state. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a pointer to the found state.\par
}}If the named state couldn't be found, an exception occurs. \par
}{
Definition at line {\b 113} of file {\b FiniteStateMachine.cpp}.}\par
}
{\xe \v getState\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:getState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CFiniteStateBase} * DCL::CFiniteStateMachine::getState (unsigned int uiIndex)}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns pointer to the state at the given index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiIndex} \cell }{Index number of the state. Valid range is 0 to {\b getNumberStates()}-1 (If at least one state has been added) \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a pointer to the found state.\par
}}If an invalid index is given, an exception occurs \par
}{
Definition at line {\b 100} of file {\b FiniteStateMachine.cpp}.}\par
}
{\xe \v getStateExists\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:getStateExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CFiniteStateMachine::getStateExists (const std::string & strStateName)}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether a named state has already been added or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strStateName} \cell }{The name given to a previously added state. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether the named state exists (true) or not (false) \par
}}}{
Definition at line {\b 70} of file {\b FiniteStateMachine.cpp}.}\par
}
{\xe \v removeAllStates\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:removeAllStates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFiniteStateMachine::removeAllStates (void )}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all previously added states. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The states given during calls to {\b addState()} are deleted for us here, no need to delete them ourselves. \par
}{
Definition at line {\b 76} of file {\b FiniteStateMachine.cpp}.}\par
}
{\xe \v removeState\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:removeState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFiniteStateMachine::removeState (const std::string & strStateName)}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes a previously added state. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strStateName} \cell }{The name given to a previously added state.\cell }
{\row }
}
If the named state doesn't exist, an exception occurs The state given during a call to {\b addState()} is deleted for us here, no need to delete it ourselves. \par
}{
Definition at line {\b 54} of file {\b FiniteStateMachine.cpp}.}\par
}
{\xe \v switchToState\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:switchToState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFiniteStateMachine::switchToState (const std::string & strStateName)}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Switches to the named state. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strStateName} \cell }{The name given to a previously added state.\cell }
{\row }
}
This usually calls the currently set state's onExit() method, followed by the new state's onEnter() method. But the first time this is called, the FSM has no currently set state, so the call to onExit() is not performed. If the named state doesn't exist, then an exception occurs. \par
}{
Definition at line {\b 20} of file {\b FiniteStateMachine.cpp}.}\par
}
{\xe \v update\:DCL::CFiniteStateMachine}
{\xe \v DCL::CFiniteStateMachine\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFiniteStateMachine::update (void )}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates the state machine, calling the currently set state's onActive() method. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remember that initially, no current state is set, so this will initially do nothing until {\b switchToState()} is called. \par
}{
Definition at line {\b 11} of file {\b FiniteStateMachine.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b FiniteStateMachine.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/FiniteStateMachine.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CFrustum Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CFrustum}
{\xe \v DCL::CFrustum}
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A frustum which is defined by six planes. }}\par
{
{\f2 #include <Frustum.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFrustum} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, does nothing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b computeFromViewProjection} (const {\b CMatrix} &cameraViewMatrix, const {\b CMatrix} &cameraProjectionMatrix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this frustum's planes from the given matrices which are from a camera's view and projection matrices. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isPointInside} (const {\b CVector3f} &vPosition) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given position is inside the frustum, else false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isAABBIntersecting} (const {\b CAABB} &aabb) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given Axis Aligned Bounding Box is intersecting this frustum, else false. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPlane} {\b mPlaneNear}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's near plane. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPlane} {\b mPlaneFar}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's far plane. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPlane} {\b mPlaneLeft}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's left plane. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPlane} {\b mPlaneRight}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's right plane. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPlane} {\b mPlaneTop}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's top plane. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPlane} {\b mPlaneBottom}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's bottom plane. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A frustum which is defined by six planes. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It can be used to determine whether various geometric shapes and points are inside of it \par
}{
Definition at line {\b 18} of file {\b Frustum.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CFrustum\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:CFrustum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CFrustum::CFrustum ()}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, does nothing. }}\par
{
Definition at line {\b 8} of file {\b Frustum.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v computeFromViewProjection\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:computeFromViewProjection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CFrustum::computeFromViewProjection (const {\b CMatrix} & cameraViewMatrix, const {\b CMatrix} & cameraProjectionMatrix)}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this frustum's planes from the given matrices which are from a camera's view and projection matrices. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cameraViewMatrix} \cell }{A {\b CMatrix} representing the camera's view matrix \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cameraProjectionMatrix} \cell }{A {\b CMatrix} representing the camera's projection matrix \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Check this \par
}
}{
Definition at line {\b 13} of file {\b Frustum.cpp}.}\par
}
{\xe \v isAABBIntersecting\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:isAABBIntersecting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CFrustum::isAABBIntersecting (const {\b CAABB} & aabb) const}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given Axis Aligned Bounding Box is intersecting this frustum, else false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i aabb} \cell }{The Axis Aligned Bounding Box to check \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the given AABB is intersecting this frustum, else false. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Check this \par
}
}{
Definition at line {\b 131} of file {\b Frustum.cpp}.}\par
}
{\xe \v isPointInside\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:isPointInside}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CFrustum::isPointInside (const {\b CVector3f} & vPosition) const}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given position is inside the frustum, else false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vPosition} \cell }{The position to check againt this frustum \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the given position is within this frustum, else false \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Check this \par
}
}{
Definition at line {\b 80} of file {\b Frustum.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mPlaneBottom\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:mPlaneBottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPlane} DCL::CFrustum::mPlaneBottom}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's bottom plane. }}\par
{
Definition at line {\b 50} of file {\b Frustum.h}.}\par
}
{\xe \v mPlaneFar\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:mPlaneFar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPlane} DCL::CFrustum::mPlaneFar}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's far plane. }}\par
{
Definition at line {\b 46} of file {\b Frustum.h}.}\par
}
{\xe \v mPlaneLeft\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:mPlaneLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPlane} DCL::CFrustum::mPlaneLeft}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's left plane. }}\par
{
Definition at line {\b 47} of file {\b Frustum.h}.}\par
}
{\xe \v mPlaneNear\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:mPlaneNear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPlane} DCL::CFrustum::mPlaneNear}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's near plane. }}\par
{
Definition at line {\b 45} of file {\b Frustum.h}.}\par
}
{\xe \v mPlaneRight\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:mPlaneRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPlane} DCL::CFrustum::mPlaneRight}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's right plane. }}\par
{
Definition at line {\b 48} of file {\b Frustum.h}.}\par
}
{\xe \v mPlaneTop\:DCL::CFrustum}
{\xe \v DCL::CFrustum\:mPlaneTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPlane} DCL::CFrustum::mPlaneTop}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This frustum's top plane. }}\par
{
Definition at line {\b 49} of file {\b Frustum.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Frustum.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Frustum.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CGeneticsTraining Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CGeneticsTraining}
{\xe \v DCL::CGeneticsTraining}
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the genetics training class which is used with the neural network class to train the weights of that class. }}\par
{
{\f2 #include <GeneticAlgorithm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CGenome} {\b rouletteWheelSelection} (const std::vector< {\b CGenome} > &vecPopulation) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of CGenomes representing a all the neural networks and their fitness of an entire population, performs roulette wheel selection and returns a selected {\b CGenome}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b computeFitness} (const std::vector< double > &vecPopulationFitness, double &dWorstFitness, double &dAverageFitness, double &dBestFitness, double &dTotalFitness) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of doubles representing the fitness of each member within a population, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b computeFitness} (const std::vector< {\b CGenome} > &vecPopulation, double &dWorstFitness, double &dAverageFitness, double &dBestFitness, double &dTotalFitness) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of {\b CGenome} objects, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b crossover} (std::vector< double > &vecMumWeights, std::vector< double > &vecDadWeights, std::vector< double > &vecChildAWeights, std::vector< double > &vecChildBWeights, double dCrossoverRate=0.7) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given the weights of two networks (the parents), performs a basic crossover of their weights and creates two child network weights from them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b crossoverBetweenNeurons} (std::vector< double > &vecMumWeights, std::vector< double > &vecDadWeights, std::vector< double > &vecChildAWeights, std::vector< double > &vecChildBWeights, const std::vector< int > &vecSplitPoints, double dCrossoverRate=0.7) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given the weights of two networks (the parents), performs a crossover of their weights between each neuron and creates two child network weights from them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mutate} (std::vector< double > &vecNetworkWeights, double dMutationProbability=0.001, double dMutationMaxAmount=0.3) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given the weights of a neural network, mutates them depending upon the given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertElite} (std::vector< {\b CGenome} > &vecOldPop, std::vector< {\b CGenome} > &vecNewPop, int iNumberOfElite=2, int iNumCopiesOfEachElite=1) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs elitism. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CGenome} > {\b createNewGeneration} (const std::vector< {\b CGenome} > &genomes, const std::vector< int > &vecSplitsPoints, double dMutationProbability=0.001, double dMutationMaxAmount=0.3, double dCrossoverRate=0.7, int iNumberOfElite=2, int iNumCopiesOfEachElite=1) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of CGenomes holding each neural network and their fitness scores, generates and returns a vector of CGenomes which contain a new generation. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the genetics training class which is used with the neural network class to train the weights of that class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid Re-read chapter five (Building a better genetic algorithm) of the "AI techniques for game programming" book to get some better methods \par
}
A neural network has weights for each of it's neurons and they need to be set to correct values, or trained, so that the network produces our desired behaviour.\par
The process goes like this... Say we wish to create a network which flees and enemy entity in a 2D world. We create a population of networks, say 100 of them, initially with random weights/genes. We then run the simulation, passing each network it's inputs, calculating their outputs and applying those outputs to each entity in the simulation. Whilst the simulation is running, we compute a fitness score for each network depending upon how it is performing. Increasing the fitness if it is doing what we want (It is far away from predators), reducing if not (It gets eaten). After a certain time has passed, this class then creates an entirely new generation of the population of networks from the existing population to run in the next run. This class uses the fitness of each network to determine how the new child networks are generated. This process repeats until, hopefully, most of the networks are performing well. We then take the best performing networks, save them out for loading into our program at a later date for use.\par
When creating the new generation of networks, there are a few ways this class can choose how to create the child population. It takes the networks from the best performing networks and use those as parents, to create children from their weights/genes. It also takes non-best performing networks too, to help keep the population's networks varies to allow for variation in behaviour which allows new behaviours to evolve in the population.\par
Typically, after a certain number of runs, the population's differences converge so that they all roughly have the same weights, but we don't want this to happen before an optimal behaviour has been found, so this class has ways of preventing this from happening too quickly.\par
There is mutation, which changes the genes/weights and may produce good behaviour, but may not. This helps diversify the population and create new behaviours. There is gene/weight crossover which determines which genes the children networks get from their parents. There are different types of crossover methods, each with subtly differences. \par
}{
Definition at line {\b 108} of file {\b GeneticAlgorithm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v computeFitness\:DCL::CGeneticsTraining}
{\xe \v DCL::CGeneticsTraining\:computeFitness}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CGeneticsTraining::computeFitness (const std::vector< {\b CGenome} > & vecPopulation, double & dWorstFitness, double & dAverageFitness, double & dBestFitness, double & dTotalFitness) const}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of {\b CGenome} objects, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i vecPopulation} \cell }{Vector holding the genomes of an entire population \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i dWorstFitness} \cell }{Will hold the worst fitness found in all the fitness scores \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i dAverageFitness} \cell }{Will hold the average fitness computed from all the fitness scores \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i dBestFitness} \cell }{Will hold the best fitness found from all the fitness scores \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i dTotalFitness} \cell }{Will hold the accumulated total of all the fitness scores \cell }
{\row }
}
}{
Definition at line {\b 95} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v computeFitness\:DCL::CGeneticsTraining}
{\xe \v DCL::CGeneticsTraining\:computeFitness}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CGeneticsTraining::computeFitness (const std::vector< double > & vecPopulationFitness, double & dWorstFitness, double & dAverageFitness, double & dBestFitness, double & dTotalFitness) const}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of doubles representing the fitness of each member within a population, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i vecPopulationFitness} \cell }{Vector holding the fitness score of each genome. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i dWorstFitness} \cell }{Will hold the worst fitness found in all the fitness scores \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i dAverageFitness} \cell }{Will hold the average fitness computed from all the fitness scores \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i dBestFitness} \cell }{Will hold the best fitness found from all the fitness scores \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i dTotalFitness} \cell }{Will hold the accumulated total of all the fitness scores \cell }
{\row }
}
}{
Definition at line {\b 71} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v createNewGeneration\:DCL::CGeneticsTraining}
{\xe \v DCL::CGeneticsTraining\:createNewGeneration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b CGenome} > DCL::CGeneticsTraining::createNewGeneration (const std::vector< {\b CGenome} > & genomes, const std::vector< int > & vecSplitsPoints, double dMutationProbability = {\f2 0.001}, double dMutationMaxAmount = {\f2 0.3}, double dCrossoverRate = {\f2 0.7}, int iNumberOfElite = {\f2 2}, int iNumCopiesOfEachElite = {\f2 1}) const}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of CGenomes holding each neural network and their fitness scores, generates and returns a vector of CGenomes which contain a new generation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i genomes} \cell }{A vector of {\b CGenome} which represent the current population which is used to generate the new population. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecSplitsPoints} \cell }{The split points which need to be obtained from either parent by calling calculateSplitPoints(). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dMutationProbability} \cell }{The mutation rate is the probability that a gene will be changed. This is typically a very small value of around 0.001 or so. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dMutationMaxAmount} \cell }{The maximum amount of deviation from the weight's current value if mutation occurs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dCrossoverRate} \cell }{The crossover rate. A random value between 0 and 1 is generated and if the value is lower than the crossover rate, then the weights are crossed over when creating the children. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumberOfElite} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumCopiesOfEachElite} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of CGenomes holding the new population.\par
}}This new generation creation method uses {\b crossoverBetweenNeurons()}, {\b mutate()}, {\b rouletteWheelSelection()} and {\b insertElite()} to generate the new population. \par
}{
Definition at line {\b 267} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v crossover\:DCL::CGeneticsTraining}
{\xe \v DCL::CGeneticsTraining\:crossover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CGeneticsTraining::crossover (std::vector< double > & vecMumWeights, std::vector< double > & vecDadWeights, std::vector< double > & vecChildAWeights, std::vector< double > & vecChildBWeights, double dCrossoverRate = {\f2 0.7}) const}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given the weights of two networks (the parents), performs a basic crossover of their weights and creates two child network weights from them. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecMumWeights} \cell }{The weights of the first parent (the mum!) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecDadWeights} \cell }{The weights of the second parent (the dad!) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecChildAWeights} \cell }{Will hold the weights of the 1st child. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecChildBWeights} \cell }{Will hold the weights of the 2nd child. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dCrossoverRate} \cell }{The crossover rate. A random value between 0 and 1 is generated and if the value is lower than the crossover rate, then the weights are crossed over when creating the children.\cell }
{\row }
}
If any of the given vectors' sizes for the parents are not all the same, an exception occurs. The child vectors are cleared before doing anything, as they are the outputs. This is the simplest type of crossover and can mess up each neuron's weight values, similar to mutation. It's probably best to not use this and instead use {\b crossoverBetweenNeurons()} instead. The crossover rate is simply a value between 0 and 1. It's used to swap genes between two parents when creating their children. We compute a random value between 0 and 1 and if this value is lower than the crossover rate, then the genes are swapped at another random value which represents a position among all the genes. A value of around 0.7 is pretty good, in certain cases however, a different value may produce better results. \par
}{
Definition at line {\b 119} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v crossoverBetweenNeurons\:DCL::CGeneticsTraining}
{\xe \v DCL::CGeneticsTraining\:crossoverBetweenNeurons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CGeneticsTraining::crossoverBetweenNeurons (std::vector< double > & vecMumWeights, std::vector< double > & vecDadWeights, std::vector< double > & vecChildAWeights, std::vector< double > & vecChildBWeights, const std::vector< int > & vecSplitPoints, double dCrossoverRate = {\f2 0.7}) const}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given the weights of two networks (the parents), performs a crossover of their weights between each neuron and creates two child network weights from them. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecMumWeights} \cell }{The weights of the first parent (the mum!) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecDadWeights} \cell }{The weights of the second parent (the dad!) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecChildAWeights} \cell }{Will hold the weights of the 1st child. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecChildBWeights} \cell }{Will hold the weights of the 2nd child. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecSplitPoints} \cell }{The split points which need to be obtained from either parent by calling calculateSplitPoints(). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dCrossoverRate} \cell }{The crossover rate. A random value between 0 and 1 is generated and if the value is lower than the crossover rate, then the weights are crossed over when creating the children.\cell }
{\row }
}
vecSplitPoints needs to be obtained from one of the parent neural networks with a call to it's calculateSplitPoints() method. If any of the given vectors' sizes for the parents are not all the same, an exception occurs. The child vectors are cleared before doing anything, as they are the outputs. This crossover takes into consideration the number of weights in each neuron and only splits the weight between those. The crossover rate is simply a value between 0 and 1. It's used to swap genes between two parents when creating their children. We compute a random value between 0 and 1 and if this value is lower than the crossover rate, then the genes are swapped at another random value which represents a position among all the genes. A value of around 0.7 is pretty good, in certain cases however, a different value may produce better results. \par
}{
Definition at line {\b 169} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v insertElite\:DCL::CGeneticsTraining}
{\xe \v DCL::CGeneticsTraining\:insertElite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CGeneticsTraining::insertElite (std::vector< {\b CGenome} > & vecOldPop, std::vector< {\b CGenome} > & vecNewPop, int iNumberOfElite = {\f2 2}, int iNumCopiesOfEachElite = {\f2 1}) const}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs elitism. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecOldPop} \cell }{A vector of {\b CGenome} representing the old population \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecNewPop} \cell }{A vector of {\b CGenome} which will represent the new population with the elite \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumberOfElite} \cell }{The number of elite from the top to copy. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumCopiesOfEachElite} \cell }{How many copies of each iNumberOfElite to place.\cell }
{\row }
}
Given two vectors of CGenomes representing the old population and the new population. iNumberOfElite is the number of elite from the top to copy. iNumCopiesOfEachElite is how many copies of each iNumberOfElite to place. As long as the new population's size is less than the size of the old population, will choose a certain number of genomes with the best fitness and inserts them into the new population. This is typically called fom inside a createNewGeneration method. This will sort the old population vector so that the genomes with the greatest fitness are twoards the end of the vector. We don't want the number of elites and number of copies to be too high, otherwise the population's diversity will suffer. These values all depend upon the size of the population. \par
}{
Definition at line {\b 243} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v mutate\:DCL::CGeneticsTraining}
{\xe \v DCL::CGeneticsTraining\:mutate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CGeneticsTraining::mutate (std::vector< double > & vecNetworkWeights, double dMutationProbability = {\f2 0.001}, double dMutationMaxAmount = {\f2 0.3}) const}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given the weights of a neural network, mutates them depending upon the given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i vecNetworkWeights} \cell }{The network weights which are to be mutated \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\cell }{{\i dMutationProbability} \cell }{The mutation rate is the probability that a gene will be changed. This is typically a very small value of around 0.001 or so. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\cell }{{\i dMutationMaxAmount} \cell }{The maximum amount of deviation from the weight's current value if mutation occurs.\cell }
{\row }
}
The mutation rate is the probability that a gene will be changed. This is typically a very small value of around 0.001 or so. We generate a random value between 0 and 1 for each weight in the given vector and if this value is less than dMutationProbability, the weight is mutated by a maximum of dMaxMutationAmount. \par
}{
Definition at line {\b 230} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v rouletteWheelSelection\:DCL::CGeneticsTraining}
{\xe \v DCL::CGeneticsTraining\:rouletteWheelSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CGenome} DCL::CGeneticsTraining::rouletteWheelSelection (const std::vector< {\b CGenome} > & vecPopulation) const}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of CGenomes representing a all the neural networks and their fitness of an entire population, performs roulette wheel selection and returns a selected {\b CGenome}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i vecPopulation} \cell }{a vector of each genome representing an entire population of neuron weights and their fitness scores. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The selected genome.\par
}}If the given vector is empty, an exception occurs. Roulette wheel selection is a method of choosing a member from the entire population in a way that is proportional to their fitness. Imagine a roulette wheel, or pie chart which is divided into portions, each assigned to a member in the population. The size of each portion is related to each member's fitness score with higher fitness getting a larger portion of the pie/wheel. The wheel is then spun until the ball stops at a position and then that member is chosen. It does not guarantee that a member with a high fitness will be chosen, but it increases the odds that it will be. Note: This may not return any best performing members, so it's probably best to use elitism if using this when selecting members. \par
}{
Definition at line {\b 38} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b GeneticAlgorithm.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/GeneticAlgorithm.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CGenome Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CGenome}
{\xe \v DCL::CGenome}
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is used with the {\b CGeneticsTraining} class with methods which are used to create an entire new population of networks from an existing one. }}\par
{
{\f2 #include <GeneticAlgorithm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CGenome} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets everything to zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CGenome} (std::vector< double > &vecNeuralNetworkWeights, double dNetworkFitness)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor which copies the given values into itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CGenome} (const {\b CNeuralNetworkFeedForward} &neuralNetwork, double dNetworkFitness)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor which copies the given values into itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (std::vector< double > &vecNeuralNetworkWeights, double dNetworkFitness)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this genome to the given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b CNeuralNetworkFeedForward} &neuralNetwork, double dNetworkFitness)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this genome to hold the given fitness and weights stored in the given neural network. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b vecWeights}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This should be filled with the weights from a neural network by calling it's getNeuronWeights() method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dFitness}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This should be set to hold the final fitness score of the entity owning the neural network. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CGenome} &lhs, const {\b CGenome} &rhs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operator overload '<' for sorting a vector of this class's objects by fitness. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is used with the {\b CGeneticsTraining} class with methods which are used to create an entire new population of networks from an existing one. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We typically create a vector of these, transfer the weights for each neural network, along with it's fitness into each one. Then we use the vector of objects of this class to create a next generation from the existing population. For example (psuedo code ahead): {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid std::vector<CGenome> vecGenomes;\par
{\cf19 for} (each neural network)\par
\{\par
    CGenome genome(someExistingNeuralNetwork, itsFitnessScore);\par
    vecGenomes.push_back(genome);\par
\}\par
CGeneticsTraining genTrainer;\par
std::vector<CGenome> vecNewPopulation = genTrainer.someMethodWhichCreatesANewPopulation(vecGenomes);\par
}
 Then we can use the vecNewPopulation to update the existing neural networks and reset their fitness for the next generation. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid Check constness. I was concentrating on the code and forgot about it! \par
}
}{
Definition at line {\b 30} of file {\b GeneticAlgorithm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CGenome\:DCL::CGenome}
{\xe \v DCL::CGenome\:CGenome}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CGenome::CGenome ()}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets everything to zero. }}\par
{
Definition at line {\b 9} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v CGenome\:DCL::CGenome}
{\xe \v DCL::CGenome\:CGenome}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CGenome::CGenome (std::vector< double > & vecNeuralNetworkWeights, double dNetworkFitness)}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor which copies the given values into itself. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecNeuralNetworkWeights} \cell }{The neural network weights of it's neurons. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dNetworkFitness} \cell }{The network's fitness score \cell }
{\row }
}
}{
Definition at line {\b 14} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v CGenome\:DCL::CGenome}
{\xe \v DCL::CGenome\:CGenome}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CGenome::CGenome (const {\b CNeuralNetworkFeedForward} & neuralNetwork, double dNetworkFitness)}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor which copies the given values into itself. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i neuralNetwork} \cell }{The neural network to use for it's weights \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dNetworkFitness} \cell }{The networks fitness score. \cell }
{\row }
}
}{
Definition at line {\b 20} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v set\:DCL::CGenome}
{\xe \v DCL::CGenome\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CGenome::set (const {\b CNeuralNetworkFeedForward} & neuralNetwork, double dNetworkFitness)}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this genome to hold the given fitness and weights stored in the given neural network. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i neuralNetwork} \cell }{The neural network to use for it's weights \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dNetworkFitness} \cell }{The networks fitness score. \cell }
{\row }
}
}{
Definition at line {\b 32} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\xe \v set\:DCL::CGenome}
{\xe \v DCL::CGenome\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CGenome::set (std::vector< double > & vecNeuralNetworkWeights, double dNetworkFitness)}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this genome to the given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecNeuralNetworkWeights} \cell }{The neural network weights of it's neurons. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dNetworkFitness} \cell }{The network's fitness score \cell }
{\row }
}
}{
Definition at line {\b 26} of file {\b GeneticAlgorithm.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v operator<\:DCL::CGenome}
{\xe \v DCL::CGenome\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator< (const {\b CGenome} & lhs, const {\b CGenome} & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operator overload '<' for sorting a vector of this class's objects by fitness. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{Left hand side of operator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{Right hand side of operator \cell }
{\row }
}
}{
Definition at line {\b 67} of file {\b GeneticAlgorithm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dFitness\:DCL::CGenome}
{\xe \v DCL::CGenome\:dFitness}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DCL::CGenome::dFitness}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This should be set to hold the final fitness score of the entity owning the neural network. }}\par
{
Definition at line {\b 61} of file {\b GeneticAlgorithm.h}.}\par
}
{\xe \v vecWeights\:DCL::CGenome}
{\xe \v DCL::CGenome\:vecWeights}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<double> DCL::CGenome::vecWeights}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This should be filled with the weights from a neural network by calling it's getNeuronWeights() method. }}\par
{
Definition at line {\b 60} of file {\b GeneticAlgorithm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b GeneticAlgorithm.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/GeneticAlgorithm.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CImage Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CImage}
{\xe \v DCL::CImage}
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class for creating/loading/saving/modifying 2D images. }}\par
{
{\f2 #include <Image.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CImage} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor whereby the image is initially empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CImage} & {\b operator=} (const {\b CImage} &other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this image to the one on the right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Free image and memory so that the image is empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createBlank} (unsigned int iWidth, unsigned int iHeight, unsigned short iNumChannels)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a blank image. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b load} (const std::string &strFilename, bool bFlipForOpenGL=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to load the image data from a file stored on disk. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInfo} (const std::string &strFilename, int &iWidth, int &iHeight, int &iComponentCount)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to read only the image width and height from the given filename, which is faster than loading the whole thing in. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b saveAsBMP} (const std::string &strFilename, bool bFlipOnSave=false) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save image as BMP file to disk. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b saveAsJPG} (const std::string &strFilename, bool bFlipOnSave=false, int iQuality=100) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save image to JPG file to disk. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b saveAsPNG} (const std::string &strFilename, bool bFlipOnSave=false) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save image to PNG file to disk. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b saveAsTGA} (const std::string &strFilename, bool bFlipOnSave=false) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save image to TGA file to disk. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fill} (unsigned char ucRed, unsigned char ucGreen, unsigned char ucBlue, unsigned char ucAlpha=255)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the image with the given colour values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char * {\b getData} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return pointer to image data for manual modification. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getDataSize} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get size of image data in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getWidth} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get width of image. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getHeight} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get height of image. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b getDimensions} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the dimensions of the image as a {\b CVector2f}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getNumChannels} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of channels. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getDimsArePowerOfTwo} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this texture's width and height are to power of two. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPixel} (int iX, int iY, unsigned char r, unsigned char g, unsigned char b, unsigned char a)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets pixel at given coordinate to given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getPixel} (int iX, int iY, unsigned char &r, unsigned char &g, unsigned char &b, unsigned char &a) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets pixel values at specified position. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swapRedAndBlue} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swap red and blue colour components around. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b flipVertically} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flip the image vertically. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invert} (bool bInvertColour=true, bool bInvertAlpha=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverts the colours of the image, AKA new colour = 255 - current colour. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b greyscaleSimple} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the image's RGB components to greyscale, simply finding mean average of RGB components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b greyscale} (float fRedSensitivity=0.299f, float fGreenSensitivity=0.587f, float fBlueSensitivity=0.144f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the image's RGB components to greyscale, taking into consideration the average human's eye sensitivity to the individual RGB components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b adjustBrightness} (int iAmount)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adjusts brightness of colour components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b adjustContrast} (int iAmount)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adjusts contrast of the colour components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copyTo} ({\b CImage} &destImage) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies this image into the one given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copyRectTo} ({\b CImage} &destImage, int iSrcPosX, int iSrcPosY, int iSrcWidth, int iSrcHeight, int iDestPosX, int iDestPosY) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies a rectangular region from this object, into the one given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copyToAddBorder} ({\b CImage} &outputImage) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the contents of this image into the outputImage and gives the output image a border. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rotateClockwise} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rotates the image 90 degrees clockwise. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b edgeDetect} ({\b CImage} &outputImage, unsigned char r, unsigned char g, unsigned char b)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Edge detection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAlphaChannel} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the alpha channel of the image, leaving the RGB components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copyAlphaChannelToRGB} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the alpha channel to each of the RGB components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalmap} ({\b CImage} &outputImage, float fScale=1.0f) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes a normal map used for normal mapping from this image and stores the result in outputImage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawColourWheel} (unsigned int iWidthAndHeightOfImage, unsigned char ucBrightness=255)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this image to the given width and height, sets it to have 4 colour channels and then draws a hue based colour wheel using the given brightness. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CColourf} {\b getColourWheelColour} (unsigned int iPositionX, unsigned int iPositionY, unsigned int iWidthAndHeightOfImage, unsigned char ucBrightness)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not 100% image related, but given an X and Y coordinate over an imaginary drawn colour wheel. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawGradient} (unsigned int iWidth, unsigned int iHeight, unsigned int iNumChannels, const {\b CColourf} &colour0, const {\b CColourf} &colour1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates this image with the specified values and draws a gradient between the two given colours. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawCircle} (unsigned int iWidthAndHeightOfImage, const {\b CColourf} &colourInner, const {\b CColourf} &colourOuter)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates this image with the specified values and draws a circle with the given colour values. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class for creating/loading/saving/modifying 2D images. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can read the following formats... JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib) PNG 1 / 2 / 4 / 8 / 16 - bit - per - channel TGA(not sure what subset, if a subset) BMP non - 1bpp, non - RLE PSD(composited view only, no extra channels, 8 / 16 bit - per - channel) GIF(*comp always reports as 4 - channel) HDR(radiance rgbE format) PIC(Softimage PIC) PNM(PPM and PGM binary only) Image pixels are stored in row first, then column. unsigned int iPixelIndex = iPixelPosX + (iPixelPosY * _miWidth); \par
}{
Definition at line {\b 29} of file {\b Image.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CImage\:DCL::CImage}
{\xe \v DCL::CImage\:CImage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CImage::CImage ()}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor whereby the image is initially empty. }}\par
{
Definition at line {\b 14} of file {\b Image.cpp}.}\par
}
{\xe \v ~CImage\:DCL::CImage}
{\xe \v DCL::CImage\:~CImage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CImage::~CImage ()}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b Image.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v adjustBrightness\:DCL::CImage}
{\xe \v DCL::CImage\:adjustBrightness}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::adjustBrightness (int iAmount)}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adjusts brightness of colour components. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iAmount} \cell }{Between -255 and 255, the amount to increase or decrease each of the colour components of the image\cell }
{\row }
}
Accepted range for iAmount can be between -255 to +255 which would make entire image totally black or white. If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 357} of file {\b Image.cpp}.}\par
}
{\xe \v adjustContrast\:DCL::CImage}
{\xe \v DCL::CImage\:adjustContrast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::adjustContrast (int iAmount)}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adjusts contrast of the colour components. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iAmount} \cell }{Between -100 and 109, the amount to adjust the contrast of the image\cell }
{\row }
}
Accepted range for iAmount is between -100 and +100 If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 380} of file {\b Image.cpp}.}\par
}
{\xe \v copyAlphaChannelToRGB\:DCL::CImage}
{\xe \v DCL::CImage\:copyAlphaChannelToRGB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::copyAlphaChannelToRGB (void )}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the alpha channel to each of the RGB components. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this image contains no data, or doesn't have 4 channels, an exception occurs. \par
}{
Definition at line {\b 619} of file {\b Image.cpp}.}\par
}
{\xe \v copyRectTo\:DCL::CImage}
{\xe \v DCL::CImage\:copyRectTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::copyRectTo ({\b CImage} & destImage, int iSrcPosX, int iSrcPosY, int iSrcWidth, int iSrcHeight, int iDestPosX, int iDestPosY) const}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies a rectangular region from this object, into the one given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i destImage} \cell }{The destination image to be copied to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iSrcPosX} \cell }{The bottom left position within the source image to copy from (a value of 0 would be left edge) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iSrcPosY} \cell }{The bottom left position within the source image to copy from (a value of 0 would be bottom edge) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iSrcWidth} \cell }{The width of the region to copy from the source image \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iSrcHeight} \cell }{The height of the region to copy from the source image \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iDestPosX} \cell }{The bottom left position within the destination image to copy to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iDestPosY} \cell }{The bottom left position within the destination image to copy to\cell }
{\row }
}
Automatic clipping is done so that if the source region doesn't fit into destination, it will be clipped. The destination image can be this image itself IE img.copyRectTo(img) destImage The destination image to copy the rectangular region of this object into iSrcPosX The bottom left position within the source image to copy from (a value of 0 would be left edge) iSrcPosY The bottom left position within the source image to copy from (a value of 0 would be bottom edge) iSrcWidth The width of the region to copy from the source image iSrcHeight The height of the region to copy from the source image iDestPosX The bottom left position within the destination image to copy to iDestPosY The bottom left position within the destination image to copy to If this image or the destination image contain no data, an exception occurs. \par
}{
Definition at line {\b 437} of file {\b Image.cpp}.}\par
}
{\xe \v copyTo\:DCL::CImage}
{\xe \v DCL::CImage\:copyTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::copyTo ({\b CImage} & destImage) const}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies this image into the one given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i destImage} \cell }{The destination image which will hold this image's contents.\cell }
{\row }
}
Silently fails if both this image and the one parsed are actually the same objects, or there is no image data to copy. If this image contains no data, an exception occurs. The destinationImage is totally replaced. \par
 \par
}{
Definition at line {\b 424} of file {\b Image.cpp}.}\par
}
{\xe \v copyToAddBorder\:DCL::CImage}
{\xe \v DCL::CImage\:copyToAddBorder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::copyToAddBorder ({\b CImage} & outputImage) const}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the contents of this image into the outputImage and gives the output image a border. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i outputImage} \cell }{The destination image\cell }
{\row }
}
Copies the contents of this image into the outputImage and gives the output image a border and sets the pixels around that border to be the same as the ones in this image's edge pixels, thereby making the output image have dimensions which are +2 of this one. This is typically used to simply calculating of stuff without having to take into consideration, edge cases. If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 504} of file {\b Image.cpp}.}\par
}
{\xe \v createBlank\:DCL::CImage}
{\xe \v DCL::CImage\:createBlank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::createBlank (unsigned int iWidth, unsigned int iHeight, unsigned short iNumChannels)}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a blank image. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iWidth} \cell }{The width of the new blank image in pixels \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iHeight} \cell }{The height of the new blank image in pixels \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumChannels} \cell }{The number of colour channels for the new image RGB if 3, RGBA if 4\cell }
{\row }
}
If already created, the previous image is freed Each channel contains black Acceptable number of channels may be 3 or 4 Both dimensions must be at least 1 iWidth The width of the image. iHeight The height of the image. Memory consumption examples... Each pixel is either RGB or RGBA and each is a byte, so and RGBA image is 4 bytes per pixel. An image of dimensions 512x512x4 is 1,048,576 bytes or 1024 KBytes or 1 MByte An image of dimensions 1024x1024x4 is 4,194,304 bytes or 4096 KB or 4 MB An image of dimensions 4096x4096x4 is 64MB An image of dimensions 16384x16384x4 is 1024MB AKA 1GB Throws exceptions if invalid params given. \par
}{
Definition at line {\b 48} of file {\b Image.cpp}.}\par
}
{\xe \v drawCircle\:DCL::CImage}
{\xe \v DCL::CImage\:drawCircle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::drawCircle (unsigned int iWidthAndHeightOfImage, const {\b CColourf} & colourInner, const {\b CColourf} & colourOuter)}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates this image with the specified values and draws a circle with the given colour values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iWidthAndHeightOfImage} \cell }{The width and height of the image \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i colourInner} \cell }{The inner colour of the circle \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i colourOuter} \cell }{The outer colour of the circle \cell }
{\row }
}
}{
Definition at line {\b 818} of file {\b Image.cpp}.}\par
}
{\xe \v drawColourWheel\:DCL::CImage}
{\xe \v DCL::CImage\:drawColourWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::drawColourWheel (unsigned int iWidthAndHeightOfImage, unsigned char ucBrightness = {\f2 255})}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this image to the given width and height, sets it to have 4 colour channels and then draws a hue based colour wheel using the given brightness. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iWidthAndHeightOfImage} \cell }{The dimensions of the image to be created. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucBrightness} \cell }{The brightness of the image. \cell }
{\row }
}
}{
Definition at line {\b 698} of file {\b Image.cpp}.}\par
}
{\xe \v drawGradient\:DCL::CImage}
{\xe \v DCL::CImage\:drawGradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::drawGradient (unsigned int iWidth, unsigned int iHeight, unsigned int iNumChannels, const {\b CColourf} & colour0, const {\b CColourf} & colour1)}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates this image with the specified values and draws a gradient between the two given colours. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iWidth} \cell }{The width of the image \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iHeight} \cell }{The height of the image \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumChannels} \cell }{The number of channels 3 or 4 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i colour0} \cell }{The first colour of the gradient \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i colour1} \cell }{The second colour of the gradient \cell }
{\row }
}
}{
Definition at line {\b 771} of file {\b Image.cpp}.}\par
}
{\xe \v edgeDetect\:DCL::CImage}
{\xe \v DCL::CImage\:edgeDetect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::edgeDetect ({\b CImage} & outputImage, unsigned char r, unsigned char g, unsigned char b)}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Edge detection. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i outputImage} \cell }{Holds the resulting image \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i r} \cell }{Red component which represents the "background colour" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i g} \cell }{Green component which represents the "background colour" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{Blue component which represents the "background colour"\cell }
{\row }
}
Given a colour value which represents the "background colour" of the image, this detects where the pixels in the image are next to this colour and sets the outputImage as white where the other coloured pixels meet this "background colour" I wish I could place images here in the code, as it'd be much easier to show what this does with images.\par
I can add images to the Doxygen generated documentation though and here they are...   Edges are detected by using the given colour value which should represent the colour of the image's background If this image contains no data, or doesn't have at least 3 channels, an exception occurs. \par
}{
Definition at line {\b 571} of file {\b Image.cpp}.}\par
}
{\xe \v fill\:DCL::CImage}
{\xe \v DCL::CImage\:fill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::fill (unsigned char ucRed, unsigned char ucGreen, unsigned char ucBlue, unsigned char ucAlpha = {\f2 255})}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the image with the given colour values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucRed} \cell }{Red colour intensity 0-255 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucGreen} \cell }{Green colour intensity 0-255 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucBlue} \cell }{Blue colour intensity 0-255 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucAlpha} \cell }{Alpha colour intensity 0-255\cell }
{\row }
}
If the image only contains 3 colour channels, the alpha component is ignored. Throws exception if image hasn't been created yet \par
}{
Definition at line {\b 157} of file {\b Image.cpp}.}\par
}
{\xe \v flipVertically\:DCL::CImage}
{\xe \v DCL::CImage\:flipVertically}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::flipVertically (void )}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flip the image vertically. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 251} of file {\b Image.cpp}.}\par
}
{\xe \v free\:DCL::CImage}
{\xe \v DCL::CImage\:free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::free (void )}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Free image and memory so that the image is empty. }}\par
{
Definition at line {\b 37} of file {\b Image.cpp}.}\par
}
{\xe \v getColourWheelColour\:DCL::CImage}
{\xe \v DCL::CImage\:getColourWheelColour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CColourf} DCL::CImage::getColourWheelColour (unsigned int iPositionX, unsigned int iPositionY, unsigned int iWidthAndHeightOfImage, unsigned char ucBrightness)}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not 100% image related, but given an X and Y coordinate over an imaginary drawn colour wheel. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPositionX} \cell }{The position within the colour wheel to sample \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPositionY} \cell }{The position within the colour wheel to sample \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iWidthAndHeightOfImage} \cell }{The width and height of the image \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ucBrightness} \cell }{The brightness of the image. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A CColour value which would represent the colour of the colour wheel at those X and Y coordinates.\par
}}No checking of incorrect position values. \par
}{
Definition at line {\b 745} of file {\b Image.cpp}.}\par
}
{\xe \v getData\:DCL::CImage}
{\xe \v DCL::CImage\:getData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char * DCL::CImage::getData (void ) const}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return pointer to image data for manual modification. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Unsigned char pointer to the image data.\par
}}Please, BE CAREFULL if you're using this method to directly access the image data. returns The pointer to the image's data. \par
 \par
}{
Definition at line {\b 189} of file {\b Image.cpp}.}\par
}
{\xe \v getDataSize\:DCL::CImage}
{\xe \v DCL::CImage\:getDataSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::CImage::getDataSize (void ) const}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get size of image data in bytes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The size of the image data in bytes \par
}}}{
Definition at line {\b 194} of file {\b Image.cpp}.}\par
}
{\xe \v getDimensions\:DCL::CImage}
{\xe \v DCL::CImage\:getDimensions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CImage::getDimensions (void ) const}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the dimensions of the image as a {\b CVector2f}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The dimensions of the image as a {\b CVector2f} \par
}}}{
Definition at line {\b 209} of file {\b Image.cpp}.}\par
}
{\xe \v getDimsArePowerOfTwo\:DCL::CImage}
{\xe \v DCL::CImage\:getDimsArePowerOfTwo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CImage::getDimsArePowerOfTwo (void ) const}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this texture's width and height are to power of two. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the image's dimensions are to the power or 2, IE 2x2, 4x4, 8x8, 16x16, or 256x64 etc.\par
}}Width and height dimensions although both have to be to the power of 2, do not have to be the same values as each other for this to return true. \par
}{
Definition at line {\b 221} of file {\b Image.cpp}.}\par
}
{\xe \v getHeight\:DCL::CImage}
{\xe \v DCL::CImage\:getHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::CImage::getHeight (void ) const}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get height of image. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The height of the image in pixels \par
}}}{
Definition at line {\b 204} of file {\b Image.cpp}.}\par
}
{\xe \v getNumChannels\:DCL::CImage}
{\xe \v DCL::CImage\:getNumChannels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::CImage::getNumChannels (void ) const}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of channels. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The number of channels of the image. \par
 \par
}}}{
Definition at line {\b 216} of file {\b Image.cpp}.}\par
}
{\xe \v getPixel\:DCL::CImage}
{\xe \v DCL::CImage\:getPixel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::getPixel (int iX, int iY, unsigned char & r, unsigned char & g, unsigned char & b, unsigned char & a) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets pixel values at specified position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iX} \cell }{The X position within the image to set. Range = 0 to image width-1 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iY} \cell }{The Y position within the image to set. Range = 0 to image height-1 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i r} \cell }{Unsigned char representing red colour intensity \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i g} \cell }{Unsigned char representing green colour intensity \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{Unsigned char representing blue colour intensity \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{Unsigned char representing alpha colour intensity\cell }
{\row }
}
Due to additional overhead of this method due to function calling and bounds checking, if you're wanting to modify many pixels, it's best to use the "unsafe" {\b getData()} method. iX The X position of the pixel. Where a value of 0 = left edge of image. iY The Y position of the pixel. Where a value of 0 = bottom edge of image. r The colour will be held in here (Red). g The colour will be held in here (Green). b The colour will be held in here (Blue). a The colour will be held in here (Alpha). \par
 \par
}{
Definition at line {\b 425} of file {\b Image.h}.}\par
}
{\xe \v getWidth\:DCL::CImage}
{\xe \v DCL::CImage\:getWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::CImage::getWidth (void ) const}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get width of image. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The width of the image in pixels \par
}}}{
Definition at line {\b 199} of file {\b Image.cpp}.}\par
}
{\xe \v greyscale\:DCL::CImage}
{\xe \v DCL::CImage\:greyscale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::greyscale (float fRedSensitivity = {\f2 0.299f}, float fGreenSensitivity = {\f2 0.587f}, float fBlueSensitivity = {\f2 0.144f})}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the image's RGB components to greyscale, taking into consideration the average human's eye sensitivity to the individual RGB components. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Isn't working properly. \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fRedSensitivity} \cell }{Value between 0.0 and 1.0 to be used for the sensitivity of red \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fGreenSensitivity} \cell }{Value between 0.0 and 1.0 to be used for the sensitivity of green \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fBlueSensitivity} \cell }{Value between 0.0 and 1.0 to be used for the sensitivity of blue\cell }
{\row }
}
If default params are not used (They approximate the average human's eye sensitivity), they should be of unit length. If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 334} of file {\b Image.cpp}.}\par
}
{\xe \v greyscaleSimple\:DCL::CImage}
{\xe \v DCL::CImage\:greyscaleSimple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::greyscaleSimple (void )}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the image's RGB components to greyscale, simply finding mean average of RGB components. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For example. if R = 0, G = 30 and B = 90, then each of the RGB colours will be set to (0+30+90)/3 = 40 If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 311} of file {\b Image.cpp}.}\par
}
{\xe \v invert\:DCL::CImage}
{\xe \v DCL::CImage\:invert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::invert (bool bInvertColour = {\f2 true}, bool bInvertAlpha = {\f2 false})}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverts the colours of the image, AKA new colour = 255 - current colour. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bInvertColour} \cell }{If true, will invert the RGB colour components \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bInvertAlpha} \cell }{If true, will invert the alpha colour component\cell }
{\row }
}
If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 282} of file {\b Image.cpp}.}\par
}
{\xe \v load\:DCL::CImage}
{\xe \v DCL::CImage\:load}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CImage::load (const std::string & strFilename, bool bFlipForOpenGL = {\f2 false})}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to load the image data from a file stored on disk. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The name of the image file to load. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bFlipForOpenGL} \cell }{Will flip the image vertically if true \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
false if the image couldn't be loaded.\par
}}Depending upon the file name extension, determines the file type and loads it in. If the image couldn't be loaded, false is returned, else true The image is freed at the start of this method Loads image from file using the stb_image library \par
}{
Definition at line {\b 70} of file {\b Image.cpp}.}\par
}
{\xe \v loadInfo\:DCL::CImage}
{\xe \v DCL::CImage\:loadInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CImage::loadInfo (const std::string & strFilename, int & iWidth, int & iHeight, int & iComponentCount)}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to read only the image width and height from the given filename, which is faster than loading the whole thing in. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The filename containing the image \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iWidth} \cell }{Will hold the image's width \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iHeight} \cell }{Will hold the image's height \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iComponentCount} \cell }{Will hold the image's number of colour channels \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether the image's values were loaded or not \par
}}}{
Definition at line {\b 117} of file {\b Image.cpp}.}\par
}
{\xe \v normalmap\:DCL::CImage}
{\xe \v DCL::CImage\:normalmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::normalmap ({\b CImage} & outputImage, float fScale = {\f2 1.0f}) const}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes a normal map used for normal mapping from this image and stores the result in outputImage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i outputImage} \cell }{The image which will hold the normal map \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fScale} \cell }{Value between 0.0 to 1.0 to signify how "intense" the normals are.\cell }
{\row }
}
This image should be a heightmap, where each pixel represents the height of a surface. White being max height, black being the lowest. However, this image first creates a copy of itself in memory, then calls {\b greyscaleSimple()} on that to ensure proper computation of the normals. fScale should be between 0.0f and 1.0f and affects how "intense" the normals are generated. This value is clamped internally. Lower values increase the effect If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 634} of file {\b Image.cpp}.}\par
}
{\xe \v operator=\:DCL::CImage}
{\xe \v DCL::CImage\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CImage} & DCL::CImage::operator= (const {\b CImage} & other)}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this image to the one on the right. }}\par
{
Definition at line {\b 26} of file {\b Image.cpp}.}\par
}
{\xe \v removeAlphaChannel\:DCL::CImage}
{\xe \v DCL::CImage\:removeAlphaChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::removeAlphaChannel (void )}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the alpha channel of the image, leaving the RGB components. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this image contains no data, or doesn't have 4 channels, an exception occurs. \par
}{
Definition at line {\b 594} of file {\b Image.cpp}.}\par
}
{\xe \v rotateClockwise\:DCL::CImage}
{\xe \v DCL::CImage\:rotateClockwise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::rotateClockwise (void )}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rotates the image 90 degrees clockwise. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 544} of file {\b Image.cpp}.}\par
}
{\xe \v saveAsBMP\:DCL::CImage}
{\xe \v DCL::CImage\:saveAsBMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::saveAsBMP (const std::string & strFilename, bool bFlipOnSave = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save image as BMP file to disk. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The filename to save the image data to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bFlipOnSave} \cell }{If true, will flip the data vertically upon saving (Not the data in memory, just what's stored in the file) \cell }
{\row }
}
}{
Definition at line {\b 129} of file {\b Image.cpp}.}\par
}
{\xe \v saveAsJPG\:DCL::CImage}
{\xe \v DCL::CImage\:saveAsJPG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::saveAsJPG (const std::string & strFilename, bool bFlipOnSave = {\f2 false}, int iQuality = {\f2 100}) const}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save image to JPG file to disk. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The filename to save the image data to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bFlipOnSave} \cell }{If true, will flip the data vertically upon saving (Not the data in memory, just what's stored in the file) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iQuality} \cell }{The quality setting to use when saving the JPG file 0-100 \cell }
{\row }
}
}{
Definition at line {\b 136} of file {\b Image.cpp}.}\par
}
{\xe \v saveAsPNG\:DCL::CImage}
{\xe \v DCL::CImage\:saveAsPNG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::saveAsPNG (const std::string & strFilename, bool bFlipOnSave = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save image to PNG file to disk. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The filename to save the image data to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bFlipOnSave} \cell }{If true, will flip the data vertically upon saving (Not the data in memory, just what's stored in the file) \cell }
{\row }
}
}{
Definition at line {\b 143} of file {\b Image.cpp}.}\par
}
{\xe \v saveAsTGA\:DCL::CImage}
{\xe \v DCL::CImage\:saveAsTGA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::saveAsTGA (const std::string & strFilename, bool bFlipOnSave = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save image to TGA file to disk. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The filename to save the image data to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bFlipOnSave} \cell }{If true, will flip the data vertically upon saving (Not the data in memory, just what's stored in the file) \cell }
{\row }
}
}{
Definition at line {\b 150} of file {\b Image.cpp}.}\par
}
{\xe \v setPixel\:DCL::CImage}
{\xe \v DCL::CImage\:setPixel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::setPixel (int iX, int iY, unsigned char r, unsigned char g, unsigned char b, unsigned char a){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets pixel at given coordinate to given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iX} \cell }{The X position within the image to set. Range = 0 to image width-1 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iY} \cell }{The Y position within the image to set. Range = 0 to image height-1 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i r} \cell }{Unsigned char representing red colour intensity \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i g} \cell }{Unsigned char representing green colour intensity \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{Unsigned char representing blue colour intensity \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{Unsigned char representing alpha colour intensity\cell }
{\row }
}
Due to additional overhead of this method due to function calling and bounds checking, if you're wanting to modify many pixels, it's best to use the "unsafe" {\b getData()} method. iX The X position of the pixel. Where a value of 0 = left edge of image. iY The Y position of the pixel. Where a value of 0 = bottom edge of image. r The colour to set the pixel to (Red). g The colour to set the pixel to (Green). b The colour to set the pixel to (Blue). a The colour to set the pixel to (Alpha). \par
 \par
}{
Definition at line {\b 397} of file {\b Image.h}.}\par
}
{\xe \v swapRedAndBlue\:DCL::CImage}
{\xe \v DCL::CImage\:swapRedAndBlue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImage::swapRedAndBlue (void )}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swap red and blue colour components around. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this image contains no data, an exception occurs. \par
}{
Definition at line {\b 234} of file {\b Image.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/{\b Image.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/Image.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CImageAtlasDetails Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CImageAtlasDetails}
{\xe \v DCL::CImageAtlasDetails}
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds information about each packed image inside an atlas image. }}\par
{
{\f2 #include <ImageAtlas.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b STexCoords}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds texture coordinates for each of the four corners of an image. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write} (std::ofstream &file)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes out this object's data to an already opened ofstream. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read} (std::ifstream &file)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in this object's data from an already opened ifsream. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b STexCoords} {\b sTexCoords}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The texture coordinates within the atlas image of the image. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b uiAtlasImage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The atlas image number which the image is located in. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bRotated}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the image was rotated clockwise to fit better or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b vDims}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The dimensions of the image in pixels. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b strImageFilename}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The filename which the image was created from. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds information about each packed image inside an atlas image. \par
}{
Definition at line {\b 17} of file {\b ImageAtlas.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v read\:DCL::CImageAtlasDetails}
{\xe \v DCL::CImageAtlasDetails\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImageAtlasDetails::read (std::ifstream & file)}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads in this object's data from an already opened ifsream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{An already opened ifstream handle.\cell }
{\row }
}
If an error occurs, so does an exception \par
}{
Definition at line {\b 23} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v write\:DCL::CImageAtlasDetails}
{\xe \v DCL::CImageAtlasDetails\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImageAtlasDetails::write (std::ofstream & file)}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes out this object's data to an already opened ofstream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{An already opened ofstream handle.\cell }
{\row }
}
If an error occurs, so does an exception \par
}{
Definition at line {\b 7} of file {\b ImageAtlas.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v bRotated\:DCL::CImageAtlasDetails}
{\xe \v DCL::CImageAtlasDetails\:bRotated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CImageAtlasDetails::bRotated}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the image was rotated clockwise to fit better or not. }}\par
{
Definition at line {\b 38} of file {\b ImageAtlas.h}.}\par
}
{\xe \v sTexCoords\:DCL::CImageAtlasDetails}
{\xe \v DCL::CImageAtlasDetails\:sTexCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b STexCoords} DCL::CImageAtlasDetails::sTexCoords}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The texture coordinates within the atlas image of the image. }}\par
{
Definition at line {\b 30} of file {\b ImageAtlas.h}.}\par
}
{\xe \v strImageFilename\:DCL::CImageAtlasDetails}
{\xe \v DCL::CImageAtlasDetails\:strImageFilename}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::CImageAtlasDetails::strImageFilename}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The filename which the image was created from. }}\par
{
Definition at line {\b 40} of file {\b ImageAtlas.h}.}\par
}
{\xe \v uiAtlasImage\:DCL::CImageAtlasDetails}
{\xe \v DCL::CImageAtlasDetails\:uiAtlasImage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::CImageAtlasDetails::uiAtlasImage}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The atlas image number which the image is located in. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If setting the maximum size of the atlas images to a small size, multiple atlas images may be created to accomodate all the images. \par
}{
Definition at line {\b 36} of file {\b ImageAtlas.h}.}\par
}
{\xe \v vDims\:DCL::CImageAtlasDetails}
{\xe \v DCL::CImageAtlasDetails\:vDims}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CImageAtlasDetails::vDims}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The dimensions of the image in pixels. }}\par
{
Definition at line {\b 39} of file {\b ImageAtlas.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/{\b ImageAtlas.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/ImageAtlas.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CImageAtlasPacker Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker}
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Image atlas class used to pack many smaller images into as few as possible larger atlas images. }}\par
{
{\f2 #include <ImageAtlas.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CImageAtlasPacker} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, does nothing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CImageAtlasPacker} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor, calls {\b reset()} to free all data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createAtlasImages} (const std::vector< std::string > &vstrImages, unsigned int uiMaxAtlasImageWidth, unsigned int uiMaxAtlasImageHeight, bool bAllowRotationOfImages, unsigned int uiImageSpacing=1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This creates texture atlas images. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets everything, freeing computed data and atlas images. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getNumAtlases} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of generated atlas images holding the individual images. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CImage} * {\b getAtlasImage} (unsigned int uiIndex) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the atlas image at the specified index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CImageAtlasDetails} > {\b getAllImageDetails} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of {\b CImageAtlasDetails} containing each image's details. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CImageAtlasDetails} > * {\b getAllImageDetailsPointer} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to _mvImageDetails containing each image's details. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getNumIndividualImages} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total number of individual images added to all the atlases. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CImageAtlasDetails} {\b getImageDetails} (const std::string &strImageName) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the named image's details. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CImageAtlasDetails} * {\b getImageDetailsPointer} (const std::string &strImageName) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the named image's details. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getImageExists} (const std::string &strImageName) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the named image exists or not. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Image atlas class used to pack many smaller images into as few as possible larger atlas images. \par
}{
Definition at line {\b 58} of file {\b ImageAtlas.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CImageAtlasPacker\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:CImageAtlasPacker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CImageAtlasPacker::CImageAtlasPacker ()}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, does nothing. }}\par
{
Definition at line {\b 39} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v ~CImageAtlasPacker\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:~CImageAtlasPacker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CImageAtlasPacker::~CImageAtlasPacker ()}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor, calls {\b reset()} to free all data. }}\par
{
Definition at line {\b 43} of file {\b ImageAtlas.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createAtlasImages\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:createAtlasImages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImageAtlasPacker::createAtlasImages (const std::vector< std::string > & vstrImages, unsigned int uiMaxAtlasImageWidth, unsigned int uiMaxAtlasImageHeight, bool bAllowRotationOfImages, unsigned int uiImageSpacing = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This creates texture atlas images. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vstrImages} \cell }{A vector of strings holding each individual image's filename which to add to the atlas image/s \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiMaxAtlasImageWidth} \cell }{The maximum allowed width of the created atlas image/s \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiMaxAtlasImageHeight} \cell }{The maximum allowed height of the created atlas image/s \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bAllowRotationOfImages} \cell }{Whether to allow rotation of individual images to obtain greater packing efficiency or not. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiImageSpacing} \cell }{Amount of spacing between individual images.\cell }
{\row }
}
We provide a vector of strings holding each individual image's filename. Each individual image can have different dimensions. We specify a maximum width and height that an individual atlas image may be. We specify whether to allow or disallow rotation of images to allow better fitting of the images. If rotation is enabled, the computed texture coordinates are rotated accordingly. After calling this, we can call the various other methods to get at the information If the vector of strings is empty, an exception occurs If an individual image's dimensions, including spacing is greater than the max atlas dimensions, an exception occurs. If all given images are the same dimensions, nothing is sorted. \par
}{
Definition at line {\b 48} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v getAllImageDetails\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:getAllImageDetails}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b CImageAtlasDetails} > DCL::CImageAtlasPacker::getAllImageDetails (void ) const}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of {\b CImageAtlasDetails} containing each image's details. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of {\b CImageAtlasDetails} which contain each image's details.\par
}}Call {\b createAtlasImages()} first. If no image data exists, an exception occurs. \par
}{
Definition at line {\b 385} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v getAllImageDetailsPointer\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:getAllImageDetailsPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b CImageAtlasDetails} > * DCL::CImageAtlasPacker::getAllImageDetailsPointer (void )}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to _mvImageDetails containing each image's details. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to _mvImageDetails contained each image's details\par
}}Call {\b createAtlasImages()} first. If no image data exists, an exception occurs. Usage: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid std::vector<CImageAtlasDetails>* pviad = _mAtlases.getAllImageDetailsPointer();\par
{\cf18 unsigned} {\cf18 int} uiLastImageIndex = pviad->size() - 1;\par
{\cf18 unsigned} {\cf18 int} uiAtlasNumber = (*pviad)[uiLastImageIndex].uiAtlasImage;\par
}
 or {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 unsigned} {\cf18 int} uiAtlasNumber = pviad->operator[](uiLastImageIndex).uiAtlasImage;\par
}
 or {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 unsigned} {\cf18 int} uiAtlasNumber = pviad[0][uiLastImageIndex].uiAtlasImage;\par
}
 \par
}{
Definition at line {\b 391} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v getAtlasImage\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:getAtlasImage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CImage} * DCL::CImageAtlasPacker::getAtlasImage (unsigned int uiIndex) const}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the atlas image at the specified index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiIndex} \cell }{The index of the atlas image to return a pointer to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to the {\b CImage} holding the atlas image.\par
}}Call {\b createAtlasImages()} first. If an invalid index is given, or no atlases exist, an exception occurs \par
}{
Definition at line {\b 378} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v getImageDetails\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:getImageDetails}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CImageAtlasDetails} DCL::CImageAtlasPacker::getImageDetails (const std::string & strImageName) const}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the named image's details. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strImageName} \cell }{The previously added image's name. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CImageAtlasDetails} holding the named image's details.\par
}}Call {\b createAtlasImages()} first. If an invalid image name is given, an exception occurs \par
}{
Definition at line {\b 402} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v getImageDetailsPointer\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:getImageDetailsPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CImageAtlasDetails} * DCL::CImageAtlasPacker::getImageDetailsPointer (const std::string & strImageName) const}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the named image's details. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strImageName} \cell }{The name of an image which was previously added. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CImageAtlasDetails} A pointer to the image's details.\par
}}Call {\b createAtlasImages()} first. If an invalid image name is given, an exception occurs \par
}{
Definition at line {\b 409} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v getImageExists\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:getImageExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CImageAtlasPacker::getImageExists (const std::string & strImageName) const}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the named image exists or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strImageName} \cell }{The name of the image we wish to determine whether it had been added or not. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the image exists, else false. \par
}}}{
Definition at line {\b 426} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v getNumAtlases\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:getNumAtlases}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::CImageAtlasPacker::getNumAtlases (void ) const}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of generated atlas images holding the individual images. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The number of generated atlas images holding the individual images\par
}}Call {\b createAtlasImages()} first. \par
}{
Definition at line {\b 373} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v getNumIndividualImages\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:getNumIndividualImages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::CImageAtlasPacker::getNumIndividualImages (void ) const}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total number of individual images added to all the atlases. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The total number of individual images added to the atlases\par
}}Call {\b createAtlasImages()} first. \par
}{
Definition at line {\b 397} of file {\b ImageAtlas.cpp}.}\par
}
{\xe \v reset\:DCL::CImageAtlasPacker}
{\xe \v DCL::CImageAtlasPacker\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CImageAtlasPacker::reset (void )}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets everything, freeing computed data and atlas images. }}\par
{
Definition at line {\b 416} of file {\b ImageAtlas.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/{\b ImageAtlas.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/ImageAtlas.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CLog Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CLog}
{\xe \v DCL::CLog}
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logging of text to a text file. }}\par
{
{\f2 #include <Logging.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLog} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add} (const std::string &string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add text to the log file and entries in memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the log file and all log entries in memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b deleteLogFile} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the current log file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLogFileName} (const std::string &strFilename="log.txt")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the log file name of the log file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getNumEntries} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return number of entries added via {\b add()} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getEntryText} (size_t entryIndex) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a log entry's text string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getEntryTime} (size_t entryIndex) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a log entry's time it was added since the log file was created as a formatted string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getEntryTimes} (size_t entryIndex, float &fSecondsOut, int &iMinutesOut, int &iHoursOut, int &iDaysOut, int &iWeeksOut) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stores a log entry's time it was added since the log file was created to the passed variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLogEntry} {\b getEntry} (size_t entryIndex) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a log entry. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logging of text to a text file. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logging of information to a text file and storage of each added log entry into memory. The default filename used for the log file is "log.txt" but can be changed with {\b setLogFileName()} Example... {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CLog myLog;     {\cf20 // Create a logging object. It'll create an empty "log.txt" file ready for use.}\par
\par
{\cf20 // If we wish to use a different name for this log file, then...}\par
myLog.setLogFileName({\cf22 "MyNewLogFile.txt"});\par
{\cf20 // The above will delete the old "log.txt" file and then create a new file named "MyNewLogFile.txt", ready for use.}\par
{\cf20 // This is usefull if we wish to have different log files, say perhaps one for audio, one for graphics, one for AI etc.}\par
\par
{\cf20 // Add an entry to the log file...}\par
myLog.add({\cf22 "Some text"}); {\cf20 // Text to be added to the log entry in the file and in memory}\par
\par
{\cf20 // All previously added entries with add() are stored in memory and can be accessed.}\par
{\cf20 // Only the text is stored, not whether a new line was added, nor the time it was added.}\par
{\cf20 // Example looping through these...}\par
{\cf19 for} ({\cf18 size_t} iEntry = 0; iEntry < myLog.getNumEntries(); iEntry++)\par
\{\par
    {\cf20 // Get the text for the indexed entry}\par
    {\cf20 // If iEntry is out of bounds, an exception occurs.}\par
    std::string strEntryText = myLog.getEntry(iEntry);\par
\par
    {\cf20 // Do something with the log entry text here.}\par
\}\par
}
 \par
}{
Definition at line {\b 66} of file {\b Logging.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CLog\:DCL::CLog}
{\xe \v DCL::CLog\:CLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CLog::CLog ()}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the log file name to "log.txt" and clears the file. \par
}{
Definition at line {\b 17} of file {\b Logging.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:DCL::CLog}
{\xe \v DCL::CLog\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CLog::add (const std::string & string)}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add text to the log file and entries in memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{Holds the text for this new log entry. \cell }
{\row }
}
}{
Definition at line {\b 23} of file {\b Logging.cpp}.}\par
}
{\xe \v clear\:DCL::CLog}
{\xe \v DCL::CLog\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CLog::clear (void )}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the log file and all log entries in memory. }}\par
{
Definition at line {\b 58} of file {\b Logging.cpp}.}\par
}
{\xe \v deleteLogFile\:DCL::CLog}
{\xe \v DCL::CLog\:deleteLogFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CLog::deleteLogFile (void )}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the current log file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether deletion was successfull.\par
}}Whatever the currently set log file name is set to, attempts to delete that file. Returns true if the deletion was successfull, else false. \par
}{
Definition at line {\b 66} of file {\b Logging.cpp}.}\par
}
{\xe \v getEntry\:DCL::CLog}
{\xe \v DCL::CLog\:getEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CLogEntry} DCL::CLog::getEntry (size_t entryIndex) const}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a log entry. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i entryIndex} \cell }{The index of the entry \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The found log entry.\par
}}If entryIndex is out of bounds, an exception occurs \par
}{
Definition at line {\b 128} of file {\b Logging.cpp}.}\par
}
{\xe \v getEntryText\:DCL::CLog}
{\xe \v DCL::CLog\:getEntryText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::CLog::getEntryText (size_t entryIndex) const}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a log entry's text string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i entryIndex} \cell }{The index of the entry \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A string holding the entry's text.\par
}}If entryIndex is out of bounds, an exception occurs \par
}{
Definition at line {\b 106} of file {\b Logging.cpp}.}\par
}
{\xe \v getEntryTime\:DCL::CLog}
{\xe \v DCL::CLog\:getEntryTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::CLog::getEntryTime (size_t entryIndex) const}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a log entry's time it was added since the log file was created as a formatted string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i entryIndex} \cell }{The index of the entry \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A string which represents the time since the log file was created, which the entry was added.\par
}}If entryIndex is out of bounds, an exception occurs \par
}{
Definition at line {\b 112} of file {\b Logging.cpp}.}\par
}
{\xe \v getEntryTimes\:DCL::CLog}
{\xe \v DCL::CLog\:getEntryTimes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CLog::getEntryTimes (size_t entryIndex, float & fSecondsOut, int & iMinutesOut, int & iHoursOut, int & iDaysOut, int & iWeeksOut) const}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stores a log entry's time it was added since the log file was created to the passed variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\cell }{{\i entryIndex} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i fSecondsOut} \cell }{Holds the number of seconds. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i iMinutesOut} \cell }{Holds the number of minutes. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i iHoursOut} \cell }{Holds the number of hours. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i iDaysOut} \cell }{Holds the number of days. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i iWeeksOut} \cell }{Holds the number of weeks.\cell }
{\row }
}
If entryIndex is out of bounds, an exception occurs \par
}{
Definition at line {\b 118} of file {\b Logging.cpp}.}\par
}
{\xe \v getNumEntries\:DCL::CLog}
{\xe \v DCL::CLog\:getNumEntries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t DCL::CLog::getNumEntries (void ) const}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return number of entries added via {\b add()} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current number of entries added via {\b add()} \par
}}}{
Definition at line {\b 101} of file {\b Logging.cpp}.}\par
}
{\xe \v setLogFileName\:DCL::CLog}
{\xe \v DCL::CLog\:setLogFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CLog::setLogFileName (const std::string & strFilename = {\f2 "log.txt"})}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the log file name of the log file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strFilename} \cell }{The filename to use for the log file.\cell }
{\row }
}
Will attempt to delete the current log file by calling {\b deleteLogFile()} before creating the newly named one. Also clears the newly named file. \par
}{
Definition at line {\b 93} of file {\b Logging.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Logging.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Logging.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CLogEntry Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CLogEntry}
{\xe \v DCL::CLogEntry}
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Log entry object which holds information about a single log entry. Used by the {\b CLog} class. }}\par
{
{\f2 #include <Logging.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b strText}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A string holding the text for this log entry. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b fTimeSeconds}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Seconds as clock) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iTimeMin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Minutes as clock) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iTimeHours}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Hours as clock) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iTimeDays}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Days as clock) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iTimeWeeks}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Weeks as clock) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b strTime}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added, formatted to a string. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Log entry object which holds information about a single log entry. Used by the {\b CLog} class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b CLog} class for more information. \par
}{
Definition at line {\b 23} of file {\b Logging.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CLogEntry\:DCL::CLogEntry}
{\xe \v DCL::CLogEntry\:CLogEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CLogEntry::CLogEntry ()}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b Logging.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v fTimeSeconds\:DCL::CLogEntry}
{\xe \v DCL::CLogEntry\:fTimeSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CLogEntry::fTimeSeconds}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Seconds as clock) }}\par
{
Definition at line {\b 29} of file {\b Logging.h}.}\par
}
{\xe \v iTimeDays\:DCL::CLogEntry}
{\xe \v DCL::CLogEntry\:iTimeDays}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CLogEntry::iTimeDays}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Days as clock) }}\par
{
Definition at line {\b 32} of file {\b Logging.h}.}\par
}
{\xe \v iTimeHours\:DCL::CLogEntry}
{\xe \v DCL::CLogEntry\:iTimeHours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CLogEntry::iTimeHours}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Hours as clock) }}\par
{
Definition at line {\b 31} of file {\b Logging.h}.}\par
}
{\xe \v iTimeMin\:DCL::CLogEntry}
{\xe \v DCL::CLogEntry\:iTimeMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CLogEntry::iTimeMin}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Minutes as clock) }}\par
{
Definition at line {\b 30} of file {\b Logging.h}.}\par
}
{\xe \v iTimeWeeks\:DCL::CLogEntry}
{\xe \v DCL::CLogEntry\:iTimeWeeks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CLogEntry::iTimeWeeks}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added (Weeks as clock) }}\par
{
Definition at line {\b 33} of file {\b Logging.h}.}\par
}
{\xe \v strText\:DCL::CLogEntry}
{\xe \v DCL::CLogEntry\:strText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::CLogEntry::strText}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A string holding the text for this log entry. }}\par
{
Definition at line {\b 28} of file {\b Logging.h}.}\par
}
{\xe \v strTime\:DCL::CLogEntry}
{\xe \v DCL::CLogEntry\:strTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::CLogEntry::strTime}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time since start of log file creation that log entry was added, formatted to a string. }}\par
{
Definition at line {\b 34} of file {\b Logging.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Logging.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Logging.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CMatrix Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CMatrix}
{\xe \v DCL::CMatrix}
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Matrix class. }}\par
{
{\f2 #include <Matrix.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMatrix} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets to identity matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const void {\b operator=} (const {\b CMatrix} &matrix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this matrix to the one on the right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CMatrix} {\b operator*} (const {\b CMatrix} &matrix) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply this matrix by another and return the result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const void {\b operator*=} (const {\b CMatrix} &matrix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply this matrix by another. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b CMatrix} &matrix) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares whether this matrix and the one to the right of the == operator are equal. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b CMatrix} &matrix) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares whether this matrix and the one to the right of the != operator are equal. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIdentity} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets matrix to identity matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZero} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the matrix with zeros. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const float src[16])\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this matrix from the given array of floats. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b CMatrix} &src)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix from the one given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMatrix} {\b get} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix from the one given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTranslation} (float fX, float fY, float fZ)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a glm matrix constructed from this one. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTranslation} (const {\b CVector3f} &vTrans)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the matrix to hold a translation transformation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScale} (float fX, float fY, float fZ)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the matrix to hold a scale transformation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScale} (const {\b CVector3f} &vTrans)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the matrix to hold a scale transformation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromAxisAngleDegrees} (const {\b CVector3f} &vAxis, float fAngleDegrees)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to hold a rotation transformation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromAxisAngleRadians} (const {\b CVector3f} &vAxis, float fAngleRadians)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to hold a rotation transformation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromQuaternion} (const {\b CQuaternion} &quaternion)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to hold a rotation transformation from a quaternion. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getRightVector} ({\b CVector3f} &vVec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given vector to hold this matrix's right vector/axis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getUpVector} ({\b CVector3f} &vVec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given vector to hold this matrix's up vector/axis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getForwardVector} ({\b CVector3f} &vVec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given vector to hold this matrix's forward vector/axis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMatrix} {\b transpose} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a matrix which is the transpose of this matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMatrix} {\b inverse} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a matrix which is the inverse of this matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMatrix} {\b multiply} (const {\b CMatrix} &matrix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies this matrix by the one given and returns the resulting matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b multiply} (const {\b CVector3f} &vector)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies the given vector by this matrix and returns the resulting vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMatrix} {\b multiply} (const float fScalar)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies each value in the matrix by the given scalar and returns the resulting matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setProjectionPerspective} (float fWidth=320.0f, float fHeight=240.0f, float fFieldOfViewInDegrees=55.0f, float fNearClippingPlaneDistance=1.0f, float fFarClippingPlaneDistance=1000.0f, float fAspectRatio=-1.0f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to represent a perspective projection matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setProjectionOrthographic} (float fWidth=320.0f, float fHeight=240.0f, float fLeft=0.0f, float fRight=-1.0f, float fTop=0.0f, float fBottom=-1.0f, float fNear=-1.0f, float fFar=1.0f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to represent an orthographic prjection matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setViewLookat} (const {\b CVector3f} &vEyePos, const {\b CVector3f} &vTarget, const {\b CVector3f} &vUp={\b CVector3f}(0.0f, 1.0f, 0.0f))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to represent a view matrix based upon glLookat. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float * {\b getFloat} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the float array containing the matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getTranslation} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current translation stored in the matrix as a {\b CVector3f}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuaternion}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Matrix class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Here's the matrix class used for applying transformations to vectors in 3D space and projecting points to 2D. This is a column-major matrix, compatible with OpenGL. So the elements of the matrix are stored like this.. [ 0 4 8 12 ] [ 1 5 9 13 ] [ 2 6 10 14 ] [ 3 7 11 15 ]\par
A matrix is a rectangular array of numbers layed out in rows and columns, like this... [1 0 0 0] [0 1 0 0] [0 0 1 0] [0 0 0 1]\par
The above is a special case of a matrix, known as an identity matrix where if multiplying a point/vector by it, will produce no translation, rotation or scale.\par
A translation in a matrix for x, y and z are stored in these values... [1 0 0 x] [0 1 0 y] [0 0 1 z] [0 0 0 1]\par
The scaling values are along the diagonal(scaling of x, y and z)... [x 0 0 0] [0 y 0 0] [0 0 z 0] [0 0 0 1]\par
The rotation part is more complicated since it uses cosine and sine functions and it changes depending on the axis... X - Axis Rotation Y - Axis Rotation Z - Axis Rotation [1 0 0 0] [cos(\'CE\'B8) 0 -sin(\'CE\'B8) 0] [cos(\'CE\'B8) sin(\'CE\'B8) 0 0] [0 cos(\'CE\'B8) sin(\'CE\'B8) 0] [0 1 0 0] [-sin(\'CE\'B8) cos(\'CE\'B8) 0 0] [0 -sin(\'CE\'B8) cos(\'CE\'B8) 0] [sin(\'CE\'B8) 0 cos(\'CE\'B8) 0] [0 0 1 0] [0 0 0 1] [0 0 0 1] [0 0 0 1]\par
The rotation matrices can be combined with the scale and translation matrix to create the final matrix.\par
Here's what a poor vertex has to go through to get to the screen... Vertex object coordinates x model matrix = world coordinates World coordinates x view matrix = eye coordinates Eye coordinates x projection matrix = clipping space coordinates Clipping space coordinates x perspective division = normalized device coordinates Normalized device coordinates x viewport transformation = screen coordinates\par
Vertex object coordinates are the vertex positions usually created in 3D modelling apps such as Blender. Model matrix is what translates, rotates and scales a vertex into the correct world position. View matrix is the camera position and created by the inverse of the camera position. We use the lookat() method to create a view matrix. Projection matrix is created using setProjectionOrtho() and {\b setProjectionPerspective()} depending upon how we wish the vertices to be transformed. The other stuff is performed in the vertex/fragment shaders.\par
Remember that the order of matrix multiplication is important and we go from right to left, like this in a shader... gl_Position = projectionMatrix * viewMatrix * modelMatrix * in_Position; \par
}{
Definition at line {\b 73} of file {\b Matrix.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CMatrix\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:CMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CMatrix::CMatrix ()}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets to identity matrix. }}\par
{
Definition at line {\b 12} of file {\b Matrix.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CMatrix} DCL::CMatrix::get (void ) const}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix from the one given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a matrix containing the contents of this matrix\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A matrix which holds this matrix's data \par
}}}{
Definition at line {\b 117} of file {\b Matrix.cpp}.}\par
}
{\xe \v getFloat\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:getFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float * DCL::CMatrix::getFloat (void ) const}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the float array containing the matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a pointer to the float array containing the matrix values \par
}}}{
Definition at line {\b 425} of file {\b Matrix.cpp}.}\par
}
{\xe \v getForwardVector\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:getForwardVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::getForwardVector ({\b CVector3f} & vVec) const}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given vector to hold this matrix's forward vector/axis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vVec} \cell }{A {\b CVector3f} which will hold this matrix's forward vector/axis\cell }
{\row }
}
This is used to obtain the orientation of the current state of the matrix \par
}{
Definition at line {\b 247} of file {\b Matrix.cpp}.}\par
}
{\xe \v getRightVector\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:getRightVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::getRightVector ({\b CVector3f} & vVec) const}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given vector to hold this matrix's right vector/axis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vVec} \cell }{A {\b CVector3f} which will hold this matrix's right vector/axis\cell }
{\row }
}
This is used to obtain the orientation of the current state of the matrix \par
}{
Definition at line {\b 233} of file {\b Matrix.cpp}.}\par
}
{\xe \v getTranslation\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:getTranslation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CMatrix::getTranslation (void ) const}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current translation stored in the matrix as a {\b CVector3f}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} holding the translation this matrix contains \par
}}}{
Definition at line {\b 488} of file {\b Matrix.cpp}.}\par
}
{\xe \v getUpVector\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:getUpVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::getUpVector ({\b CVector3f} & vVec) const}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given vector to hold this matrix's up vector/axis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vVec} \cell }{A {\b CVector3f} which will hold this matrix's up vector/axis\cell }
{\row }
}
This is used to obtain the orientation of the current state of the matrix \par
}{
Definition at line {\b 240} of file {\b Matrix.cpp}.}\par
}
{\xe \v inverse\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:inverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CMatrix} DCL::CMatrix::inverse (void )}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a matrix which is the inverse of this matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CMatrix} which is the inverse of this matrix\par
}}The inverse of a matrix is a matrix that, when multiplied by the original matrix, gives the identity matrix. \par
}{
Definition at line {\b 430} of file {\b Matrix.cpp}.}\par
}
{\xe \v multiply\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CMatrix} DCL::CMatrix::multiply (const {\b CMatrix} & matrix)}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies this matrix by the one given and returns the resulting matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i matrix} \cell }{A matrix to multiply this one by \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CMatrix} holding the result \par
}}}{
Definition at line {\b 264} of file {\b Matrix.cpp}.}\par
}
{\xe \v multiply\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CMatrix::multiply (const {\b CVector3f} & vector)}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies the given vector by this matrix and returns the resulting vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vector} \cell }{A {\b CVector3f} to multiply by this matrix \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} holding the result \par
}}}{
Definition at line {\b 289} of file {\b Matrix.cpp}.}\par
}
{\xe \v multiply\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CMatrix} DCL::CMatrix::multiply (const float fScalar)}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies each value in the matrix by the given scalar and returns the resulting matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fScalar} \cell }{The scalar value to multiply this matrix by \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The resulting matrix \par
}}}{
Definition at line {\b 298} of file {\b Matrix.cpp}.}\par
}
{\xe \v operator!=\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CMatrix::operator!= (const {\b CMatrix} & matrix) const}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares whether this matrix and the one to the right of the != operator are equal. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an exact compare, no teeny epsilon value. \par
}{
Definition at line {\b 60} of file {\b Matrix.cpp}.}\par
}
{\xe \v operator*\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CMatrix} DCL::CMatrix::operator* (const {\b CMatrix} & matrix) const}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply this matrix by another and return the result. }}\par
{
Definition at line {\b 22} of file {\b Matrix.cpp}.}\par
}
{\xe \v operator*=\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const void DCL::CMatrix::operator*= (const {\b CMatrix} & matrix)}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply this matrix by another. }}\par
{
Definition at line {\b 47} of file {\b Matrix.cpp}.}\par
}
{\xe \v operator=\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const void DCL::CMatrix::operator= (const {\b CMatrix} & matrix)}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this matrix to the one on the right. }}\par
{
Definition at line {\b 17} of file {\b Matrix.cpp}.}\par
}
{\xe \v operator==\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CMatrix::operator== (const {\b CMatrix} & matrix) const}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares whether this matrix and the one to the right of the == operator are equal. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an exact compare, no teeny epsilon value. \par
}{
Definition at line {\b 52} of file {\b Matrix.cpp}.}\par
}
{\xe \v set\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::set (const {\b CMatrix} & src)}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix from the one given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i src} \cell }{Matrix holding the values to set this matrix to. \cell }
{\row }
}
}{
Definition at line {\b 87} of file {\b Matrix.cpp}.}\par
}
{\xe \v set\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::set (const float src[16])}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this matrix from the given array of floats. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i src} \cell }{Array holding the values to set this matrix to. \cell }
{\row }
}
}{
Definition at line {\b 79} of file {\b Matrix.cpp}.}\par
}
{\xe \v setFromAxisAngleDegrees\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setFromAxisAngleDegrees}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setFromAxisAngleDegrees (const {\b CVector3f} & vAxis, float fAngleDegrees)}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to hold a rotation transformation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vAxis} \cell }{The axis with which to rotate around \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAngleDegrees} \cell }{The amount in degrees in which to rotate around the given axis\cell }
{\row }
}
The rotation is specified from the give amount of rotation in degrees around the given axis. Working with degrees is slightly slower than working in radians as when using degrees, {\b deg2rad()} is called. \par
}{
Definition at line {\b 179} of file {\b Matrix.cpp}.}\par
}
{\xe \v setFromAxisAngleRadians\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setFromAxisAngleRadians}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setFromAxisAngleRadians (const {\b CVector3f} & vAxis, float fAngleRadians)}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to hold a rotation transformation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vAxis} \cell }{The axis with which to rotate around \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAngleRadians} \cell }{The amount in radians in which to rotate around the given axis\cell }
{\row }
}
The rotation is specified from the give amount of rotation in radians around the given axis. Working with radians is slightly faster than working in degress as when using degrees, {\b deg2rad()} is called. \par
}{
Definition at line {\b 198} of file {\b Matrix.cpp}.}\par
}
{\xe \v setFromQuaternion\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setFromQuaternion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setFromQuaternion (const {\b CQuaternion} & quaternion)}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to hold a rotation transformation from a quaternion. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i quaternion} \cell }{The quaternion holding a rotation \cell }
{\row }
}
}{
Definition at line {\b 216} of file {\b Matrix.cpp}.}\par
}
{\xe \v setIdentity\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setIdentity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setIdentity (void )}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets matrix to identity matrix. }}\par
{
Definition at line {\b 68} of file {\b Matrix.cpp}.}\par
}
{\xe \v setProjectionOrthographic\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setProjectionOrthographic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setProjectionOrthographic (float fWidth = {\f2 320.0f}, float fHeight = {\f2 240.0f}, float fLeft = {\f2 0.0f}, float fRight = {\f2 -1.0f}, float fTop = {\f2 0.0f}, float fBottom = {\f2 -1.0f}, float fNear = {\f2 -1.0f}, float fFar = {\f2 1.0f})}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to represent an orthographic prjection matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fWidth} \cell }{If fRight or fBottom are given values < 0.0f, this is used for fRight \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fHeight} \cell }{If fRight or fBottom are given values < 0.0f, this is used for fBottom \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fLeft} \cell }{Typically 0.0f \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fRight} \cell }{Typically -1.0f \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fTop} \cell }{Typically 0.0f \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fBottom} \cell }{Typically -1.0f \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fNear} \cell }{Typically -1.0f \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fFar} \cell }{Typically 1.0f\cell }
{\row }
}
Passing in a value of 0.0f or less for fRight or fBottom will use values from fWidth and fHeight \par
}{
Definition at line {\b 352} of file {\b Matrix.cpp}.}\par
}
{\xe \v setProjectionPerspective\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setProjectionPerspective}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setProjectionPerspective (float fWidth = {\f2 320.0f}, float fHeight = {\f2 240.0f}, float fFieldOfViewInDegrees = {\f2 55.0f}, float fNearClippingPlaneDistance = {\f2 1.0f}, float fFarClippingPlaneDistance = {\f2 1000.0f}, float fAspectRatio = {\f2 -1.0f})}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to represent a perspective projection matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fWidth} \cell }{The width of the backbuffer/screen to use when calculating the aspect ration if fAspectRatio is given a value of < 0.0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fHeight} \cell }{The height of the backbuffer/screen to use when calculating the aspect ration if fAspectRatio is given a value of < 0.0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fFieldOfViewInDegrees} \cell }{The desired field of view, in degrees \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fNearClippingPlaneDistance} \cell }{The near clipping plane distance \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fFarClippingPlaneDistance} \cell }{The far clipping plane distance \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAspectRatio} \cell }{The aspect ratio, which if given a value < 0, will be computed from fWidth and fHeight\cell }
{\row }
}
Passing in a value of 0.0f or less for fAspectRatio will compute this value for us from the given (width / height) parameters \par
}{
Definition at line {\b 308} of file {\b Matrix.cpp}.}\par
}
{\xe \v setScale\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setScale (const {\b CVector3f} & vTrans)}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the matrix to hold a scale transformation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vTrans} \cell }{A {\b CVector3f} holding the scaling amounts \cell }
{\row }
}
}{
Definition at line {\b 172} of file {\b Matrix.cpp}.}\par
}
{\xe \v setScale\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setScale (float fX, float fY, float fZ)}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the matrix to hold a scale transformation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fX} \cell }{The amount to scale along X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fY} \cell }{The amount to scale along Y \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fZ} \cell }{The amount to scale along Z \cell }
{\row }
}
}{
Definition at line {\b 165} of file {\b Matrix.cpp}.}\par
}
{\xe \v setTranslation\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setTranslation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setTranslation (const {\b CVector3f} & vTrans)}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the matrix to hold a translation transformation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vTrans} \cell }{A {\b CVector3f} holding the translation to set \cell }
{\row }
}
}{
Definition at line {\b 158} of file {\b Matrix.cpp}.}\par
}
{\xe \v setTranslation\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setTranslation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setTranslation (float fX, float fY, float fZ)}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a glm matrix constructed from this one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the matrix to hold a translation transformation\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fX} \cell }{X translation amount \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fY} \cell }{Y translation amount \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fZ} \cell }{Z translation amount \cell }
{\row }
}
}{
Definition at line {\b 151} of file {\b Matrix.cpp}.}\par
}
{\xe \v setViewLookat\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setViewLookat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setViewLookat (const {\b CVector3f} & vEyePos, const {\b CVector3f} & vTarget, const {\b CVector3f} & vUp = {\f2 {\b CVector3f}(0.0f,\~ 1.0f,\~ 0.0f)})}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the matrix to represent a view matrix based upon glLookat. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vEyePos} \cell }{The eye position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vTarget} \cell }{The target position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vUp} \cell }{The up vector\cell }
{\row }
}
vUp should be normalised \par
}{
Definition at line {\b 394} of file {\b Matrix.cpp}.}\par
}
{\xe \v setZero\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:setZero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CMatrix::setZero (void )}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the matrix with zeros. }}\par
{
Definition at line {\b 74} of file {\b Matrix.cpp}.}\par
}
{\xe \v transpose\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:transpose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CMatrix} DCL::CMatrix::transpose (void )}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a matrix which is the transpose of this matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CMatrix} which is the transpose of this matrix\par
}}The transpose of a matrix is obtained by flipping the matrix over its diagonal. Which means the rows become columns and the columns become rows. The transpose of a matrix has some useful properties such as reversing the order of multiplication, preserving the trace and determinant, changing the orientation of vectors and converting matrixs between column major and row major. \par
}{
Definition at line {\b 254} of file {\b Matrix.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v CQuaternion\:DCL::CMatrix}
{\xe \v DCL::CMatrix\:CQuaternion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b CQuaternion}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Matrix.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Matrix.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Matrix.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CNeuralNetworkFeedForward Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward}
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a "feed forward" neural network. }}\par
{
{\f2 #include <NeuralNetFeedForward.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNeuralNetworkFeedForward} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNeuralNetworkFeedForward} (int iNumInputs, int iNumOutputs, int iNumLayers, int iNumNeuronsPerLayer)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create} (int iNumInputs, int iNumOutputs, int iNumLayers, int iNumNeuronsPerLayer)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates/recreates the network. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b getNeuronWeights} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector holding all the weights of all the neurons in each of the layers, including the output layer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getNumberOfWeights} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of weights of all the neurons in each of the layers, including the output layer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b replaceWeights} (const std::vector< double > &newWeights)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces the weights of all the neurons in each of the layers with the ones given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b update} (std::vector< double > &vecInputs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of inputs, updates the neural network and returns the output values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWeightBias} (double dWeightBias=-1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the bias which is used during update when computing the output for a neuron (weight * input) * bias. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSigmoidResponse} (double dResponse=1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the response value used by the sigmoid function which sets the shape of the curve produced from the sigmoid function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b calculateSplitPoints} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate splits points used by the genetic algorithm training class. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a "feed forward" neural network. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A feed forward neural network is one whereby the inputs go into the network and move along in one direction towards the outputs. The advantages of this is speed. The disadvantages is that it is not as complex. A neural network, regardless of it's type, simulates connections and firings between neurons in a biological brain.\par
Here's a short list of animals and the approximate number of neurons within their minds... Killer whale: 43 100 000 000 Dolphin: 18 750 000 000 Human: 16 340 000 000 Bottlenose dolphin: 12 700 000 000 Gorilla (Western): 9 100 000 000 Asian elephant: 6 775 000 000 Red and green macaw: 2 646 000 000 Giraffe: 1 731 000 000 Snowy old: 1 270 000 000 German shepherd: 885 460 000 Lion: 545 240 000 Pig: 425 000 000 Brown bear: 250 970 000 House cat: 249 830 000 Mallard duck: 112 255 000 Common wood pigeon: 51 325 000 Brown rat: 31 000 000 Golden hamster: 17 000 000 Bat: 6 000 000 Ant: 250 000 Cockroach: 200 000 Honey bee: 170 000 Cricket: 50 000 Jelly fish: 5 600 Common fruit fly: 2 500 Starfish: 500 Tardigrade: 200 Sea sponge: 0\par
We won't be simulating the mind of a killer whale any time soon, but the above list gives us an insight into how complex these creatures' minds are.\par
In a human mind, each neuron is connected via its dendrites to approximately 10,000 other neurons. This means that it's possible to have 1,000,000,000,000,000 connections!\par
A brain\'92s neurons either fire or they don\'92t. The strength of the emitted signal does not vary, only the frequency. The neuron sums all the incoming signals from the synapses and if the total signal exceeds a threshold value, the neuron fires and an electrical signal is sent shooting down the axon. Also, each neuron operates at around 100Hz.\par
Obviously, we can't use millions of neurons, but with a number as small as just ten, we are able to get some incredibly interesting behaviour.\par
The great thing about all these neurons is that they are great for generalizing. and if trained well, can exhibit fantastic creature like behaviour. Neural networks are commonly used for pattern recognition. This is because they are great at mapping an input state (the pattern it\'92s trying to recognize) to an output state (the pattern it has been trained to recognize)\par
Let\'92s take the example of character recognition. Imagine an LED panel made up of a grid of lights 8\'D78. Each light can be on or off, so the panel can be used to display the numbers 0 through to 9. To solve the problem, a network must be designed which will accept the state of the panel as an input and then output either a one or a zero. A one to indicate that, for example, the character 7 is being displayed and zero if it thinks it is not. The neural net will have 64 inputs, a layer of neurons, all feeding their output into just one neuron in the output layer. Once the neural network has been setup with the inputs, layers and output, it must be trained to recognize the character 7. One way of doing this is to initialize the neural net with random weights and then feed it a series of inputs which represent the different characters shown on the panel. For each character, we check to see what it's output is and adjust the weights accordingly. If the input pattern we feed it is not a 7, then we know the neural network should output a zero. So for every non 7 character, the weights are adjusted slightly so the output tends toward zero. When it\'92s presented with a pattern that represents the character 7, the weights are adjusted so the output tends toward the number one.\par
We could increase the number of outputs to ten. Then it would be possible to train the network to recognize all the digits 0 through 9. But let's go even more nuts! Let\'92s increase the outputs so the entire alphabet can be recognized. This is how handwriting recognition works. For each character, the network is trained to recognize many different versions of a letter. Eventually the network will not only be able to recognize the letters it has been trained with, but it will also be able to generalize. That is, if a letter is drawn slightly differently from the letters used during training, the network will stand a pretty good chance of recognizing it.\par
Not only can a network be used for recognition of characters, but any type of image. People's faces, photos of animals or objects. A network can also even be used for horse racing prediction and, interesting to us, game object navigation (flocking, avoidance, moving towards food, away from enemies) and more!\par
This type of network training is called "Supervised training" and the data used to train it is called a "training set".\par
Now let's get back to programming... We simulate all these neurons and their connections (On a much smaller scale) within this class. Each neuron can have inputs which are either on or off, 0 or 1 and they are scaled by a weight. Each of these weights are summed by their connected neuron and if the sum is over a certain threshold, the neuron fires. Just like a biological neuron, kinda:) The inputs can be positive or negative so can contribute towards or against a neuron firing. A feed forward network has it's inputs at one end and then one or more layers of neurons, with the initial layer taking and summing the inputs, firing or not and then sending that onto the next layer of neurons until the final layer is reached. Each neuron in each layer is connected to each and every neuron in the next layer. The outputs of the final neuron layer are then retrieved by use to interprete however we choose.\par
The outputs of a network are either 0 or 1, however, we can modify them so that the output is S shaped, with the values being around 0.5. To do this, we use a sigma function, sigma being a Greek word for something which is S shaped. We can then use these modified output values as anything we like, for example, the amount of rotation around an axis, or velocity increase/decrease, or whether to fire a weapon and more.\par
When using the sigmoid method, it requires a value named response. This modifies the curve of the output value and is typically set to 1. Larger values produce a smoother curve where the values tend towards a straight line, whereas smaller values produce a tighter curve where the value centres more towards 0.5.\par
When choosing which inputs to use, the fewer the better because the network won't have to "work as hard" to find a relationship between them all. So for example, if we're trying to make some game entity move towards certain objects, instead of specifying lots of inputs such as entity positions(x and y), vectors towards the objects (also x,y) and the entity's direction vector (another x and y), we could more efficiently give the network just a single float for it's rotation and a single float which represents the angle between the rotation of the entity and the object instead. These fewer inputs still represent all the information needed, but as there are less of them, the network will be able to find the relationship between them easier. And with this, the network can contain fewer neurons and be faster to compute as a result.\par
Inputs should each be given, which are around the same scale, for example if a vector was given to a target and it wasn't normalized, and another input was given, perhaps say the entity's normalized direction vector, the vector with the larger magnitude would have a much greater impact on the neural network than the entity's direction vector and as a result, the network may have a really hard time trying to find a relationship between them. Another great tip is that sometimes, centering the inputs around zero give better results.\par
What about the number of neurons and number of layers? What should we choose there? It's pretty much down to trial and error and getting a feel for how the network is behaving. Typically, one layer is enough. As for the number of neurons, yup, same again, trial and error. However, too few and the network won't stand a chance at giving good outputs and too many, well, it'll be OK, but it will be slower to compute.\par
So with all that out of the way, how do we actually use them? We create a network, choosing the number of inputs we'll give it, the number of layers, the number of neurons in each layer and the number of outputs. We then use another class, to train the network. Then once the we've found networks which perform as we wish, we can then save those best performing networks to a file. Then in our game/program, we can create a network, for each entity in our program, load the networks weights and configuration from the file and then update it, passing it it's input we used during training and getting the outputs and applying those the same we did during training, nice.\par
At the moment, the training class we use is in {\b geneticAlgorithm.h}/cpp, go there to see more detail on how we train the networks. \par
}{
Definition at line {\b 199} of file {\b NeuralNetFeedForward.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CNeuralNetworkFeedForward\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:CNeuralNetworkFeedForward}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CNeuralNetworkFeedForward::CNeuralNetworkFeedForward ()}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets to default values. \par
}{
Definition at line {\b 27} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\xe \v CNeuralNetworkFeedForward\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:CNeuralNetworkFeedForward}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CNeuralNetworkFeedForward::CNeuralNetworkFeedForward (int iNumInputs, int iNumOutputs, int iNumLayers, int iNumNeuronsPerLayer)}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumInputs} \cell }{The number of inputs this network will have. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumOutputs} \cell }{The number of outputs this network will have. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumLayers} \cell }{The number of neuron layers this network will have. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumNeuronsPerLayer} \cell }{The number of neurons per layer this network will have.\cell }
{\row }
}
Sets values to the ones given \par
}{
Definition at line {\b 32} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v calculateSplitPoints\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:calculateSplitPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > DCL::CNeuralNetworkFeedForward::calculateSplitPoints (void )}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate splits points used by the genetic algorithm training class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of ints holding the split points between individual neurons.\par
}}This returns points in the weights vector which are spaced out between each neuron. This makes it so that when we split the weights of the parents, when creating child networks, the splits are between neurons, rather than ANY position which could be between some of the weights of a single neuron. If this happened, that individual neuron when passed on to the child, could be considered "mutated", as we are not passing on a whole neuron, only a part of it. \par
}{
Definition at line {\b 201} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\xe \v create\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CNeuralNetworkFeedForward::create (int iNumInputs, int iNumOutputs, int iNumLayers, int iNumNeuronsPerLayer)}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates/recreates the network. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumInputs} \cell }{The number of inputs this network will have. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumOutputs} \cell }{The number of outputs this network will have. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumLayers} \cell }{The number of neuron layers this network will have. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumNeuronsPerLayer} \cell }{The number of neurons per layer this network will have. \cell }
{\row }
}
}{
Definition at line {\b 37} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\xe \v getNeuronWeights\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:getNeuronWeights}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > DCL::CNeuralNetworkFeedForward::getNeuronWeights (void ) const}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector holding all the weights of all the neurons in each of the layers, including the output layer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector holding all the weights of this network. \par
}}}{
Definition at line {\b 83} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\xe \v getNumberOfWeights\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:getNumberOfWeights}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CNeuralNetworkFeedForward::getNumberOfWeights (void ) const}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of weights of all the neurons in each of the layers, including the output layer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The number of weights in this network. \par
}}}{
Definition at line {\b 103} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\xe \v replaceWeights\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:replaceWeights}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CNeuralNetworkFeedForward::replaceWeights (const std::vector< double > & newWeights)}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces the weights of all the neurons in each of the layers with the ones given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newWeights} \cell }{A vector of doubles which hold the values of the new weights. \cell }
{\row }
}
}{
Definition at line {\b 122} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\xe \v setSigmoidResponse\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:setSigmoidResponse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CNeuralNetworkFeedForward::setSigmoidResponse (double dResponse = {\f2 1})}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the response value used by the sigmoid function which sets the shape of the curve produced from the sigmoid function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dResponse} \cell }{The response value used by the sigmoid function which sets the shape of the curve produced from the sigmoid function.\cell }
{\row }
}
Higher values, flatten the curve, lower ones tighten it. A default value of 1 is usually used. Do not set it to zero, this'll create a divide by zero error. (Actually, an exception occurs) \par
}{
Definition at line {\b 195} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\xe \v setWeightBias\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:setWeightBias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CNeuralNetworkFeedForward::setWeightBias (double dWeightBias = {\f2 -1})}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the bias which is used during update when computing the output for a neuron (weight * input) * bias. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dWeightBias} \cell }{The bias used during updating the network and computing the output for each of it's neurons (weight * input) * bias.\cell }
{\row }
}
This is typically set to -1 and left alone. \par
}{
Definition at line {\b 190} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\xe \v update\:DCL::CNeuralNetworkFeedForward}
{\xe \v DCL::CNeuralNetworkFeedForward\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > DCL::CNeuralNetworkFeedForward::update (std::vector< double > & vecInputs)}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a vector of inputs, updates the neural network and returns the output values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecInputs} \cell }{A vector holding each of the input values for the network. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of doubles holding the output values of the network.\par
}}If invalid number of inputs is given, an exception occurs \par
}{
Definition at line {\b 141} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b NeuralNetFeedForward.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CNeuron Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CNeuron}
{\xe \v DCL::CNeuron}
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron of a neural network. }}\par
{
{\f2 #include <NeuralNetFeedForward.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNeuron} (int iNumInputs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b mvecInputWeights}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the weight values for each of the inputs this neuron has and also holds the bias of the neuron at the end of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b miNumInputs}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This holds the number of inputs and weights this neuron has. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron of a neural network. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It represents a single neuron and holds the weights for each input into the neuron as well as the neuron's bias. \par
}{
Definition at line {\b 17} of file {\b NeuralNetFeedForward.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CNeuron\:DCL::CNeuron}
{\xe \v DCL::CNeuron\:CNeuron}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CNeuron::CNeuron (int iNumInputs)}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumInputs} \cell }{The number of inputs this neuron has.\cell }
{\row }
}
Sets the number of inputs this neuron has, creates each neuron and bias value for the neuron and sets them all to have random values between -1 and 1 \par
}{
Definition at line {\b 7} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v miNumInputs\:DCL::CNeuron}
{\xe \v DCL::CNeuron\:miNumInputs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CNeuron::miNumInputs}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This holds the number of inputs and weights this neuron has. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It actually has the number of inputs + 1, as we need an additional weight for the bias of the neuron. We could just call vecInputsWeights.size(), but for speed purposes, we store the value here. \par
}{
Definition at line {\b 37} of file {\b NeuralNetFeedForward.h}.}\par
}
{\xe \v mvecInputWeights\:DCL::CNeuron}
{\xe \v DCL::CNeuron\:mvecInputWeights}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<double> DCL::CNeuron::mvecInputWeights}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the weight values for each of the inputs this neuron has and also holds the bias of the neuron at the end of the vector. }}\par
{
Definition at line {\b 29} of file {\b NeuralNetFeedForward.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b NeuralNetFeedForward.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CNeuronLayer Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CNeuronLayer}
{\xe \v DCL::CNeuronLayer}
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron layer. }}\par
{
{\f2 #include <NeuralNetFeedForward.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNeuronLayer} (int iNumNeurons, int iNumInputsPerNeuron)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CNeuron} > {\b mvecNeurons}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds each neuron in this layer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b miNumNeurons}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This holds the number of neurons in this layer. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron layer. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This holds a layer of neurons \par
}{
Definition at line {\b 43} of file {\b NeuralNetFeedForward.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CNeuronLayer\:DCL::CNeuronLayer}
{\xe \v DCL::CNeuronLayer\:CNeuronLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CNeuronLayer::CNeuronLayer (int iNumNeurons, int iNumInputsPerNeuron)}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumNeurons} \cell }{The number of neurons this layer will have \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNumInputsPerNeuron} \cell }{The number of inputs each neuron of this layer will have.\cell }
{\row }
}
Sets the number of neurons in this layer. \par
}{
Definition at line {\b 18} of file {\b NeuralNetFeedForward.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v miNumNeurons\:DCL::CNeuronLayer}
{\xe \v DCL::CNeuronLayer\:miNumNeurons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CNeuronLayer::miNumNeurons}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This holds the number of neurons in this layer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We could just call mvecNeurons.size(), but for speed purposes, we store the value here. \par
}{
Definition at line {\b 61} of file {\b NeuralNetFeedForward.h}.}\par
}
{\xe \v mvecNeurons\:DCL::CNeuronLayer}
{\xe \v DCL::CNeuronLayer\:mvecNeurons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b CNeuron}> DCL::CNeuronLayer::mvecNeurons}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds each neuron in this layer. }}\par
{
Definition at line {\b 55} of file {\b NeuralNetFeedForward.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/{\b NeuralNetFeedForward.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CNewClassTemplate Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CNewClassTemplate}
{\xe \v DCL::CNewClassTemplate}
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. }}\par
{
{\f2 #include <NewFileTemplate.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b someMethod} (int paramName, int &paramINOUT)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b fSomeMember}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A public member. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description goes here {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 int} iSomeCode = 0;\par
}
 \par
}{
Definition at line {\b 19} of file {\b NewFileTemplate.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v someMethod\:DCL::CNewClassTemplate}
{\xe \v DCL::CNewClassTemplate\:someMethod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CNewClassTemplate::someMethod (int paramName, int & paramINOUT){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\cell }{{\i paramName} \cell }{Description of parameter goes here \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i paramINOUT} \cell }{Specifies in or out, or both for a parameter that's either a pointer or a reference \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
What the method returns, if anything.\par
}}Detailed description text goes here \par
}{
Definition at line {\b 29} of file {\b NewFileTemplate.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v fSomeMember\:DCL::CNewClassTemplate}
{\xe \v DCL::CNewClassTemplate\:fSomeMember}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CNewClassTemplate::fSomeMember}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A public member. }}\par
{
Definition at line {\b 34} of file {\b NewFileTemplate.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/{\b NewFileTemplate.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::COctTree Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::COctTree}
{\xe \v DCL::COctTree}
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D spatial partitioning class. }}\par
{
{\f2 #include <OctTree.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b COctTree} (int iMaxEntitiesPerNode=10, float fSizeIncreaseMultiplier=2.0f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~COctTree} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (int iMaxEntitiesPerNode=10, float fSizeIncreaseMultiplier=2.0f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise the oct tree using the new given settings. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the root node and in turn all of it's children and all entities. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addEntity} (const std::string &strName, const {\b CVector3f} &vPosition, int iUserData=0, void *pUserData=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add entity to the oct tree. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeEntity} (const std::string &strName)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the named entity from the tree. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getEntityExists} (const std::string &strName) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the named entity exists or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAllEntities} (bool bResetTree=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all entities from the tree and depending upon the passed bool, resets the tree to contain just the root node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEntityPosition} (const std::string &strName, const {\b CVector3f} &vNewPosition)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set an existing entity's position to the one given, moving to the correct node if needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getEntityPosition} (const std::string &strName, {\b CVector3f} &vPosition) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given vector to the named entity's position. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b COctTreeNode} * > {\b getNodesWithEntities} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of COctTreeNodes which holds all nodes which have entities in them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b COctTreeNode} * > {\b getNodesWithEntitiesWhichIntersect} (const {\b CAABB} &aabb) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of COctTreeNodes which holds all nodes which intersect with the given AABB and have entities. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b COctTreeNode} * > {\b getNodesWithEntitiesWhichIntersect} (const {\b CFrustum} &frustum) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of COctTreeNodes which holds all nodes which intersect with the given {\b CFrustum} and have entities. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b COctTreeEntity} * > {\b getEntitiesWithinRange} (const {\b CVector3f} &vPosition, float fRange) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within range of the given position. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b COctTreeEntity} * > {\b getEntitiesWithinAABB} (const {\b CAABB} &aabb) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within the given {\b CAABB}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b COctTreeEntity} * > {\b getEntitiesWithinFrustum} (const {\b CFrustum} &frustum) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within the given {\b CFrustum}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getNodeDepthCurrent} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns current node depth stat. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getNodeDepthMax} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns max node depth stat. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COctTreeNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COctTreeEntity}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D spatial partitioning class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For 2D spatial partitioning, see the {\b CQuadTree} class\par
An oct tree gives us fast retrieval of entities which are within a specified range of a given position aswell as fast retrieval of entities which are within a given area of space. This is great for rendering only visible entities and also for getting a list of entities which can be used to perform collision detection only upon entities which are closeby, instead of having to perform collision for ALL entities within a world.\par
An oct tree begins with an initial root 3D space (node) with which to insert uniquely named entities into, specifying their position. The oct tree has a maximum number of entities which can be inserted into a node and once this number is reached, the node is split into one or more (up to eight) child nodes and the entities are removed from the parent node and into the child nodes. The position of entities determines which child nodes need to be created and then the entity inserted into. Each of the child nodes have half the dimensions of their parent node and there are eight of them.\par
This is a recursive process, so smaller and smaller child nodes of child nodes and so on are created until a "max node depth" value is reached, then what happens is the child nodes no longer get any more child nodes and the entities inserted, ignore the maximum number of entities per node value. The max node depth is computed upon the tree's construction based upon it's dimensions and then again if the root node of the tree gets resized (due to insertion of an entity outside of the root node's region). The reason we have a max node depth is because, as the nodes get divided, their dimensions get smaller and smaller, until they reach a dimension of 1x1x1 and if they were to become zero dimensions, no entities would fit in them and the algorithm would enter an infinite recursive loop, forever creating useless zero sized child nodes and cause a stack overflow.\par
The intial region is set to -8, +8 along each axis. \par
 \par
}{
Definition at line {\b 44} of file {\b OctTree.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v COctTree\:DCL::COctTree}
{\xe \v DCL::COctTree\:COctTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::COctTree::COctTree (int iMaxEntitiesPerNode = {\f2 10}, float fSizeIncreaseMultiplier = {\f2 2.0f})}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMaxEntitiesPerNode} \cell }{The maximum number of entities able to be stored within a node before that node will be subdivided again into child nodes. This must be at least 1, otherwise an exception occurs. If we add an entity which is outside of the root node's initial region then the tree is rebuilt.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fSizeIncreaseMultiplier} \cell }{is used when the tree is rebuilt. It is the amount to increase the root node's dimensions by until the new entity's position fits. A value of 2 would double the new root node's dimensions each time. It must be at least 2 otherwise an exception occurs. \cell }
{\row }
}
}{
Definition at line {\b 6} of file {\b OctTree.cpp}.}\par
}
{\xe \v ~COctTree\:DCL::COctTree}
{\xe \v DCL::COctTree\:~COctTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::COctTree::~COctTree ()}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the root node, which will delete all children and their children and so on. \par
}{
Definition at line {\b 37} of file {\b OctTree.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addEntity\:DCL::COctTree}
{\xe \v DCL::COctTree\:addEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTree::addEntity (const std::string & strName, const {\b CVector3f} & vPosition, int iUserData = {\f2 0}, void * pUserData = {\f2 0})}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add entity to the oct tree. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{The name to be given to the new entity within the tree. It must be unique, if it already exists, an exception occurs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vPosition} \cell }{The position of the new entity. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iUserData} \cell }{Optional integer which you can use for anything. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pUserData} \cell }{A void pointer to anything you wish to associate with this entity.\cell }
{\row }
}
Each entity needs a unique name, if the name given already exists, an exception occurs. If the specified position is outside of the tree's region, the tree is rebuilt \par
}{
Definition at line {\b 128} of file {\b OctTree.cpp}.}\par
}
{\xe \v free\:DCL::COctTree}
{\xe \v DCL::COctTree\:free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTree::free (void )}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the root node and in turn all of it's children and all entities. }}\par
{
Definition at line {\b 42} of file {\b OctTree.cpp}.}\par
}
{\xe \v getEntitiesWithinAABB\:DCL::COctTree}
{\xe \v DCL::COctTree\:getEntitiesWithinAABB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b COctTreeEntity} * > DCL::COctTree::getEntitiesWithinAABB (const {\b CAABB} & aabb) const}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within the given {\b CAABB}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i aabb} \cell }{The axis aligned bounding box which to use for the test. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of COctTreeEntity* which are within the given AABB\par
}}This may return some entities which are outside of the range, as the test to see whether the entities aren't in range isn't 100% accurate. \par
}{
Definition at line {\b 370} of file {\b OctTree.cpp}.}\par
}
{\xe \v getEntitiesWithinFrustum\:DCL::COctTree}
{\xe \v DCL::COctTree\:getEntitiesWithinFrustum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b COctTreeEntity} * > DCL::COctTree::getEntitiesWithinFrustum (const {\b CFrustum} & frustum) const}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within the given {\b CFrustum}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i frustum} \cell }{The frustum to use for the test \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of COctTreeEntity* which are within the given frustum \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid check this \par
}
}{
Definition at line {\b 388} of file {\b OctTree.cpp}.}\par
}
{\xe \v getEntitiesWithinRange\:DCL::COctTree}
{\xe \v DCL::COctTree\:getEntitiesWithinRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b COctTreeEntity} * > DCL::COctTree::getEntitiesWithinRange (const {\b CVector3f} & vPosition, float fRange) const}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within range of the given position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vPosition} \cell }{The position in 3D space \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fRange} \cell }{The range from the given position with which any entities within this range will be returned. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of COctTreeEntity* which are within range of the given position and range.\par
}}This may return some entities which are outside of the range, as the test to see whether the entities aren't in range isn't 100% accurate. \par
}{
Definition at line {\b 347} of file {\b OctTree.cpp}.}\par
}
{\xe \v getEntityExists\:DCL::COctTree}
{\xe \v DCL::COctTree\:getEntityExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::COctTree::getEntityExists (const std::string & strName) const}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the named entity exists or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{The name of the entity within the tree. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the named entity exists, else false. \par
}}}{
Definition at line {\b 237} of file {\b OctTree.cpp}.}\par
}
{\xe \v getEntityPosition\:DCL::COctTree}
{\xe \v DCL::COctTree\:getEntityPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTree::getEntityPosition (const std::string & strName, {\b CVector3f} & vPosition) const}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given vector to the named entity's position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\cell }{{\i strName} \cell }{The name of the entity within the tree. If the named entity doesn't exist, an exception occurs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i vPosition} \cell }{Will hold the current position of the named entity. \cell }
{\row }
}
}{
Definition at line {\b 299} of file {\b OctTree.cpp}.}\par
}
{\xe \v getNodeDepthCurrent\:DCL::COctTree}
{\xe \v DCL::COctTree\:getNodeDepthCurrent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::COctTree::getNodeDepthCurrent (void )}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns current node depth stat. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current node depth\par
}}If there are no child nodes, this would be zero. It's used by the debug rendering code to colour the nodes accordingly. It's also used to determine if the tree has reached the maximum child division depth, in which case, additionally added entities no longer subdivide a node into children and instead simply add the new entity into the node, ignoring the _miMaxEntitiesPerNode value. \par
}{
Definition at line {\b 406} of file {\b OctTree.cpp}.}\par
}
{\xe \v getNodeDepthMax\:DCL::COctTree}
{\xe \v DCL::COctTree\:getNodeDepthMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::COctTree::getNodeDepthMax (void ) const}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns max node depth stat. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The max node depth stat\par
}}If adding an entity into a node, that node's depth is equal to this value, then _miMaxEntitiesPerNode is ignored and the new entity is simply added to the node, instead of trying to sub-divide the node further. This is to prevent node dimensions of less than 1x1 which would cause infinite sub-division of nodes and cause a stack overflow. This value is computed upon construction and whenever the root node's dimensions are increased. \par
}{
Definition at line {\b 414} of file {\b OctTree.cpp}.}\par
}
{\xe \v getNodesWithEntities\:DCL::COctTree}
{\xe \v DCL::COctTree\:getNodesWithEntities}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b COctTreeNode} * > DCL::COctTree::getNodesWithEntities (void ) const}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of COctTreeNodes which holds all nodes which have entities in them. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of COctTreeNodes which holds all nodes which have entities in them \par
}}}{
Definition at line {\b 326} of file {\b OctTree.cpp}.}\par
}
{\xe \v getNodesWithEntitiesWhichIntersect\:DCL::COctTree}
{\xe \v DCL::COctTree\:getNodesWithEntitiesWhichIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b COctTreeNode} * > DCL::COctTree::getNodesWithEntitiesWhichIntersect (const {\b CAABB} & aabb) const}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of COctTreeNodes which holds all nodes which intersect with the given AABB and have entities. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i aabb} \cell }{The axis aligned bounding box which to use for the intersection test. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a vector of COctTreeNode* which have entities in them and intersect with the given AABB \par
}}}{
Definition at line {\b 333} of file {\b OctTree.cpp}.}\par
}
{\xe \v getNodesWithEntitiesWhichIntersect\:DCL::COctTree}
{\xe \v DCL::COctTree\:getNodesWithEntitiesWhichIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b COctTreeNode} * > DCL::COctTree::getNodesWithEntitiesWhichIntersect (const {\b CFrustum} & frustum) const}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of COctTreeNodes which holds all nodes which intersect with the given {\b CFrustum} and have entities. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i frustum} \cell }{The frustum to use for the intersection test. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a vector of COctTreeNode* which have entities in them and intersect with the given frustum \par
}}}{
Definition at line {\b 340} of file {\b OctTree.cpp}.}\par
}
{\xe \v init\:DCL::COctTree}
{\xe \v DCL::COctTree\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTree::init (int iMaxEntitiesPerNode = {\f2 10}, float fSizeIncreaseMultiplier = {\f2 2.0f})}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise the oct tree using the new given settings. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This will free the existing tree and any entities.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMaxEntitiesPerNode} \cell }{is the maximum number of entities able to be stored within a node before that node will be subdivided again into child nodes. This must be at least 1, otherwise an exception occurs. If we add an entity which is outside of the root node's initial region then the tree is rebuilt.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fSizeIncreaseMultiplier} \cell }{is used when the tree is rebuilt. It is the amount to increase the root node's dimensions by until the new entity's position fits. A value of 2 would double the new root node's dimensions each time. It must be at least 2 otherwise an exception occurs. \cell }
{\row }
}
}{
Definition at line {\b 12} of file {\b OctTree.cpp}.}\par
}
{\xe \v removeAllEntities\:DCL::COctTree}
{\xe \v DCL::COctTree\:removeAllEntities}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTree::removeAllEntities (bool bResetTree = {\f2 false})}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all entities from the tree and depending upon the passed bool, resets the tree to contain just the root node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bResetTree} \cell }{Whether to reset the tree whist we're here. \cell }
{\row }
}
}{
Definition at line {\b 244} of file {\b OctTree.cpp}.}\par
}
{\xe \v removeEntity\:DCL::COctTree}
{\xe \v DCL::COctTree\:removeEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTree::removeEntity (const std::string & strName)}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the named entity from the tree. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{The name of the entity within the tree. If it doesn't exist, an exception occurs. To determine whether the entity exists, use {\b getEntityExists()} \cell }
{\row }
}
}{
Definition at line {\b 181} of file {\b OctTree.cpp}.}\par
}
{\xe \v setEntityPosition\:DCL::COctTree}
{\xe \v DCL::COctTree\:setEntityPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTree::setEntityPosition (const std::string & strName, const {\b CVector3f} & vNewPosition)}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set an existing entity's position to the one given, moving to the correct node if needed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{The name of the entity within the tree. If the named entity doesn't exist, an exception occurs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vNewPosition} \cell }{The new position of the entity. \cell }
{\row }
}
}{
Definition at line {\b 276} of file {\b OctTree.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v COctTreeEntity\:DCL::COctTree}
{\xe \v DCL::COctTree\:COctTreeEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b COctTreeEntity}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b OctTree.h}.}\par
}
{\xe \v COctTreeNode\:DCL::COctTree}
{\xe \v DCL::COctTree\:COctTreeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b COctTreeNode}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b OctTree.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b OctTree.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTree.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::COctTreeEntity Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::COctTreeEntity}
{\xe \v DCL::COctTreeEntity}
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into an {\b COctTreeNode}. }}\par
{
{\f2 #include <OctTreeEntity.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b COctTreeEntity} (const std::string &strName, const {\b CVector3f} &vPosition, {\b COctTreeNode} *pNodeOwner, int iUserData=0, void *pUserData=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getPosition} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the debug colour of the entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getName} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the name of the entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b miUserData}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optional user data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b mpUserData}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optional user data. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COctTree}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COctTreeNode}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into an {\b COctTreeNode}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It contains it's unique name, it's position within the world and the node it belongs to. \par
}{
Definition at line {\b 21} of file {\b OctTreeEntity.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v COctTreeEntity\:DCL::COctTreeEntity}
{\xe \v DCL::COctTreeEntity\:COctTreeEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::COctTreeEntity::COctTreeEntity (const std::string & strName, const {\b CVector3f} & vPosition, {\b COctTreeNode} * pNodeOwner, int iUserData = {\f2 0}, void * pUserData = {\f2 0})}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{is the unique name given to this entity. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vPosition} \cell }{is this entity's position within the world \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pNodeOwner} \cell }{A pointer to this entity's owning node. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iUserData} \cell }{Optional integer which you can use for anything. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pUserData} \cell }{A void pointer to anything you wish to associate with this entity. \cell }
{\row }
}
}{
Definition at line {\b 6} of file {\b OctTreeEntity.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getName\:DCL::COctTreeEntity}
{\xe \v DCL::COctTreeEntity\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::COctTreeEntity::getName (void )}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the name of the entity. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A string holding the entity's name \par
}}}{
Definition at line {\b 29} of file {\b OctTreeEntity.cpp}.}\par
}
{\xe \v getPosition\:DCL::COctTreeEntity}
{\xe \v DCL::COctTreeEntity\:getPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::COctTreeEntity::getPosition (void )}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the debug colour of the entity. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns position of entity\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} containing the entity's position. \par
}}}{
Definition at line {\b 24} of file {\b OctTreeEntity.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v COctTree\:DCL::COctTreeEntity}
{\xe \v DCL::COctTreeEntity\:COctTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b COctTree}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b OctTreeEntity.h}.}\par
}
{\xe \v COctTreeNode\:DCL::COctTreeEntity}
{\xe \v DCL::COctTreeEntity\:COctTreeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b COctTreeNode}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b OctTreeEntity.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v miUserData\:DCL::COctTreeEntity}
{\xe \v DCL::COctTreeEntity\:miUserData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::COctTreeEntity::miUserData}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optional user data. }}\par
{
Definition at line {\b 50} of file {\b OctTreeEntity.h}.}\par
}
{\xe \v mpUserData\:DCL::COctTreeEntity}
{\xe \v DCL::COctTreeEntity\:mpUserData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* DCL::COctTreeEntity::mpUserData}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optional user data. }}\par
{
Definition at line {\b 51} of file {\b OctTreeEntity.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b OctTreeEntity.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeEntity.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::COctTreeNode Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode}
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b COctTree} class. }}\par
{
{\f2 #include <OctTreeNode.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ChildNode} \{ {\b NEGX_NEGY_NEGZ}
, {\b NEGX_POSY_NEGZ}
, {\b NEGX_NEGY_POSZ}
, {\b NEGX_POSY_POSZ}
, {\b POSX_NEGY_NEGZ}
, {\b POSX_POSY_NEGZ}
, {\b POSX_NEGY_POSZ}
, {\b POSX_POSY_POSZ}
, {\b NONE}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for accessing child nodes based upon their location. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b COctTreeNode} (const {\b CAABB} &region, {\b COctTreeNode} *pParentNode, {\b COctTree} *pOctTree)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~COctTreeNode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasChildNode} ({\b ChildNode} childNode) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Debug renders this node and it's child nodes', node boundaries. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasAnyChildNodes} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this node has any child nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasEntitiesInThisAndAllChildren} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this node and all it's children have any entities within. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createChildNode} ({\b ChildNode} childNode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates the specified child node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAABB} {\b computeChildNodeRegion} ({\b ChildNode} childNode) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates and returns a child's region. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addEntity} ({\b COctTreeEntity} *pEntity)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an entity into this node, or it's children. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeEntity} ({\b COctTreeEntity} *pEntity)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes an entity from this node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getNodesWithEntities} (std::vector< {\b COctTreeNode} * > &vecNodes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of COctTreeNodes which have entities in them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getNodesWithEntitiesWhichIntersect} (std::vector< {\b COctTreeNode} * > &vecNodes, const {\b CAABB} &aabb)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of COctTreeNodes which intersect with the given AABB and have entities. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getNodesWithEntitiesWhichIntersect} (std::vector< {\b COctTreeNode} * > &vecNodes, const {\b CFrustum} &frustum)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of COctTreeNodes which intersect with the given {\b CFrustum} and have entities. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getMaxNodeDepth} (unsigned int &uiMaxNodeDepth)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Go through all children and if their depth is greater, increases given uiMaxNodeDepth. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COctTree}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b COctTree} class. \par
}{
Definition at line {\b 22} of file {\b OctTreeNode.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ChildNode\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:ChildNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b DCL::COctTreeNode::ChildNode}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for accessing child nodes based upon their location. }}\par
{
Definition at line {\b 27} of file {\b OctTreeNode.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v COctTreeNode\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:COctTreeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::COctTreeNode::COctTreeNode (const {\b CAABB} & region, {\b COctTreeNode} * pParentNode, {\b COctTree} * pOctTree)}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i region} \cell }{The 3D area/region which this node represents. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pParentNode} \cell }{A pointer to this node's parent node. However, if this node is to represent the root node, this will be 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pOctTree} \cell }{The oct tree which owns this node\cell }
{\row }
}
Sets up the node to represent the given region within the 3D world, with no child nodes. pParentNode is a pointer to this node's parent node. However, if this node is to represent the root node, this will be 0. \par
}{
Definition at line {\b 7} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v ~COctTreeNode\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:~COctTreeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::COctTreeNode::~COctTreeNode ()}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all child nodes Although this obviously removes the entities from the nodes, because the nodes themselves no longer exist, this does NOT delete the entity pointers. They are stored in the {\b COctTree}'s _mmapEntities hashmap. \par
}{
Definition at line {\b 26} of file {\b OctTreeNode.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addEntity\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:addEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTreeNode::addEntity ({\b COctTreeEntity} * pEntity)}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an entity into this node, or it's children. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pEntity} \cell }{A pointer to the entity to add \cell }
{\row }
}
}{
Definition at line {\b 221} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v computeChildNodeRegion\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:computeChildNodeRegion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CAABB} DCL::COctTreeNode::computeChildNodeRegion ({\b ChildNode} childNode) const}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates and returns a child's region. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i childNode} \cell }{A ChildNode \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CAABB} representing the node's region. \par
}}}{
Definition at line {\b 155} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v createChildNode\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:createChildNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTreeNode::createChildNode ({\b ChildNode} childNode)}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates the specified child node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i childNode} \cell }{A ChildNode\cell }
{\row }
}
If the node already exists, this does nothing. \par
}{
Definition at line {\b 143} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v getMaxNodeDepth\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:getMaxNodeDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTreeNode::getMaxNodeDepth (unsigned int & uiMaxNodeDepth)}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Go through all children and if their depth is greater, increases given uiMaxNodeDepth. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiMaxNodeDepth} \cell }{Will hold maximum node depth \cell }
{\row }
}
}{
Definition at line {\b 426} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v getNodesWithEntities\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:getNodesWithEntities}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTreeNode::getNodesWithEntities (std::vector< {\b COctTreeNode} * > & vecNodes)}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of COctTreeNodes which have entities in them. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecNodes} \cell }{A vector of {\b COctTreeNode} pointers which have entities within them \cell }
{\row }
}
}{
Definition at line {\b 351} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v getNodesWithEntitiesWhichIntersect\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:getNodesWithEntitiesWhichIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTreeNode::getNodesWithEntitiesWhichIntersect (std::vector< {\b COctTreeNode} * > & vecNodes, const {\b CAABB} & aabb)}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of COctTreeNodes which intersect with the given AABB and have entities. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecNodes} \cell }{A vector of {\b COctTreeNode} pointers which have entities within them and intersect with the given AABB \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i aabb} \cell }{The Axis aligned bounding box to use for the test. \cell }
{\row }
}
}{
Definition at line {\b 374} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v getNodesWithEntitiesWhichIntersect\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:getNodesWithEntitiesWhichIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTreeNode::getNodesWithEntitiesWhichIntersect (std::vector< {\b COctTreeNode} * > & vecNodes, const {\b CFrustum} & frustum)}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of COctTreeNodes which intersect with the given {\b CFrustum} and have entities. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecNodes} \cell }{A vector of {\b COctTreeNode} pointers which have entities within them and intersect with the given frustum \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i frustum} \cell }{The frustum to use for the test. \cell }
{\row }
}
}{
Definition at line {\b 400} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v hasAnyChildNodes\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:hasAnyChildNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::COctTreeNode::hasAnyChildNodes (void ) const}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this node has any child nodes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether this node has any child nodes \par
}}}{
Definition at line {\b 112} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v hasChildNode\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:hasChildNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::COctTreeNode::hasChildNode ({\b ChildNode} childNode) const}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Debug renders this node and it's child nodes', node boundaries. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pLine is the CResourceLine object which is being used to add vertices to be rendered vertex is the vertex object we're using to add vertices using the pLine object.\par
Returns true if this node has the specified child node\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i childNode} \cell }{A ChildNode \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if this node has the specified child node, else false. \par
}}}{
Definition at line {\b 107} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v hasEntitiesInThisAndAllChildren\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:hasEntitiesInThisAndAllChildren}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::COctTreeNode::hasEntitiesInThisAndAllChildren (void ) const}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this node and all it's children have any entities within. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether this node and all it's children have any entities within \par
}}}{
Definition at line {\b 122} of file {\b OctTreeNode.cpp}.}\par
}
{\xe \v removeEntity\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:removeEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::COctTreeNode::removeEntity ({\b COctTreeEntity} * pEntity)}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes an entity from this node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pEntity} \cell }{A pointer to the entity to remove\cell }
{\row }
}
If the entity couldn't be found, an exception occurs \par
}{
Definition at line {\b 342} of file {\b OctTreeNode.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v COctTree\:DCL::COctTreeNode}
{\xe \v DCL::COctTreeNode\:COctTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b COctTree}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b OctTreeNode.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b OctTreeNode.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeNode.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CPlane Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CPlane}
{\xe \v DCL::CPlane}
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A representation of a plane in 3D space. }}\par
{
{\f2 #include <Plane.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPlane} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets plane's normal to (0,1,0) and distance to 0. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPlane} (const {\b CVector3f} &vNormal, float fDistanceToOrigin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets the plane's normal and distance to given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b CVector3f} &vNormal, float fDistanceToOrigin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets plane to given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getNormal} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns normal of plane. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDistanceToOrigin} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns distance from origin. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDistanceFromPlane} (const {\b CVector3f} &vPoint) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses to dot product to compute the distance of a point from the plane. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A representation of a plane in 3D space. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plane is defined by two things.{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Distance to the origin\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab A normal vector \par}
\par
}{
Definition at line {\b 18} of file {\b Plane.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPlane\:DCL::CPlane}
{\xe \v DCL::CPlane\:CPlane}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CPlane::CPlane ()}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets plane's normal to (0,1,0) and distance to 0. }}\par
{
Definition at line {\b 5} of file {\b Plane.cpp}.}\par
}
{\xe \v CPlane\:DCL::CPlane}
{\xe \v DCL::CPlane\:CPlane}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CPlane::CPlane (const {\b CVector3f} & vNormal, float fDistanceToOrigin)}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets the plane's normal and distance to given values. }}\par
{
Definition at line {\b 11} of file {\b Plane.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getDistanceFromPlane\:DCL::CPlane}
{\xe \v DCL::CPlane\:getDistanceFromPlane}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CPlane::getDistanceFromPlane (const {\b CVector3f} & vPoint) const}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses to dot product to compute the distance of a point from the plane. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vPoint} \cell }{The point to test which side of the plane it is upon \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A positive value if the given point is on the side the plane's normal is pointing, else a negative value.\par
}}If the given point is on the side of the plane it's normal is pointing, a positive value is returned, else negative. \par
}{
Definition at line {\b 33} of file {\b Plane.cpp}.}\par
}
{\xe \v getDistanceToOrigin\:DCL::CPlane}
{\xe \v DCL::CPlane\:getDistanceToOrigin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CPlane::getDistanceToOrigin (void ) const}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns distance from origin. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The plane's distance from the origin \par
}}}{
Definition at line {\b 28} of file {\b Plane.cpp}.}\par
}
{\xe \v getNormal\:DCL::CPlane}
{\xe \v DCL::CPlane\:getNormal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CPlane::getNormal (void ) const}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns normal of plane. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} holding the normal of the plane \par
}}}{
Definition at line {\b 23} of file {\b Plane.cpp}.}\par
}
{\xe \v set\:DCL::CPlane}
{\xe \v DCL::CPlane\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CPlane::set (const {\b CVector3f} & vNormal, float fDistanceToOrigin)}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets plane to given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vNormal} \cell }{The normal of the plane \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fDistanceToOrigin} \cell }{The distance from the origin \cell }
{\row }
}
}{
Definition at line {\b 17} of file {\b Plane.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Plane.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Plane.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CProfiler Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CProfiler}
{\xe \v DCL::CProfiler}
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to deal with time profiling. }}\par
{
{\f2 #include <Profiler.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SSection}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Members needed by each code section. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} (const std::string &strSectionName="main")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Begin timing a named section of code. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b end} (const std::string &strSectionName="main")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
End timing a named section of code. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets the profiler, removing all previously used sections, except for "main". }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getSectionTime} (const std::string &strSectionName="main")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of accumulated seconds for the named section. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getSectionNumber} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total number of sections including "main". }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b SProfilerResults} > {\b getResults} (bool bReturnCachedResults=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of {\b SProfilerResults}, sorted by accumulated time in seconds. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to deal with time profiling. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It works on the concept of code sections. We create an object of this class (Or use the global one stored in x->pProfiler) and then call begin("nameOfSection") before any code we wish to time. Then after all the section code, we call end("nameOfSection") If elsewhere in the code, we wish to time a section and add that time to the named section we've already used, we add another {\b begin()}/end() pair and the time taken between those will be added to that code sections total time. For everything to be computed properly, we MUST have a section called "main" which encapsulates all other sections. This will allow the class to compute percentages each section takes. Example: {\b CProfiler} prof; void mainLoop(void) \{ prof.begin("main"); prof.begin("audio"); // Audio code goes here prof.end("audio"); prof.begin("gfx"); // Rendering code goes here prof.end("gfx"); prof.end("main"); \} \par
}{
Definition at line {\b 48} of file {\b Profiler.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CProfiler\:DCL::CProfiler}
{\xe \v DCL::CProfiler\:CProfiler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CProfiler::CProfiler ()}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b Profiler.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:DCL::CProfiler}
{\xe \v DCL::CProfiler\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CProfiler::begin (const std::string & strSectionName = {\f2 "main"})}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Begin timing a named section of code. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strSectionName} \cell }{The name to use for a section of code to be timed.\cell }
{\row }
}
There must be at least one section called "main" for things to work correctly. \par
}{
Definition at line {\b 21} of file {\b Profiler.cpp}.}\par
}
{\xe \v end\:DCL::CProfiler}
{\xe \v DCL::CProfiler\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CProfiler::end (const std::string & strSectionName = {\f2 "main"})}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
End timing a named section of code. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strSectionName} \cell }{The name to use for a section of code to be timed. \cell }
{\row }
}
}{
Definition at line {\b 52} of file {\b Profiler.cpp}.}\par
}
{\xe \v getResults\:DCL::CProfiler}
{\xe \v DCL::CProfiler\:getResults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b SProfilerResults} > DCL::CProfiler::getResults (bool bReturnCachedResults = {\f2 true})}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of {\b SProfilerResults}, sorted by accumulated time in seconds. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bReturnCachedResults} \cell }{Whether or not to return results which are complete and one loop old \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of {\b SProfilerResults} holding all profiling information.\par
}}Unfortunately, this only returns valid results after a call to {\b end()} with the "main" section specified has been called, otherwise we don't have all the needed information we need to compute the percentages of main. However, passing true to bReturnCachedResults will return the results from results which have been obtained during the last call to {\b end()} with "main" being given as the section. These results are one frame old, but are complete. \par
}{
Definition at line {\b 89} of file {\b Profiler.cpp}.}\par
}
{\xe \v getSectionNumber\:DCL::CProfiler}
{\xe \v DCL::CProfiler\:getSectionNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t DCL::CProfiler::getSectionNumber (void )}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total number of sections including "main". }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the total number of sections including "main" \par
}}}{
Definition at line {\b 78} of file {\b Profiler.cpp}.}\par
}
{\xe \v getSectionTime\:DCL::CProfiler}
{\xe \v DCL::CProfiler\:getSectionTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DCL::CProfiler::getSectionTime (const std::string & strSectionName = {\f2 "main"})}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of accumulated seconds for the named section. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strSectionName} \cell }{The name to use for a section of code to be timed. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the number of accumulated seconds for the named section.\par
}}If the section doesn't exist, an exception occurs. \par
}{
Definition at line {\b 70} of file {\b Profiler.cpp}.}\par
}
{\xe \v reset\:DCL::CProfiler}
{\xe \v DCL::CProfiler\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CProfiler::reset (void )}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets the profiler, removing all previously used sections, except for "main". }}\par
{
Definition at line {\b 13} of file {\b Profiler.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Profiler.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Profiler.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CQuadTree Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CQuadTree}
{\xe \v DCL::CQuadTree}
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a 2D spatial partitioning class. }}\par
{
{\f2 #include <QuadTree.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuadTree} (int iMaxEntitiesPerNode=10, int iRectSizeIncreaseMultiplier=2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CQuadTree} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (int iMaxEntitiesPerNode=10, int iRectSizeIncreaseMultiplier=2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise the quad tree using the new given settings. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the root node and in turn all of it's children and all entities. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addEntity} (const std::string &strName, int iPosX, int iPosY, int iUserData=0, void *pUserData=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add entity to the quad tree. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeEntity} (const std::string &strName)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the named entity from the tree. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getEntityExists} (const std::string &strName) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the named entity exists or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAllEntities} (bool bResetTree=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all entities from the tree and depending upon the passed bool, resets the tree to contain just the root node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEntityPosition} (const std::string &strName, int iNewPosX, int iNewPosY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set an existing entity's position to the one given, moving to the correct node if needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getEntityPosition} (const std::string &strName, int &iPosX, int &iPosY) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given integers to the named entity's position. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CQuadTreeNode} * > {\b getNodesWithEntities} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of CQuadTreeNodes which holds all nodes which have entities in them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CQuadTreeNode} * > {\b getNodesWithEntitiesWhichIntersect} (const {\b CRect} &rect) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of {\b CQuadTreeNode} which holds all nodes which intersect with the given {\b CRect} and have entities. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CQuadTreeEntity} * > {\b getEntitiesWithinRange} (int iPosX, int iPosY, int iRange) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within range of the given position. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CQuadTreeEntity} * > {\b getEntitiesWithinRect} (const {\b CRect} &rect) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within the given {\b CRect}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getNodeDepthCurrent} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns current node depth stat. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getNodeDepthMax} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns max node depth stat. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuadTreeNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuadTreeEntity}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a 2D spatial partitioning class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For 3D spatial partitioning, see the {\b COctTree} class\par
A quad tree gives us fast retrieval of entities which are within a specified range of a given position aswell as fast retrieval of entities which are within a given area of space. This is great for rendering only visible entities and also for getting a list of entities which can be used to perform collision detection only upon entities which are closeby, instead of having to perform collision for ALL entities within a world.\par
A quad tree begins with an initial root 2D space (node) with which to insert uniquely named entities into, specifying their position. The quad tree has a maximum number of entities which can be inserted into a node and once this number is reached, the node is split into one or more (up to four) child nodes and the entities are removed from the parent node and into the child nodes. The position of entities determines which child nodes need to be created and then the entity inserted into. Each of the child nodes have half the dimensions of their parent node and there are four of them.\par
This is a recursive process, so smaller and smaller child nodes of child nodes and so on are created until a "max node depth" value is reached, then what happens is the child nodes no longer get any more child nodes and the entities inserted, ignore the maximum number of entities per node value. The max node depth is computed upon the tree's construction based upon it's dimensions and then again if the root node of the tree gets resized (due to insertion of an entity outside of the root node's region). The reason we have a max node depth is because, as the nodes get divided, their dimensions get smaller and smaller, until they reach a dimension of 1x1 and if they were to become zero dimensions, no entities would fit in them and the algorithm would enter an infinite recursive loop, forever creating useless zero sized child nodes and cause a stack overflow.\par
The initial region covered by the root node has to be a multiple of 2, otherwise division of the child nodes may cause certain position to not be covered (For example, if the initial region was (3, 3) in dimensions, when creating the child nodes, their dims would be (1, 1) meaning half the region of the parent node would not be covered and make it so an entity within the uncovered area would not fit. The intial region is set to -1024, +1024 along each axis. \par
}{
Definition at line {\b 46} of file {\b QuadTree.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CQuadTree\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:CQuadTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CQuadTree::CQuadTree (int iMaxEntitiesPerNode = {\f2 10}, int iRectSizeIncreaseMultiplier = {\f2 2})}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMaxEntitiesPerNode} \cell }{is the maximum number of entities able to be stored within a node before that node will be subdivided again into child nodes. This must be at least 1, otherwise an exception occurs. If we add an entity which is outside of the root node's initial region of -1024 to 1024, then the tree is rebuilt.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iRectSizeIncreaseMultiplier} \cell }{is used when the tree is rebuilt. It is the amount to increase the root node's dimensions by until the new entity's position fits. A value of 2 would double the new root node's dimensions each time. It must be at least 2 otherwise an exception occurs. \cell }
{\row }
}
}{
Definition at line {\b 6} of file {\b QuadTree.cpp}.}\par
}
{\xe \v ~CQuadTree\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:~CQuadTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CQuadTree::~CQuadTree ()}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the root node, which will delete all children and their children and so on. \par
}{
Definition at line {\b 38} of file {\b QuadTree.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addEntity\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:addEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTree::addEntity (const std::string & strName, int iPosX, int iPosY, int iUserData = {\f2 0}, void * pUserData = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add entity to the quad tree. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{The name to be given to the new entity within the tree. It must be unique, if it already exists, an exception occurs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPosX} \cell }{The position of the new entity for the X axis \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPosY} \cell }{The position of the new entity for the Y axis \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iUserData} \cell }{Optional integer which you can use for anything. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pUserData} \cell }{A void pointer to anything you wish to associate with this entity.\cell }
{\row }
}
Each entity needs a unique name, if the name given already exists, an exception occurs. If the specified position is outside of the tree's region, the tree is rebuilt \par
}{
Definition at line {\b 150} of file {\b QuadTree.cpp}.}\par
}
{\xe \v free\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTree::free (void )}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the root node and in turn all of it's children and all entities. }}\par
{
Definition at line {\b 43} of file {\b QuadTree.cpp}.}\par
}
{\xe \v getEntitiesWithinRange\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:getEntitiesWithinRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b CQuadTreeEntity} * > DCL::CQuadTree::getEntitiesWithinRange (int iPosX, int iPosY, int iRange) const}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within range of the given position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPosX} \cell }{The position in 3D space along X axis \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPosY} \cell }{The position in 3D space along Y axis \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iRange} \cell }{The range from the given position with which any entities within this range will be returned. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of CQuadTreeEntity* which are within range of the given position and range.\par
}}This may return some entities which are outside of the range, as the test to see whether the entities aren't in range isn't 100% accurate. \par
}{
Definition at line {\b 362} of file {\b QuadTree.cpp}.}\par
}
{\xe \v getEntitiesWithinRect\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:getEntitiesWithinRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b CQuadTreeEntity} * > DCL::CQuadTree::getEntitiesWithinRect (const {\b CRect} & rect) const}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of entities which are within the given {\b CRect}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rect} \cell }{The {\b CRect} to use for the test. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of CQuadTreeEntity* which are within the given {\b CRect}\par
}}This may return some entities which are outside of the range, as the test to see whether the entities aren't in range isn't 100% accurate. \par
}{
Definition at line {\b 387} of file {\b QuadTree.cpp}.}\par
}
{\xe \v getEntityExists\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:getEntityExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CQuadTree::getEntityExists (const std::string & strName) const}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the named entity exists or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{The name of the entity within the tree. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the named entity exists, else false. \par
}}}{
Definition at line {\b 259} of file {\b QuadTree.cpp}.}\par
}
{\xe \v getEntityPosition\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:getEntityPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTree::getEntityPosition (const std::string & strName, int & iPosX, int & iPosY) const}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given integers to the named entity's position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\cell }{{\i strName} \cell }{The name of the entity within the tree. If the named entity doesn't exist, an exception occurs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i iPosX} \cell }{Will hold the current position of the named entity along X axis. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i iPosY} \cell }{Will hold the current position of the named entity along Y axis. \cell }
{\row }
}
}{
Definition at line {\b 322} of file {\b QuadTree.cpp}.}\par
}
{\xe \v getNodeDepthCurrent\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:getNodeDepthCurrent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::CQuadTree::getNodeDepthCurrent (void )}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns current node depth stat. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current node depth\par
}}If there are no child nodes, this would be zero. It's used by the debug rendering code to colour the nodes accordingly. It's also used to determine if the tree has reached the maximum child division depth, in which case, additionally added entities no longer subdivide a node into children and instead simply add the new entity into the node, ignoring the _miMaxEntitiesPerNode value. \par
}{
Definition at line {\b 405} of file {\b QuadTree.cpp}.}\par
}
{\xe \v getNodeDepthMax\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:getNodeDepthMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::CQuadTree::getNodeDepthMax (void ) const}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns max node depth stat. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The max node depth stat\par
}}If adding an entity into a node, that node's depth is equal to this value, then _miMaxEntitiesPerNode is ignored and the new entity is simply added to the node, instead of trying to sub-divide the node further. This is to prevent node dimensions of less than 1x1 which would cause infinite sub-division of nodes and cause a stack overflow. This value is computed upon construction and whenever the root node's dimensions are increased. \par
}{
Definition at line {\b 413} of file {\b QuadTree.cpp}.}\par
}
{\xe \v getNodesWithEntities\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:getNodesWithEntities}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b CQuadTreeNode} * > DCL::CQuadTree::getNodesWithEntities (void ) const}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of CQuadTreeNodes which holds all nodes which have entities in them. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A vector of {\b CQuadTreeNode} which holds all nodes which have entities in them \par
}}}{
Definition at line {\b 348} of file {\b QuadTree.cpp}.}\par
}
{\xe \v getNodesWithEntitiesWhichIntersect\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:getNodesWithEntitiesWhichIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b CQuadTreeNode} * > DCL::CQuadTree::getNodesWithEntitiesWhichIntersect (const {\b CRect} & rect) const}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of {\b CQuadTreeNode} which holds all nodes which intersect with the given {\b CRect} and have entities. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rect} \cell }{The {\b CRect} to use for the intersection test. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a vector of CQuadTreeNode* which have entities in them and intersect with the given {\b CRect} \par
}}}{
Definition at line {\b 355} of file {\b QuadTree.cpp}.}\par
}
{\xe \v init\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTree::init (int iMaxEntitiesPerNode = {\f2 10}, int iRectSizeIncreaseMultiplier = {\f2 2})}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise the quad tree using the new given settings. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMaxEntitiesPerNode} \cell }{is the maximum number of entities able to be stored within a node before that node will be subdivided again into child nodes. This must be at least 1, otherwise an exception occurs. If we add an entity which is outside of the root nodes initial region of -1024 to 1024, then the tree is rebuilt.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iRectSizeIncreaseMultiplier} \cell }{is used when the tree is rebuilt. It is the amount to increase the root node's dimensions by until the new entity's position fits. A value of 2 would double the new root node's dimensions each time. It must be at least 2 otherwise an exception occurs.\cell }
{\row }
}
This will free the existing tree and any entities. \par
}{
Definition at line {\b 13} of file {\b QuadTree.cpp}.}\par
}
{\xe \v removeAllEntities\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:removeAllEntities}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTree::removeAllEntities (bool bResetTree = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all entities from the tree and depending upon the passed bool, resets the tree to contain just the root node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bResetTree} \cell }{Whether to reset the tree whist we're here. \cell }
{\row }
}
}{
Definition at line {\b 266} of file {\b QuadTree.cpp}.}\par
}
{\xe \v removeEntity\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:removeEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTree::removeEntity (const std::string & strName)}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the named entity from the tree. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{The name of the entity within the tree. If it doesn't exist, an exception occurs. To determine whether the entity exists, use {\b getEntityExists()} \cell }
{\row }
}
}{
Definition at line {\b 203} of file {\b QuadTree.cpp}.}\par
}
{\xe \v setEntityPosition\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:setEntityPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTree::setEntityPosition (const std::string & strName, int iNewPosX, int iNewPosY)}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set an existing entity's position to the one given, moving to the correct node if needed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{The name of the entity within the tree. If the named entity doesn't exist, an exception occurs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNewPosX} \cell }{The new position of the entity along X axis. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iNewPosY} \cell }{The new position of the entity along Y axis. \cell }
{\row }
}
}{
Definition at line {\b 298} of file {\b QuadTree.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v CQuadTreeEntity\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:CQuadTreeEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b CQuadTreeEntity}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b QuadTree.h}.}\par
}
{\xe \v CQuadTreeNode\:DCL::CQuadTree}
{\xe \v DCL::CQuadTree\:CQuadTreeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b CQuadTreeNode}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b QuadTree.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b QuadTree.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTree.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CQuadTreeEntity Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CQuadTreeEntity}
{\xe \v DCL::CQuadTreeEntity}
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into a {\b CQuadTreeNode}. }}\par
{
{\f2 #include <QuadTreeEntity.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuadTreeEntity} (const std::string &strName, int iPosX, int iPosY, {\b CQuadTreeNode} *pNodeOwner, int iUserData=0, void *pUserData=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b getPosition} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the debug colour of the entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getName} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the name of the entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b miUserData}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can store a value for use by you for any required reason. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b mpUserData}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can store a void pointer for use by you for any required reason. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuadTree}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuadTreeNode}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into a {\b CQuadTreeNode}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It contains it's unique name, it's position within the world and the node it belongs to. \par
}{
Definition at line {\b 21} of file {\b QuadTreeEntity.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CQuadTreeEntity\:DCL::CQuadTreeEntity}
{\xe \v DCL::CQuadTreeEntity\:CQuadTreeEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CQuadTreeEntity::CQuadTreeEntity (const std::string & strName, int iPosX, int iPosY, {\b CQuadTreeNode} * pNodeOwner, int iUserData = {\f2 0}, void * pUserData = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strName} \cell }{is the unique name given to this entity. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPosX} \cell }{is this entity's position within the world along X axis \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPosY} \cell }{is this entity's position within the world along Y axis \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pNodeOwner} \cell }{A pointer to this entity's owning node. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iUserData} \cell }{Optional integer which you can use for anything. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pUserData} \cell }{A void pointer to anything you wish to associate with this entity. \cell }
{\row }
}
}{
Definition at line {\b 6} of file {\b QuadTreeEntity.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getName\:DCL::CQuadTreeEntity}
{\xe \v DCL::CQuadTreeEntity\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::CQuadTreeEntity::getName (void )}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the name of the entity. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A string holding the entity's name \par
}}}{
Definition at line {\b 33} of file {\b QuadTreeEntity.cpp}.}\par
}
{\xe \v getPosition\:DCL::CQuadTreeEntity}
{\xe \v DCL::CQuadTreeEntity\:getPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CQuadTreeEntity::getPosition (void )}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the debug colour of the entity. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns position of entity\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector2f} containing the entity's position. \par
}}}{
Definition at line {\b 25} of file {\b QuadTreeEntity.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v CQuadTree\:DCL::CQuadTreeEntity}
{\xe \v DCL::CQuadTreeEntity\:CQuadTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b CQuadTree}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b QuadTreeEntity.h}.}\par
}
{\xe \v CQuadTreeNode\:DCL::CQuadTreeEntity}
{\xe \v DCL::CQuadTreeEntity\:CQuadTreeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b CQuadTreeNode}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b QuadTreeEntity.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v miUserData\:DCL::CQuadTreeEntity}
{\xe \v DCL::CQuadTreeEntity\:miUserData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CQuadTreeEntity::miUserData}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can store a value for use by you for any required reason. }}\par
{
Definition at line {\b 51} of file {\b QuadTreeEntity.h}.}\par
}
{\xe \v mpUserData\:DCL::CQuadTreeEntity}
{\xe \v DCL::CQuadTreeEntity\:mpUserData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* DCL::CQuadTreeEntity::mpUserData}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can store a void pointer for use by you for any required reason. }}\par
{
Definition at line {\b 52} of file {\b QuadTreeEntity.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b QuadTreeEntity.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeEntity.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CQuadTreeNode Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode}
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b CQuadTree} class. }}\par
{
{\f2 #include <QuadTreeNode.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ChildNode} \{ {\b BL}
, {\b BR}
, {\b TL}
, {\b TR}
, {\b NONE}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for accessing child nodes based upon their location. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuadTreeNode} (const {\b CRect} &rectRegion, {\b CQuadTreeNode} *pParentNode, {\b CQuadTree} *pQuadTree)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CQuadTreeNode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasChildNode} ({\b ChildNode} childNode) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Debug renders this node and it's child nodes', node boundaries. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasAnyChildNodes} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this node has any child nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasEntitiesInThisAndAllChildren} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this node and all it's children have any entities within. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createChildNode} ({\b ChildNode} childNode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates the specified child node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRect} {\b computeChildNodeRegion} ({\b ChildNode} childNode) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates and returns a child's region. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addEntity} ({\b CQuadTreeEntity} *pEntity)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an entity into this node, or it's children. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeEntity} ({\b CQuadTreeEntity} *pEntity)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes an entity from this node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getNodesWithEntities} (std::vector< {\b CQuadTreeNode} * > &vecNodes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of CQuadTreeNodes which have entities in them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getNodesWithEntitiesWhichIntersect} (std::vector< {\b CQuadTreeNode} * > &vecNodes, const {\b CRect} &rect)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of CQuadTreeNodes which intersect with the given {\b CRect} and have entities. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getMaxNodeDepth} (unsigned int &uiMaxNodeDepth)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Go through all children and if their depth is greater, increases given uiMaxNodeDepth. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CQuadTree}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b CQuadTree} class. \par
}{
Definition at line {\b 21} of file {\b QuadTreeNode.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ChildNode\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:ChildNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b DCL::CQuadTreeNode::ChildNode}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for accessing child nodes based upon their location. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v BL\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:BL}
{\qr BL{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bottom left child node. \par
}\cell }{\row }
{\xe \v BR\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:BR}
{\qr BR{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bottom right child node. \par
}\cell }{\row }
{\xe \v TL\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:TL}
{\qr TL{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Top left child node. \par
}\cell }{\row }
{\xe \v TR\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:TR}
{\qr TR{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Top right child node. \par
}\cell }{\row }
}
{
Definition at line {\b 26} of file {\b QuadTreeNode.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CQuadTreeNode\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:CQuadTreeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CQuadTreeNode::CQuadTreeNode (const {\b CRect} & rectRegion, {\b CQuadTreeNode} * pParentNode, {\b CQuadTree} * pQuadTree)}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rectRegion} \cell }{The 2D area/region which this node represents. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pParentNode} \cell }{A pointer to this node's parent node. However, if this node is to represent the root node, this will be 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pQuadTree} \cell }{The quad tree which owns this node\cell }
{\row }
}
Sets up the node to represent the given region within the 2D world, with no child nodes. pParentNode is a pointer to this node's parent node. However, if this node is to represent the root node, this will be 0. \par
}{
Definition at line {\b 7} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v ~CQuadTreeNode\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:~CQuadTreeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CQuadTreeNode::~CQuadTreeNode ()}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all child nodes Although this obviously removes the entities from the nodes, because the nodes themselves no longer exist, this does NOT delete the entity pointers. They are stored in the {\b CQuadTree}'s _mmapEntities hashmap. \par
}{
Definition at line {\b 26} of file {\b QuadTreeNode.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addEntity\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:addEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTreeNode::addEntity ({\b CQuadTreeEntity} * pEntity)}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an entity into this node, or it's children. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pEntity} \cell }{A pointer to the entity to add \cell }
{\row }
}
}{
Definition at line {\b 196} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v computeChildNodeRegion\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:computeChildNodeRegion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CRect} DCL::CQuadTreeNode::computeChildNodeRegion ({\b ChildNode} childNode) const}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates and returns a child's region. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i childNode} \cell }{A ChildNode \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CRect} representing the node's region. \par
}}}{
Definition at line {\b 154} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v createChildNode\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:createChildNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTreeNode::createChildNode ({\b ChildNode} childNode)}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates the specified child node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i childNode} \cell }{A ChildNode\cell }
{\row }
}
If the node already exists, this does nothing. \par
}{
Definition at line {\b 142} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v getMaxNodeDepth\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:getMaxNodeDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTreeNode::getMaxNodeDepth (unsigned int & uiMaxNodeDepth)}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Go through all children and if their depth is greater, increases given uiMaxNodeDepth. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiMaxNodeDepth} \cell }{Will hold maximum node depth \cell }
{\row }
}
}{
Definition at line {\b 350} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v getNodesWithEntities\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:getNodesWithEntities}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTreeNode::getNodesWithEntities (std::vector< {\b CQuadTreeNode} * > & vecNodes)}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of CQuadTreeNodes which have entities in them. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecNodes} \cell }{A vector of {\b CQuadTreeNode} pointers which have entities within them \cell }
{\row }
}
}{
Definition at line {\b 301} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v getNodesWithEntitiesWhichIntersect\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:getNodesWithEntitiesWhichIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTreeNode::getNodesWithEntitiesWhichIntersect (std::vector< {\b CQuadTreeNode} * > & vecNodes, const {\b CRect} & rect)}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds nodes to a vector of CQuadTreeNodes which intersect with the given {\b CRect} and have entities. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vecNodes} \cell }{A vector of {\b CQuadTreeNode} pointers which have entities within them and intersect with the given AABB \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rect} \cell }{The {\b CRect} to use for the test. \cell }
{\row }
}
}{
Definition at line {\b 324} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v hasAnyChildNodes\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:hasAnyChildNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CQuadTreeNode::hasAnyChildNodes (void ) const}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this node has any child nodes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether this node has any child nodes \par
}}}{
Definition at line {\b 111} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v hasChildNode\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:hasChildNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CQuadTreeNode::hasChildNode ({\b ChildNode} childNode) const}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Debug renders this node and it's child nodes', node boundaries. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pLine is the CResourceLine object which is being used to add vertices to be rendered vertex is the vertex object we're using to add vertices using the pLine object.\par
Debug renders this node and it's child nodes' entities\par
pLine is the CResourceLine object which is being used to add vertices to be rendered\par
Returns true if this node has the specified child node\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i childNode} \cell }{A ChildNode \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if this node has the specified child node, else false. \par
}}}{
Definition at line {\b 106} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v hasEntitiesInThisAndAllChildren\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:hasEntitiesInThisAndAllChildren}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CQuadTreeNode::hasEntitiesInThisAndAllChildren (void ) const}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this node and all it's children have any entities within. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether this node and all it's children have any entities within \par
}}}{
Definition at line {\b 121} of file {\b QuadTreeNode.cpp}.}\par
}
{\xe \v removeEntity\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:removeEntity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuadTreeNode::removeEntity ({\b CQuadTreeEntity} * pEntity)}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes an entity from this node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pEntity} \cell }{A pointer to the entity to remove\cell }
{\row }
}
If the entity couldn't be found, an exception occurs \par
}{
Definition at line {\b 292} of file {\b QuadTreeNode.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v CQuadTree\:DCL::CQuadTreeNode}
{\xe \v DCL::CQuadTreeNode\:CQuadTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b CQuadTree}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b QuadTreeNode.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/{\b QuadTreeNode.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeNode.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CQuaternion Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CQuaternion}
{\xe \v DCL::CQuaternion}
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Quaternion class to represent rotations. }}\par
{
{\f2 #include <Quaternion.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuaternion} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets quaternion to identity (0, 0, 0, 1) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuaternion} (float fX, float fY, float fZ, float fW)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets quaternion from given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuaternion} (const {\b CQuaternion} &quaternion)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets quaternion from given quaternion. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float & {\b operator[]} (const int iIndex)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Access each element. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CQuaternion} {\b operator*} (const {\b CQuaternion} &quaternion) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply this quaternion by another and return result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const void {\b operator*=} (const {\b CQuaternion} &quaternion)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply this quaternion by another. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CQuaternion} {\b operator+} (const {\b CQuaternion} &quat) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add two quaternions, return result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CQuaternion} {\b operator-} (const {\b CQuaternion} &quat) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtract two quaternions, return result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CQuaternion} {\b operator*} (const float fScalar) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply by scalar, return result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CQuaternion} {\b operator/} (const float fScalar) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Divide by scalar, return result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b operator*} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply a vector, return result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const void {\b operator=} (const {\b CQuaternion} &quat)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set this quaternion to the one on the right of the operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const bool {\b operator==} (const {\b CQuaternion} &quat) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparison operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const bool {\b operator!=} (const {\b CQuaternion} &quat) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparison operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIdentity} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets quaternion to identity (0, 0, 0, 1) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getMagnitude} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets magnitude of the quaternion. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalise} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalizes the quaternion. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuaternion} {\b getConjugate} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a quaternion with this quaternion's first three components negated. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuaternion} {\b getNegative} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a quaternion with all of this quaternion's components negated. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromAxisAngle} (const {\b CVector3f} &vAxis, float fAngleRadians)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this quaternion from an axis and an angle. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getAxis} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns this quaternion's axis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getAngle} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns this quaternion's angle in radians. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromEuler} (float fAngleRadiansX, float fAngleRadiansY, float fAngleRadiansZ)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this quaternion from Euler angles. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getEuler} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector containing the amount of rotation around each local axis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromMatrix} (const {\b CMatrix} &matrix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets quaternion from given {\b CMatrix}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rotate} (const {\b CQuaternion} &quat)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rotate this quaternion by another. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuaternion} {\b getSLERP} (const {\b CQuaternion} &quaternion, float fInterval) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a quaternion which is interpolated between this quat and the one given using smooth SLERP. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CQuaternion} {\b getLERP} (const {\b CQuaternion} &quaternion, float fInterval) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a quaternion which is interpolated between this quat and the one given using linear interpolation. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b q} [4]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
x, y, z and w }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Quaternion class to represent rotations. \par
}{
Definition at line {\b 16} of file {\b Quaternion.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CQuaternion\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:CQuaternion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CQuaternion::CQuaternion ()}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets quaternion to identity (0, 0, 0, 1) }}\par
{
Definition at line {\b 8} of file {\b Quaternion.cpp}.}\par
}
{\xe \v CQuaternion\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:CQuaternion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CQuaternion::CQuaternion (float fX, float fY, float fZ, float fW)}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets quaternion from given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fX} \cell }{The X component \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fY} \cell }{The Y component \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fZ} \cell }{The Z component \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fW} \cell }{The W component \cell }
{\row }
}
}{
Definition at line {\b 13} of file {\b Quaternion.cpp}.}\par
}
{\xe \v CQuaternion\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:CQuaternion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CQuaternion::CQuaternion (const {\b CQuaternion} & quaternion)}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets quaternion from given quaternion. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i quaternion} \cell }{The source quaternion to set this one's values to. \cell }
{\row }
}
}{
Definition at line {\b 21} of file {\b Quaternion.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getAngle\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:getAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CQuaternion::getAngle (void ) const}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns this quaternion's angle in radians. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The angle in radians the rotation is around it's axis \par
}}}{
Definition at line {\b 185} of file {\b Quaternion.cpp}.}\par
}
{\xe \v getAxis\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:getAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CQuaternion::getAxis (void ) const}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns this quaternion's axis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} holding the axis \par
}}}{
Definition at line {\b 179} of file {\b Quaternion.cpp}.}\par
}
{\xe \v getConjugate\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:getConjugate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CQuaternion} DCL::CQuaternion::getConjugate (void ) const}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a quaternion with this quaternion's first three components negated. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CQuaternion} with the first three components negated \par
}}}{
Definition at line {\b 159} of file {\b Quaternion.cpp}.}\par
}
{\xe \v getEuler\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:getEuler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CQuaternion::getEuler (void ) const}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector containing the amount of rotation around each local axis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CVector3f} containing the amount of rotation around each local axis \par
}}}{
Definition at line {\b 206} of file {\b Quaternion.cpp}.}\par
}
{\xe \v getLERP\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:getLERP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CQuaternion} DCL::CQuaternion::getLERP (const {\b CQuaternion} & quaternion, float fInterval) const}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a quaternion which is interpolated between this quat and the one given using linear interpolation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i quaternion} \cell }{The other quaternion \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fInterval} \cell }{The interval \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The resulting quaternion \par
}}}{
Definition at line {\b 293} of file {\b Quaternion.cpp}.}\par
}
{\xe \v getMagnitude\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:getMagnitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CQuaternion::getMagnitude (void ) const}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets magnitude of the quaternion. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The magnitude or length of the quaternion \par
}}}{
Definition at line {\b 139} of file {\b Quaternion.cpp}.}\par
}
{\xe \v getNegative\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:getNegative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CQuaternion} DCL::CQuaternion::getNegative (void ) const}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a quaternion with all of this quaternion's components negated. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b CQuaternion} with all four components negated \par
}}}{
Definition at line {\b 164} of file {\b Quaternion.cpp}.}\par
}
{\xe \v getSLERP\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:getSLERP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CQuaternion} DCL::CQuaternion::getSLERP (const {\b CQuaternion} & quaternion, float fInterval) const}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a quaternion which is interpolated between this quat and the one given using smooth SLERP. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i quaternion} \cell }{The other quaternion \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fInterval} \cell }{The interval \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The resulting quaternion \par
}}}{
Definition at line {\b 270} of file {\b Quaternion.cpp}.}\par
}
{\xe \v normalise\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:normalise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuaternion::normalise (void )}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalizes the quaternion. }}\par
{
Definition at line {\b 147} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator!=\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const bool DCL::CQuaternion::operator!= (const {\b CQuaternion} & quat) const}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparison operator. }}\par
{
Definition at line {\b 128} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator*\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CQuaternion} DCL::CQuaternion::operator* (const {\b CQuaternion} & quaternion) const}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply this quaternion by another and return result. }}\par
{
Definition at line {\b 31} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator*\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CQuaternion::operator* (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply a vector, return result. }}\par
{
Definition at line {\b 106} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator*\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CQuaternion} DCL::CQuaternion::operator* (const float fScalar) const}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply by scalar, return result. }}\par
{
Definition at line {\b 87} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator*=\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const void DCL::CQuaternion::operator*= (const {\b CQuaternion} & quaternion)}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiply this quaternion by another. }}\par
{
Definition at line {\b 53} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator+\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CQuaternion} DCL::CQuaternion::operator+ (const {\b CQuaternion} & quat) const}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add two quaternions, return result. }}\par
{
Definition at line {\b 69} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator-\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CQuaternion} DCL::CQuaternion::operator- (const {\b CQuaternion} & quat) const}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtract two quaternions, return result. }}\par
{
Definition at line {\b 78} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator/\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CQuaternion} DCL::CQuaternion::operator/ (const float fScalar) const}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Divide by scalar, return result. }}\par
{
Definition at line {\b 96} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator=\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const void DCL::CQuaternion::operator= (const {\b CQuaternion} & quat)}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set this quaternion to the one on the right of the operator. }}\par
{
Definition at line {\b 118} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator==\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const bool DCL::CQuaternion::operator== (const {\b CQuaternion} & quat) const}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparison operator. }}\par
{
Definition at line {\b 123} of file {\b Quaternion.cpp}.}\par
}
{\xe \v operator[]\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float & DCL::CQuaternion::operator[] (const int iIndex)}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Access each element. }}\par
{
Definition at line {\b 26} of file {\b Quaternion.cpp}.}\par
}
{\xe \v rotate\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:rotate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuaternion::rotate (const {\b CQuaternion} & quat)}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rotate this quaternion by another. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i quat} \cell }{The other quaternion \cell }
{\row }
}
}{
Definition at line {\b 264} of file {\b Quaternion.cpp}.}\par
}
{\xe \v setFromAxisAngle\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:setFromAxisAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuaternion::setFromAxisAngle (const {\b CVector3f} & vAxis, float fAngleRadians)}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this quaternion from an axis and an angle. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vAxis} \cell }{The axis to form the rotation around \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAngleRadians} \cell }{The amount in radians to be rotated around the given axis\cell }
{\row }
}
This does not normalize the given axis \par
}{
Definition at line {\b 169} of file {\b Quaternion.cpp}.}\par
}
{\xe \v setFromEuler\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:setFromEuler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuaternion::setFromEuler (float fAngleRadiansX, float fAngleRadiansY, float fAngleRadiansZ)}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this quaternion from Euler angles. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAngleRadiansX} \cell }{The angle in radians along the euler X axis \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAngleRadiansY} \cell }{The angle in radians along the euler Y axis \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fAngleRadiansZ} \cell }{The angle in radians along the euler Z axis \cell }
{\row }
}
}{
Definition at line {\b 190} of file {\b Quaternion.cpp}.}\par
}
{\xe \v setFromMatrix\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:setFromMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuaternion::setFromMatrix (const {\b CMatrix} & matrix)}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets quaternion from given {\b CMatrix}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i matrix} \cell }{A {\b CMatrix} which we take it's stored rotation from \cell }
{\row }
}
}{
Definition at line {\b 222} of file {\b Quaternion.cpp}.}\par
}
{\xe \v setIdentity\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:setIdentity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CQuaternion::setIdentity (void )}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets quaternion to identity (0, 0, 0, 1) }}\par
{
Definition at line {\b 133} of file {\b Quaternion.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v q\:DCL::CQuaternion}
{\xe \v DCL::CQuaternion\:q}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CQuaternion::q[4]}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
x, y, z and w }}\par
{
Definition at line {\b 142} of file {\b Quaternion.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Quaternion.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Quaternion.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CRay Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CRay}
{\xe \v DCL::CRay}
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A ray class used to represent a ray. }}\par
{
{\f2 #include <Ray.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRay} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, does nothing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b at} (float t) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given the value t, returns a {\b CVector3f} which represents a point along a ray. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b vOrigin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The origin position of the ray. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b vDirection}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The direction of the ray. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A ray class used to represent a ray. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
All ray tracers need rays!
This class represents one.
A ray tracer sends rays through pixels and computes the colour seen by these rays.
Here's the steps involved...
Step 1: Compute a ray from the eye, through a pixel
Step 2: Compute which objects if any that the ray intersects with
Step 3: Compute the colour for the closest intersection position.


\par}
 \par
}{
Definition at line {\b 26} of file {\b Ray.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CRay\:DCL::CRay}
{\xe \v DCL::CRay\:CRay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CRay::CRay ()}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, does nothing. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initial values of vOrigin and vDirection are both zero upon their construction \par
}{
Definition at line {\b 5} of file {\b Ray.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v at\:DCL::CRay}
{\xe \v DCL::CRay\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CRay::at (float t) const}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given the value t, returns a {\b CVector3f} which represents a point along a ray. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i t} \cell }{The amount along the ray from it's origin which we wish to "project" along and find the position. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed position along the ray\par
}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Here's an equation I borrowed from somewhere...
P(t) = A + tb
P is a 3D position along a line/ray
A is the ray's origin position
b is the ray direction
t is a float or double which represents the position along the ray
So for example...
if t was 0.0, then the position would be at the ray's origin
if t was 1.0, then the position would be from the ray's origin, along it's direction by 1 unit
if t was -1.0, then the position would be from the ray's origin, "behind" the origin by 1 unit
Doxygen to the rescue again, here's an image I badly drew on the Wacom tablet...
\par}
  \par
}{
Definition at line {\b 10} of file {\b Ray.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v vDirection\:DCL::CRay}
{\xe \v DCL::CRay\:vDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CRay::vDirection}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The direction of the ray. }}\par
{
Definition at line {\b 56} of file {\b Ray.h}.}\par
}
{\xe \v vOrigin\:DCL::CRay}
{\xe \v DCL::CRay\:vOrigin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CRay::vOrigin}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The origin position of the ray. }}\par
{
Definition at line {\b 55} of file {\b Ray.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/{\b Ray.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/Ray.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CRect Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CRect}
{\xe \v DCL::CRect}
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a non-uniform cube aka a rectangle. }}\par
{
{\f2 #include <Rect.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRect} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets everything to zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRect} (int iMinX, int iMinY, int iMaxX, int iMaxY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct the rectangle, setting to passed values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (int iMinX, int iMinY, int iMaxX, int iMaxY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this rect using given values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b intersects} (const {\b CRect} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the passed {\b CRect} intersects with this one. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resizeArea} (int iMultiplier)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the rect so that it's dimensions are multiplied by the given int. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doesPositionFitWithin} (int iPosX, int iPosY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a position, returns whether it fits within this rect or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doesPositionFitWithin} (const {\b CVector2f} &vPos)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a position, returns whether it fits within this rect or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getCentre} (int &iCentreX, int &iCentreY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the centre position of the rect. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b miMinX}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The minimum position of this rectangle along X. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b miMinY}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The minimum position of this rectangle along Y. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b miMaxX}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum position of this rectangle along X. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b miMaxY}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum position of this rectangle along Y. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a non-uniform cube aka a rectangle. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to compute whether two rects intersect one another \par
}{
Definition at line {\b 16} of file {\b Rect.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CRect\:DCL::CRect}
{\xe \v DCL::CRect\:CRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CRect::CRect ()}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, sets everything to zero. }}\par
{
Definition at line {\b 5} of file {\b Rect.cpp}.}\par
}
{\xe \v CRect\:DCL::CRect}
{\xe \v DCL::CRect\:CRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CRect::CRect (int iMinX, int iMinY, int iMaxX, int iMaxY)}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct the rectangle, setting to passed values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMinX} \cell }{The minimum value of the rectangle along X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMinY} \cell }{The minimum value of the rectangle along Y \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMaxX} \cell }{The maximum value of the rectangle along X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMaxY} \cell }{The maximum value of the rectangle along Y \cell }
{\row }
}
}{
Definition at line {\b 9} of file {\b Rect.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v doesPositionFitWithin\:DCL::CRect}
{\xe \v DCL::CRect\:doesPositionFitWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CRect::doesPositionFitWithin (const {\b CVector2f} & vPos)}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a position, returns whether it fits within this rect or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vPos} \cell }{The position to check if it fits within this rect or not \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the given position fits within this rect. \par
}}}{
Definition at line {\b 73} of file {\b Rect.cpp}.}\par
}
{\xe \v doesPositionFitWithin\:DCL::CRect}
{\xe \v DCL::CRect\:doesPositionFitWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CRect::doesPositionFitWithin (int iPosX, int iPosY)}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a position, returns whether it fits within this rect or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPosX} \cell }{The position along X to check if it fits within this rect or not \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iPosY} \cell }{The position along X to check if it fits within this rect or not \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the given position fits within this rect. \par
}}}{
Definition at line {\b 60} of file {\b Rect.cpp}.}\par
}
{\xe \v getCentre\:DCL::CRect}
{\xe \v DCL::CRect\:getCentre}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRect::getCentre (int & iCentreX, int & iCentreY)}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the centre position of the rect. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iCentreX} \cell }{Will hold the position of this rect for the X axis \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iCentreY} \cell }{Will hold the position of this rect for the Y axis \cell }
{\row }
}
}{
Definition at line {\b 78} of file {\b Rect.cpp}.}\par
}
{\xe \v intersects\:DCL::CRect}
{\xe \v DCL::CRect\:intersects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CRect::intersects (const {\b CRect} & other) const}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the passed {\b CRect} intersects with this one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{The other CRest to test for intersection with this one \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if an intersection would happen, else false. \par
}}}{
Definition at line {\b 25} of file {\b Rect.cpp}.}\par
}
{\xe \v resizeArea\:DCL::CRect}
{\xe \v DCL::CRect\:resizeArea}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRect::resizeArea (int iMultiplier)}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the rect so that it's dimensions are multiplied by the given int. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMultiplier} \cell }{The multiplier\cell }
{\row }
}
Example: If mvMin = (0,0) and mvMax = (10,10) (total dims of (10,10)) and the given int is 2 then the new values would be mvMin = (-5,-5) and mvMax = (15,15) (total dims of (20, 20)) \par
}{
Definition at line {\b 39} of file {\b Rect.cpp}.}\par
}
{\xe \v set\:DCL::CRect}
{\xe \v DCL::CRect\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRect::set (int iMinX, int iMinY, int iMaxX, int iMaxY)}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this rect using given values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMinX} \cell }{The minimum value of the rectangle along X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMinY} \cell }{The minimum value of the rectangle along Y \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMaxX} \cell }{The maximum value of the rectangle along X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMaxY} \cell }{The maximum value of the rectangle along Y \cell }
{\row }
}
}{
Definition at line {\b 17} of file {\b Rect.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v miMaxX\:DCL::CRect}
{\xe \v DCL::CRect\:miMaxX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CRect::miMaxX}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum position of this rectangle along X. }}\par
{
Definition at line {\b 74} of file {\b Rect.h}.}\par
}
{\xe \v miMaxY\:DCL::CRect}
{\xe \v DCL::CRect\:miMaxY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CRect::miMaxY}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum position of this rectangle along Y. }}\par
{
Definition at line {\b 75} of file {\b Rect.h}.}\par
}
{\xe \v miMinX\:DCL::CRect}
{\xe \v DCL::CRect\:miMinX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CRect::miMinX}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The minimum position of this rectangle along X. }}\par
{
Definition at line {\b 72} of file {\b Rect.h}.}\par
}
{\xe \v miMinY\:DCL::CRect}
{\xe \v DCL::CRect\:miMinY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CRect::miMinY}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The minimum position of this rectangle along Y. }}\par
{
Definition at line {\b 73} of file {\b Rect.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Rect.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Rect.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CRendererBase Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CRendererBase}
{\xe \v DCL::CRendererBase}
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for the various renderers. }}\par
{
{\f2 #include <RendererBase.h>}}\par
Inheritance diagram for DCL::CRendererBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_d_c_l_1_1_c_renderer_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialise} (unsigned int iWindowWidth, unsigned int iWindowHeight, const std::string &strWindowTitle, bool bFullscreen)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise a window with the graphics API all hooked up and ready to go. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b shutdown} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shutdown and close the API and window. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b blendDisable} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable blending. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b blendEnable} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable blending. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b blendFunction_SrcAlpha_One} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, One. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b blendFunction_SrcAlpha_OneMinusSrcAlpha} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, OneMinusSrcAlpha. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b cullFaceAntiClockwise} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of anti clockwise faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b cullFaceClockwise} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of clockwise faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b cullFaceDisable} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable culling of faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b cullFaceEnable} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable culling of faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b depthTestDisable} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable depth testing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b depthTestEnable} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable depth testing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b pixelsRead} (int iPositionX, int iPositionY, int iWidth, int iHeight, void *pixels)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read pixels from the currently set "back buffer". }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b pixelsWrite} (int iPositionX, int iPositionY, int iWidth, int iHeight, void *pixels)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write pixels from the currently set "back buffer". }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b scissorTest} (int iPositionX, int iPositionY, int iWidth, int iHeight)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set parameters for scissor test. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b scissorTestDisable} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable scissor testing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b scissorTestEnable} (void)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable scissor testing. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for the various renderers. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class which declares which methods need to be in a renderer class. No implementation here. Every method in here is pure virtual (The virtual keyword and the "= 0" at the end) All the various rendering classes (such as the user interface class for example) use the methods declared here to render stuff in a generic way. This allows us, to write all the rendering code in an API independent way, so if we wish to use a different API, we don't have to re-write all the rendering code. We implement multiple renderer classes which are based upon this class, then create a pointer to one of those classes and store that in a CRenderer pointer depending upon which renderer we wish to use (OpenGL, Vulkan, maybe software (at a later date)). The only disadvantage I can think of is more work. The advantages are plentiful! Being able to switch APIs is fun and good for a few reasons... If some end user piece of software is buggy and crashing when using the Vulkan API, I can just say "Try the more stable OpenGL renderer" as I'm a little uncertain what I'm doing with Vulkan and it gives me a nice user support feature :) It'll also be fun to compare performance between the different APIs.\par
We use Cheshire cat/pimpl for the derived renderer classes as we do not wish to expose/make the APIs visible to any code, otherwise we might be tempted to call the APIs and that'd make a huge mess! So all objects needed by the renderer classes go inside the private implementation instead of their header files. \par
}{
Definition at line {\b 30} of file {\b RendererBase.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v blendDisable\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:blendDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::blendDisable (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable blending. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXS \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v blendEnable\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:blendEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::blendEnable (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable blending. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXV \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v blendFunction_SrcAlpha_One\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:blendFunction_SrcAlpha_One}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::blendFunction_SrcAlpha_One (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, One. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXY \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v blendFunction_SrcAlpha_OneMinusSrcAlpha\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:blendFunction_SrcAlpha_OneMinusSrcAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::blendFunction_SrcAlpha_OneMinusSrcAlpha (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, OneMinusSrcAlpha. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v cullFaceAntiClockwise\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:cullFaceAntiClockwise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::cullFaceAntiClockwise (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of anti clockwise faces. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYE \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v cullFaceClockwise\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:cullFaceClockwise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::cullFaceClockwise (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of clockwise faces. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYH \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v cullFaceDisable\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:cullFaceDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::cullFaceDisable (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable culling of faces. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v cullFaceEnable\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:cullFaceEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::cullFaceEnable (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable culling of faces. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v depthTestDisable\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:depthTestDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::depthTestDisable (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable depth testing. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v depthTestEnable\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:depthTestEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::depthTestEnable (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable depth testing. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initialise\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:initialise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::initialise (unsigned int iWindowWidth, unsigned int iWindowHeight, const std::string & strWindowTitle, bool bFullscreen){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise a window with the graphics API all hooked up and ready to go. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYW \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v pixelsRead\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:pixelsRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::pixelsRead (int iPositionX, int iPositionY, int iWidth, int iHeight, void * pixels){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read pixels from the currently set "back buffer". }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v pixelsWrite\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:pixelsWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::pixelsWrite (int iPositionX, int iPositionY, int iWidth, int iHeight, void * pixels){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write pixels from the currently set "back buffer". }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v scissorTest\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:scissorTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::scissorTest (int iPositionX, int iPositionY, int iWidth, int iHeight){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set parameters for scissor test. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZF \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v scissorTestDisable\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:scissorTestDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::scissorTestDisable (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable scissor testing. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v scissorTestEnable\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:scissorTestEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::scissorTestEnable (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable scissor testing. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZL \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v shutdown\:DCL::CRendererBase}
{\xe \v DCL::CRendererBase\:shutdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void DCL::CRendererBase::shutdown (void ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shutdown and close the API and window. }}\par
{
Implemented in {\b DCL::CRendererOpenGL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZO \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b DCL::CRendererVulkan} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererBase.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CRendererManager Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CRendererManager}
{\xe \v DCL::CRendererManager}
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renderer manager class for creating and holding a renderer. }}\par
{
{\f2 #include <RendererManager.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRendererBase} * {\b initOpenGL} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialises the renderer by creating a window and hooking up the OpenGL API ready for use. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRendererBase} * {\b initVulkan} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialises the renderer by creating a window and hooking up the Vulkan API ready for use. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRendererBase} * {\b get} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer the a {\b CRendererBase} object if a call to one of the initAPINAME methods have previously been called. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renderer manager class for creating and holding a renderer. \par
}{
Definition at line {\b 15} of file {\b RendererManager.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CRendererManager\:DCL::CRendererManager}
{\xe \v DCL::CRendererManager\:CRendererManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CRendererManager::CRendererManager ()}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b RendererManager.cpp}.}\par
}
{\xe \v ~CRendererManager\:DCL::CRendererManager}
{\xe \v DCL::CRendererManager\:~CRendererManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CRendererManager::~CRendererManager ()}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b RendererManager.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get\:DCL::CRendererManager}
{\xe \v DCL::CRendererManager\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CRendererBase} * DCL::CRendererManager::get (void )}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer the a {\b CRendererBase} object if a call to one of the initAPINAME methods have previously been called. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to a {\b CRendererBase} object which we use to perform all the rendering operations if it has been initialised, otherwise, an exception will occur. A call to either {\b initOpenGL()} or {\b initVulkan()} or any of the other init methods will fix this exception from occurring. \par
}}}{
Definition at line {\b 31} of file {\b RendererManager.cpp}.}\par
}
{\xe \v initOpenGL\:DCL::CRendererManager}
{\xe \v DCL::CRendererManager\:initOpenGL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CRendererBase} * DCL::CRendererManager::initOpenGL (void )}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialises the renderer by creating a window and hooking up the OpenGL API ready for use. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to a {\b CRendererBase} object which we use to perform all the rendering operations. \par
}}}{
Definition at line {\b 16} of file {\b RendererManager.cpp}.}\par
}
{\xe \v initVulkan\:DCL::CRendererManager}
{\xe \v DCL::CRendererManager\:initVulkan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CRendererBase} * DCL::CRendererManager::initVulkan (void )}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialises the renderer by creating a window and hooking up the Vulkan API ready for use. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to a {\b CRendererBase} object which we use to perform all the rendering operations. \par
}}}{
Definition at line {\b 24} of file {\b RendererManager.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererManager.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererManager.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CRendererOpenGL Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL}
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
Inheritance diagram for DCL::CRendererOpenGL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_d_c_l_1_1_c_renderer_open_g_l.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialise} (unsigned int iWindowWidth, unsigned int iWindowHeight, const std::string &strWindowTitle, bool bFullscreen)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise a window with the graphics API all hooked up and ready to go. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shutdown} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shutdown and close the API and window. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blendDisable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable blending. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blendEnable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable blending. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blendFunction_SrcAlpha_One} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, One. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blendFunction_SrcAlpha_OneMinusSrcAlpha} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, OneMinusSrcAlpha. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cullFaceAntiClockwise} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of anti clockwise faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cullFaceClockwise} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of clockwise faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cullFaceDisable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable culling of faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cullFaceEnable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable culling of faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b depthTestDisable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable depth testing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b depthTestEnable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable depth testing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsRead} (int iPositionX, int iPositionY, int iWidth, int iHeight, void *pixels)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read pixels from the currently set "back buffer". }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsWrite} (int iPositionX, int iPositionY, int iWidth, int iHeight, void *pixels)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write pixels from the currently set "back buffer". }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scissorTest} (int iPositionX, int iPositionY, int iWidth, int iHeight)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set parameters for scissor test. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scissorTestDisable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable scissor testing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scissorTestEnable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable scissor testing. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 13} of file {\b RendererOpenGL.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CRendererOpenGL\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:CRendererOpenGL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CRendererOpenGL::CRendererOpenGL ()}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v ~CRendererOpenGL\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:~CRendererOpenGL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CRendererOpenGL::~CRendererOpenGL ()}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b RendererOpenGL.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v blendDisable\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:blendDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::blendDisable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable blending. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 24} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v blendEnable\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:blendEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::blendEnable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable blending. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 29} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v blendFunction_SrcAlpha_One\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:blendFunction_SrcAlpha_One}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::blendFunction_SrcAlpha_One (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, One. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 34} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v blendFunction_SrcAlpha_OneMinusSrcAlpha\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:blendFunction_SrcAlpha_OneMinusSrcAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::blendFunction_SrcAlpha_OneMinusSrcAlpha (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, OneMinusSrcAlpha. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 39} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v cullFaceAntiClockwise\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:cullFaceAntiClockwise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::cullFaceAntiClockwise (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of anti clockwise faces. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 44} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v cullFaceClockwise\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:cullFaceClockwise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::cullFaceClockwise (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of clockwise faces. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 49} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v cullFaceDisable\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:cullFaceDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::cullFaceDisable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable culling of faces. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 54} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v cullFaceEnable\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:cullFaceEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::cullFaceEnable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable culling of faces. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 59} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v depthTestDisable\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:depthTestDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::depthTestDisable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable depth testing. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 64} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v depthTestEnable\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:depthTestEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::depthTestEnable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable depth testing. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 69} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v initialise\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:initialise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::initialise (unsigned int iWindowWidth, unsigned int iWindowHeight, const std::string & strWindowTitle, bool bFullscreen){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise a window with the graphics API all hooked up and ready to go. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 14} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v pixelsRead\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:pixelsRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::pixelsRead (int iPositionX, int iPositionY, int iWidth, int iHeight, void * pixels){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read pixels from the currently set "back buffer". }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 74} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v pixelsWrite\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:pixelsWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::pixelsWrite (int iPositionX, int iPositionY, int iWidth, int iHeight, void * pixels){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write pixels from the currently set "back buffer". }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 79} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v scissorTest\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:scissorTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::scissorTest (int iPositionX, int iPositionY, int iWidth, int iHeight){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set parameters for scissor test. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 84} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v scissorTestDisable\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:scissorTestDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::scissorTestDisable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable scissor testing. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 94} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v scissorTestEnable\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:scissorTestEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::scissorTestEnable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable scissor testing. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 89} of file {\b RendererOpenGL.cpp}.}\par
}
{\xe \v shutdown\:DCL::CRendererOpenGL}
{\xe \v DCL::CRendererOpenGL\:shutdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererOpenGL::shutdown (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shutdown and close the API and window. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 19} of file {\b RendererOpenGL.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererOpenGL.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererOpenGL.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CRendererVulkan Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan}
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
Inheritance diagram for DCL::CRendererVulkan:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_d_c_l_1_1_c_renderer_vulkan.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialise} (unsigned int iWindowWidth, unsigned int iWindowHeight, const std::string &strWindowTitle, bool bFullscreen)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise a window with the graphics API all hooked up and ready to go. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shutdown} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shutdown and close the API and window. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blendDisable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable blending. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blendEnable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable blending. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blendFunction_SrcAlpha_One} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, One. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blendFunction_SrcAlpha_OneMinusSrcAlpha} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, OneMinusSrcAlpha. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cullFaceAntiClockwise} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of anti clockwise faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cullFaceClockwise} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of clockwise faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cullFaceDisable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable culling of faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cullFaceEnable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable culling of faces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b depthTestDisable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable depth testing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b depthTestEnable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable depth testing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsRead} (int iPositionX, int iPositionY, int iWidth, int iHeight, void *pixels)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read pixels from the currently set "back buffer". }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsWrite} (int iPositionX, int iPositionY, int iWidth, int iHeight, void *pixels)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write pixels from the currently set "back buffer". }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scissorTest} (int iPositionX, int iPositionY, int iWidth, int iHeight)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set parameters for scissor test. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scissorTestDisable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable scissor testing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scissorTestEnable} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable scissor testing. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 13} of file {\b RendererVulkan.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CRendererVulkan\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:CRendererVulkan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CRendererVulkan::CRendererVulkan ()}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v ~CRendererVulkan\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:~CRendererVulkan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CRendererVulkan::~CRendererVulkan ()}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b RendererVulkan.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v blendDisable\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:blendDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::blendDisable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable blending. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 24} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v blendEnable\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:blendEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::blendEnable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable blending. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 29} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v blendFunction_SrcAlpha_One\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:blendFunction_SrcAlpha_One}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::blendFunction_SrcAlpha_One (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, One. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 34} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v blendFunction_SrcAlpha_OneMinusSrcAlpha\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:blendFunction_SrcAlpha_OneMinusSrcAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::blendFunction_SrcAlpha_OneMinusSrcAlpha (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set blending mode to SourceAlpha, OneMinusSrcAlpha. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 39} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v cullFaceAntiClockwise\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:cullFaceAntiClockwise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::cullFaceAntiClockwise (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of anti clockwise faces. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 44} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v cullFaceClockwise\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:cullFaceClockwise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::cullFaceClockwise (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set culling of clockwise faces. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 49} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v cullFaceDisable\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:cullFaceDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::cullFaceDisable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable culling of faces. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 54} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v cullFaceEnable\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:cullFaceEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::cullFaceEnable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable culling of faces. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 59} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v depthTestDisable\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:depthTestDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::depthTestDisable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable depth testing. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 64} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v depthTestEnable\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:depthTestEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::depthTestEnable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable depth testing. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 69} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v initialise\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:initialise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::initialise (unsigned int iWindowWidth, unsigned int iWindowHeight, const std::string & strWindowTitle, bool bFullscreen){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise a window with the graphics API all hooked up and ready to go. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 14} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v pixelsRead\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:pixelsRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::pixelsRead (int iPositionX, int iPositionY, int iWidth, int iHeight, void * pixels){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read pixels from the currently set "back buffer". }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 74} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v pixelsWrite\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:pixelsWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::pixelsWrite (int iPositionX, int iPositionY, int iWidth, int iHeight, void * pixels){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write pixels from the currently set "back buffer". }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 79} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v scissorTest\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:scissorTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::scissorTest (int iPositionX, int iPositionY, int iWidth, int iHeight){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set parameters for scissor test. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 84} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v scissorTestDisable\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:scissorTestDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::scissorTestDisable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable scissor testing. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 94} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v scissorTestEnable\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:scissorTestEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::scissorTestEnable (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable scissor testing. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 89} of file {\b RendererVulkan.cpp}.}\par
}
{\xe \v shutdown\:DCL::CRendererVulkan}
{\xe \v DCL::CRendererVulkan\:shutdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CRendererVulkan::shutdown (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shutdown and close the API and window. }}\par
{
Implements {\b DCL::CRendererBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 19} of file {\b RendererVulkan.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/{\b RendererVulkan.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererVulkan.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CSingleton< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CSingleton< T >}
{\xe \v DCL::CSingleton< T >}
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton class to inherit from. }}\par
{
{\f2 #include <Singleton.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static T * {\b getPointer} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Obtain pointer to class object. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static T * {\b pInstance} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer holding the single instance. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T>\par
class DCL::CSingleton< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton class to inherit from. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Usage: Create a class from this template class with something like... {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 class }MyClass : {\cf17 public} CSingleton<MyClass>\par
\{\par
    {\cf20 // Rest of class declaration here}\par
\}\par
}
 From then on, whenever we create an object of MyClass like normal, it only has one instance, all variables are shared. To create a pointer to the singleton... {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid MyClass *pMyClass = MyClass::getPointer();\par
{\cf20 // Then you can access all the public stuff with something like...}\par
pMyClass->someMethod();\par
}
 \par
}{
Definition at line {\b 29} of file {\b Singleton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~CSingleton\:DCL::CSingleton< T >}
{\xe \v DCL::CSingleton< T >\:~CSingleton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > virtual {\b DCL::CSingleton}< T >::~{\b CSingleton} (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Singleton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getPointer\:DCL::CSingleton< T >}
{\xe \v DCL::CSingleton< T >\:getPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > static T * {\b DCL::CSingleton}< T >::getPointer (void ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Obtain pointer to class object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to the single instance of the class.\par
}}If not yet created, the object will be created here and it's constructor called \par
 \par
}{
Definition at line {\b 46} of file {\b Singleton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v pInstance\:DCL::CSingleton< T >}
{\xe \v DCL::CSingleton< T >\:pInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > T * {\b DCL::CSingleton}< T >::pInstance = 0{\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer holding the single instance. }}\par
{
Definition at line {\b 56} of file {\b Singleton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Singleton.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CTimer Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CTimer}
{\xe \v DCL::CTimer}
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with additional features compared to {\b CTimerMinimal}. }}\par
{
{\f2 #include <Timer.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimer} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call this to compute time difference between last call to this method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pause} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pause this timer, preventing any updates and making it so {\b getSecondsPast()} returns zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resume} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the timer was paused with a call to {\b pause()}, this resumes business as normal. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getSecondsPast} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns time passed in seconds since last call to {\b update()} method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sleep} (unsigned int uiMilliseconds) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Suspends execution of the calling thread for the parsed number of milliseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAveragedFPSRate} (float fSecondsBetweenUpdates)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the delay in seconds at which the {\b getFPSAveraged()} method's return value will be updated. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getAveragedFPSRate} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the currently set rate at which the {\b getFPSAveraged()} method's return value will be updated per second. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getFPS} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns computed Frames Per Second current value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getFPSAveraged} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns computed Frames Per Second averaged value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getFPSAveragedTimeUntilNextUpdate} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of seconds until the next time the FPSAveraged value is updated. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets all values to sane values, including the member set by {\b setAveragedFPSRate()} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getRuntimeSeconds} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns amount of seconds that we've been calling {\b update()} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getClock} (float &fSeconds, int &iMinutes, int &iHours, int &iDays, int &iWeeks) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Based on current runtime, sets parsed values to seconds, minutes, hours, days and weeks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getClock} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Based on current runtime, returns current runtime as a string holding seconds, minutes, hours, days and weeks. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with additional features compared to {\b CTimerMinimal}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an object of this class, keep it around and call {\b update()} between the code which you wish to measure the time difference. Then call {\b getSecondsPast()} to obtain the time passed since the two calls to {\b update()} There are also two framerate methods which return what the framerate is, based on the time passed between the last two calls to {\b update()}. There's {\b getFPS()} which simply returns the current frames per second and then there's... {\b getFPSAveraged()} which returns the frames per second which have been averaged over a certain amount of time. This "certain amount of time" is, by default, set to be 1 update per second, but can be changed with a call to {\b setAveragedFPSRate()} \par
}{
Definition at line {\b 22} of file {\b Timer.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTimer\:DCL::CTimer}
{\xe \v DCL::CTimer\:CTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CTimer::CTimer ()}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{
Definition at line {\b 7} of file {\b Timer.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getAveragedFPSRate\:DCL::CTimer}
{\xe \v DCL::CTimer\:getAveragedFPSRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CTimer::getAveragedFPSRate (void ) const}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the currently set rate at which the {\b getFPSAveraged()} method's return value will be updated per second. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The currently set rate at which the {\b getFPSAveraged()} method's return value will be updated per second. \par
}}}{
Definition at line {\b 79} of file {\b Timer.cpp}.}\par
}
{\xe \v getClock\:DCL::CTimer}
{\xe \v DCL::CTimer\:getClock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CTimer::getClock (float & fSeconds, int & iMinutes, int & iHours, int & iDays, int & iWeeks) const}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Based on current runtime, sets parsed values to seconds, minutes, hours, days and weeks. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fSeconds} \cell }{Will hold the runtime's seconds past \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iMinutes} \cell }{Will hold the runtime's minutes past \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iHours} \cell }{Will hold the runtime's hours past \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iDays} \cell }{Will hold the runtime's days past \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i iWeeks} \cell }{Will hold the runtime's weeks past \cell }
{\row }
}
}{
Definition at line {\b 127} of file {\b Timer.cpp}.}\par
}
{\xe \v getClock\:DCL::CTimer}
{\xe \v DCL::CTimer\:getClock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::CTimer::getClock (void ) const}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Based on current runtime, returns current runtime as a string holding seconds, minutes, hours, days and weeks. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current runtime as a string holding seconds, minutes, hours, days and weeks \par
}}}{
Definition at line {\b 164} of file {\b Timer.cpp}.}\par
}
{\xe \v getFPS\:DCL::CTimer}
{\xe \v DCL::CTimer\:getFPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CTimer::getFPS (void ) const}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns computed Frames Per Second current value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed Frames Per Second current value. \par
}}}{
Definition at line {\b 84} of file {\b Timer.cpp}.}\par
}
{\xe \v getFPSAveraged\:DCL::CTimer}
{\xe \v DCL::CTimer\:getFPSAveraged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CTimer::getFPSAveraged (void ) const}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns computed Frames Per Second averaged value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Computed Frames Per Second averaged value. \par
}}}{
Definition at line {\b 89} of file {\b Timer.cpp}.}\par
}
{\xe \v getFPSAveragedTimeUntilNextUpdate\:DCL::CTimer}
{\xe \v DCL::CTimer\:getFPSAveragedTimeUntilNextUpdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CTimer::getFPSAveragedTimeUntilNextUpdate (void ) const}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of seconds until the next time the FPSAveraged value is updated. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The number of seconds until the next time the FPSAveraged value is updated. \par
}}}{
Definition at line {\b 94} of file {\b Timer.cpp}.}\par
}
{\xe \v getRuntimeSeconds\:DCL::CTimer}
{\xe \v DCL::CTimer\:getRuntimeSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CTimer::getRuntimeSeconds (void ) const}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns amount of seconds that we've been calling {\b update()} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The amount of seconds that we've been calling {\b update()} \par
}}}{
Definition at line {\b 122} of file {\b Timer.cpp}.}\par
}
{\xe \v getSecondsPast\:DCL::CTimer}
{\xe \v DCL::CTimer\:getSecondsPast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CTimer::getSecondsPast (void ) const}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns time passed in seconds since last call to {\b update()} method. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Time passed in seconds since last call to {\b update()} method. \par
}}}{
Definition at line {\b 22} of file {\b Timer.cpp}.}\par
}
{\xe \v pause\:DCL::CTimer}
{\xe \v DCL::CTimer\:pause}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CTimer::pause (void )}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pause this timer, preventing any updates and making it so {\b getSecondsPast()} returns zero. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call Resume() to unpause. Only getSecondsPast is affected, all other methods still return normal values. \par
}{
Definition at line {\b 12} of file {\b Timer.cpp}.}\par
}
{\xe \v reset\:DCL::CTimer}
{\xe \v DCL::CTimer\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CTimer::reset (void )}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets all values to sane values, including the member set by {\b setAveragedFPSRate()} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Also, if this timer has been paused, it is unpaused. \par
}{
Definition at line {\b 99} of file {\b Timer.cpp}.}\par
}
{\xe \v resume\:DCL::CTimer}
{\xe \v DCL::CTimer\:resume}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CTimer::resume (void )}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the timer was paused with a call to {\b pause()}, this resumes business as normal. }}\par
{
Definition at line {\b 17} of file {\b Timer.cpp}.}\par
}
{\xe \v setAveragedFPSRate\:DCL::CTimer}
{\xe \v DCL::CTimer\:setAveragedFPSRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CTimer::setAveragedFPSRate (float fSecondsBetweenUpdates)}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the delay in seconds at which the {\b getFPSAveraged()} method's return value will be updated. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fSecondsBetweenUpdates} \cell }{How much time in seconds before the FPSS value is updated.\cell }
{\row }
}
For example, parsing a value of 3.0 for fSecondsBetweenUpdates will update once every 3 seconds which is the default \par
}{
Definition at line {\b 72} of file {\b Timer.cpp}.}\par
}
{\xe \v sleep\:DCL::CTimer}
{\xe \v DCL::CTimer\:sleep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CTimer::sleep (unsigned int uiMilliseconds) const}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Suspends execution of the calling thread for the parsed number of milliseconds. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uiMilliseconds} \cell }{The number of milliseconds to sleep for.\cell }
{\row }
}
The sleep may be lengthened slightly by any system activity or by the time spent processing the call or by the granularity of system timers. \par
 \par
}{
Definition at line {\b 66} of file {\b Timer.cpp}.}\par
}
{\xe \v update\:DCL::CTimer}
{\xe \v DCL::CTimer\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CTimer::update (void )}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call this to compute time difference between last call to this method. }}\par
{
Definition at line {\b 29} of file {\b Timer.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Timer.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Timer.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CTimerMinimal Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CTimerMinimal}
{\xe \v DCL::CTimerMinimal}
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with minimal features compared to {\b CTimer}. }}\par
{
{\f2 #include <TimerMinimal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerMinimal} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call this to compute time difference between the last two calls to this method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getSecondsPast} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the time passed in seconds between the last two calls to {\b update()} method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets all values to sane values. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with minimal features compared to {\b CTimer}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an object of this class, keep it around and call {\b update()} between the code which you wish to measure the time difference. Then call {\b getSecondsPast()} to obtain the time passed since the two calls to {\b update()} This class is similar to {\b CTimer}, but with less features and is slightly faster to compute. It also returns the time delta as a double instead of float for more precision. \par
}{
Definition at line {\b 20} of file {\b TimerMinimal.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTimerMinimal\:DCL::CTimerMinimal}
{\xe \v DCL::CTimerMinimal\:CTimerMinimal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CTimerMinimal::CTimerMinimal ()}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{
Definition at line {\b 5} of file {\b TimerMinimal.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getSecondsPast\:DCL::CTimerMinimal}
{\xe \v DCL::CTimerMinimal\:getSecondsPast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DCL::CTimerMinimal::getSecondsPast (void ) const}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the time passed in seconds between the last two calls to {\b update()} method. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Time passed in seconds between the last two calls to the {\b update()} method. \par
}}}{
Definition at line {\b 10} of file {\b TimerMinimal.cpp}.}\par
}
{\xe \v reset\:DCL::CTimerMinimal}
{\xe \v DCL::CTimerMinimal\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CTimerMinimal::reset (void )}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets all values to sane values. }}\par
{
Definition at line {\b 23} of file {\b TimerMinimal.cpp}.}\par
}
{\xe \v update\:DCL::CTimerMinimal}
{\xe \v DCL::CTimerMinimal\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CTimerMinimal::update (void )}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call this to compute time difference between the last two calls to this method. }}\par
{
Definition at line {\b 15} of file {\b TimerMinimal.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b TimerMinimal.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/TimerMinimal.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CVector2f Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CVector2f}
{\xe \v DCL::CVector2f}
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 2 floats. }}\par
{
{\f2 #include <Vector2f.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} (float fX, float fY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to the ones given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b operator+} (const {\b CVector2f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} & {\b operator+=} (const {\b CVector2f} &vec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b operator-} (const {\b CVector2f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} & {\b operator-=} (const {\b CVector2f} &vec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CVector2f} {\b operator*} (const float f) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator*=} (const float f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b CVector2f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for equality. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b CVector2f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for inequality. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b divide} (float fScaler)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Divides both components by the given scalar value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b multiply} (float fScaler)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies both elements by the given scalar value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (float fX, float fY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element to the values given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZero} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element within the vector's set to zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isZero} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines whether the vector is a zero vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b negate} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Negates the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getMagnitude} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes and returns the vector's magnitude. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalise} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalises this vector so that it becomes a unit vector (Has a magnitude of 1) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDistance} (const {\b CVector2f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes distance between this vector and the one given, treating each vector as a point in 2D space. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDistanceSquared} (const {\b CVector2f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes distance squared between this vector and the one given, treating each vector as a point in 2D space. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getSign} (const {\b CVector2f} &vOther) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns 1.0f if vOther is clockwise, else -1.0f if vOther is anticlockwise. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDot} (const {\b CVector2f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the dot product (also known as inner product) between this vector and the one given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getAngleRadiansUnsigned} (const {\b CVector2f} &vOther) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns angle (in radians between this and parsed vector (unsigned result) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getAngleRadiansSigned} (const {\b CVector2f} &vOther) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns signed angle (in radians) between this vector and one parsed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getAngleDegreesSigned} (const {\b CVector2f} &vOther) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns signed angle (in degrees) between this vector and one parsed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getAngleDegrees360} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns angle in degrees that this vector is from north (CVector2f(0,1)) in the range of 0-360. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rotate} (float fDegrees)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this vector represents a position, rotate it clockwise by the given number of degrees. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b limitLength} (float fMaxLength)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Limits the length of this vector so that is equal to or below the parsed value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b getPerpendicular} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector which is at right angle / 90 degrees / perpendicular to this one. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b interpolate} (const {\b CVector2f} &v1, const {\b CVector2f} &v2, float f) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines a point between two specified points. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getAsArray} (float *pArray) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns x and y as an array of floats. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b x}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The x component of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b y}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The y component of the vector. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 2 floats. \par
}{
Definition at line {\b 12} of file {\b Vector2f.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CVector2f\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:CVector2f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CVector2f::CVector2f ()}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to zero. }}\par
{
Definition at line {\b 6} of file {\b Vector2f.cpp}.}\par
}
{\xe \v CVector2f\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:CVector2f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CVector2f::CVector2f (float fX, float fY)}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to the ones given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fX} \cell }{X value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fY} \cell }{Y value \cell }
{\row }
}
}{
Definition at line {\b 11} of file {\b Vector2f.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v divide\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:divide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::divide (float fScaler)}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Divides both components by the given scalar value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fScaler} \cell }{The value to divide both components by\cell }
{\row }
}
If scalar given is less than 0.0000001, an exception occurs \par
}{
Definition at line {\b 62} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getAngleDegrees360\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getAngleDegrees360}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::getAngleDegrees360 (void ) const}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns angle in degrees that this vector is from north (CVector2f(0,1)) in the range of 0-360. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Angle in degrees which this vector is from north (CVector2f(0,1)) in the range of 0-360 \par
}}}{
Definition at line {\b 207} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getAngleDegreesSigned\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getAngleDegreesSigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::getAngleDegreesSigned (const {\b CVector2f} & vOther) const}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns signed angle (in degrees) between this vector and one parsed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vOther} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Signed angle (in degrees) between the two vectors\par
}}If given vector is clockwise of this vector, the angle (in degrees) will be positive, else negative \par
}{
Definition at line {\b 176} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getAngleRadiansSigned\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getAngleRadiansSigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::getAngleRadiansSigned (const {\b CVector2f} & vOther) const}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns signed angle (in radians) between this vector and one parsed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vOther} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The signed angle (in radians) between the two vectors.\par
}}If given vector is clockwise of this vector, the angle (in radians) will be positive, else negative \par
}{
Definition at line {\b 160} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getAngleRadiansUnsigned\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getAngleRadiansUnsigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::getAngleRadiansUnsigned (const {\b CVector2f} & vOther) const}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns angle (in radians between this and parsed vector (unsigned result) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vOther} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The angle (in radians) between the two vectors. (unsigned result) \par
}}}{
Definition at line {\b 150} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getAsArray\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getAsArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::getAsArray (float * pArray) const}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns x and y as an array of floats. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pArray} \cell }{A pointer to an array of at least size 2 which will hold both component values of the vector\cell }
{\row }
}
Example: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 float} array[2];\par
vector.getAsArray(array);\par
}
 \par
}{
Definition at line {\b 279} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getDistance\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::getDistance (const {\b CVector2f} & vec) const}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes distance between this vector and the one given, treating each vector as a point in 2D space. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector, as a position in 2D space \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed distance between this and the given vector \par
}}}{
Definition at line {\b 119} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getDistanceSquared\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getDistanceSquared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::getDistanceSquared (const {\b CVector2f} & vec) const}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes distance squared between this vector and the one given, treating each vector as a point in 2D space. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector, as a position in 2D space \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed squared distance between this and the given vector\par
}}This is faster than the {\b getDistance()} method, as no expensive square root is used. This is useful if you have many vectors/points and need to find the closest out of them all. After finding the closest, then you can squareroot the return value from this method or use {\b getDistance()} to obtain the true distance. \par
 \par
}{
Definition at line {\b 126} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getDot\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getDot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::getDot (const {\b CVector2f} & vec) const}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the dot product (also known as inner product) between this vector and the one given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The dot product\par
}}Dot product is commutative (v1.getDot(v2) == v2.getDot(v1)) == always true. If returned dot product is... \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid \zwj0 vectors are pointing roughly in same direction (upto 90 degrees apart) \par
}= 0 vectors are perpendicular to one another (90 degrees) < 0 vectors are pointing in opposite directions (+90 degrees to 180 degrees) \par
 \par
}{
Definition at line {\b 145} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getMagnitude\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getMagnitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::getMagnitude (void ) const}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes and returns the vector's magnitude. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The magnitude or length or norm of the vector\par
}}A vector's magnitude is also know as "the length" or norm of the vector. Uses sqrtf() so it's quite expensive. \par
}{
Definition at line {\b 98} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getPerpendicular\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getPerpendicular}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CVector2f::getPerpendicular (void ) const}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector which is at right angle / 90 degrees / perpendicular to this one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The perpendicular vector \par
}}}{
Definition at line {\b 259} of file {\b Vector2f.cpp}.}\par
}
{\xe \v getSign\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:getSign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::getSign (const {\b CVector2f} & vOther) const}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns 1.0f if vOther is clockwise, else -1.0f if vOther is anticlockwise. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vOther} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
1.0f if vOther is clockwise, else -1.0f if vOther is anticlockwise \par
}}}{
Definition at line {\b 133} of file {\b Vector2f.cpp}.}\par
}
{\xe \v interpolate\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:interpolate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CVector2f::interpolate (const {\b CVector2f} & v1, const {\b CVector2f} & v2, float f) const}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines a point between two specified points. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i v1} \cell }{The first vector which represents a point. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i v2} \cell }{The second vector which represents a point. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{Distance between v1 and v2. Range = 0.0 to 1.0 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The newly computed, interpolated point.\par
}}The parameter f determines where the new interpolated point is located relative to the two end points specified by parameters v1 and v2. The closer the value of the parameter f is to 1.0, the closer the interpolated point is to the first point (parameter v1). The closer the value of the parameter f is to 0, the closer the interpolated point is to the second point (parameter v2). Returns the new interpolated point \par
}{
Definition at line {\b 266} of file {\b Vector2f.cpp}.}\par
}
{\xe \v isZero\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:isZero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CVector2f::isZero (void ) const}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines whether the vector is a zero vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the vector is a zero vector. \par
}}}{
Definition at line {\b 87} of file {\b Vector2f.cpp}.}\par
}
{\xe \v limitLength\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:limitLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::limitLength (float fMaxLength)}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Limits the length of this vector so that is equal to or below the parsed value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fMaxLength} \cell }{The maximum length to limit this vector to.\cell }
{\row }
}
If the length of this vector does not exceed the one given, it remains unchanged. \par
}{
Definition at line {\b 250} of file {\b Vector2f.cpp}.}\par
}
{\xe \v multiply\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::multiply (float fScaler)}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies both elements by the given scalar value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fScaler} \cell }{The value to multiply both components by\cell }
{\row }
}
Adjusts the magnitude of a vector, keeping the direction the same (Unless the scalar is negative, in which case the direction is reversed) \par
 \par
}{
Definition at line {\b 70} of file {\b Vector2f.cpp}.}\par
}
{\xe \v negate\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:negate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::negate (void )}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Negates the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A negated vector has the same magnitude as before, however direction is reversed. \par
 \par
}{
Definition at line {\b 92} of file {\b Vector2f.cpp}.}\par
}
{\xe \v normalise\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:normalise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::normalise (void )}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalises this vector so that it becomes a unit vector (Has a magnitude of 1) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses sqrtf() so it's quite expensive. If the vector has zero length(magnitude), then it is not modified. \par
}{
Definition at line {\b 106} of file {\b Vector2f.cpp}.}\par
}
{\xe \v operator!=\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CVector2f::operator!= (const {\b CVector2f} & vec) const}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for inequality. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if both vectors are not the same \par
}}}{
Definition at line {\b 57} of file {\b Vector2f.cpp}.}\par
}
{\xe \v operator*\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CVector2f} DCL::CVector2f::operator* (const float f) const}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{The float value to multiply each of this vector's components by \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Adjusts the magnitude of a vector, keeping the direction the same (Unless the scalar is negative, in which case the direction is reversed) Example: CVector2r vTwo(2.0f, 2.0f); CVector2r vOne = vTwo * 0.5f; \par
}{
Definition at line {\b 41} of file {\b Vector2f.cpp}.}\par
}
{\xe \v operator*=\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::operator*= (const float f)}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{The scalar value which to multiply each of this vector's components by\cell }
{\row }
}
Adjusts the magnitude of a vector, keeping the direction the same (Unless the scalar is negative, in which case the direction is reversed) Example: CVector2r vOne(2.0f, 2.0f, 2.0f); vOne *= 0.5f; \par
 \par
}{
Definition at line {\b 46} of file {\b Vector2f.cpp}.}\par
}
{\xe \v operator+\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CVector2f::operator+ (const {\b CVector2f} & vec) const}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector addition is commutative. (v1 + v2 == v2 + v1) is always true. Triangle law of vector addition states that when two vectors are represented as two sides of the triangle with the order of magnitude and direction, then the third side of the triangle represents the magnitude and direction of the resultant vector. Example: CVector2r vOne(1.0f, 1.0f); CVector2r vTwo(2.0f, 2.0f); CVector2r vThree = vOne + vTwo; \par
}{
Definition at line {\b 17} of file {\b Vector2f.cpp}.}\par
}
{\xe \v operator+=\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} & DCL::CVector2f::operator+= (const {\b CVector2f} & vec)}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector addition is commutative. (v1 + v2 == v2 + v1) is always true. Triangle law of vector addition states that when two vectors are represented as two sides of the triangle with the order of magnitude and direction, then the third side of the triangle represents the magnitude and direction of the resultant vector. Example: CVector2r vOne(1.0f, 1.0f); CVector2r vThree(2.0f, 2.0f); vThree += vOne; \par
}{
Definition at line {\b 22} of file {\b Vector2f.cpp}.}\par
}
{\xe \v operator-\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CVector2f::operator- (const {\b CVector2f} & vec) const}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector subtraction is not commutative. (v1 - v2 == v2 - v1) is only true when v1 is same as v2. Example: CVector2r vOne(1.0f, 1.0f); CVector2r vTwo(2.0f, 2.0f); CVector2r vMinusOne = vOne - vTwo; \par
}{
Definition at line {\b 29} of file {\b Vector2f.cpp}.}\par
}
{\xe \v operator-=\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} & DCL::CVector2f::operator-= (const {\b CVector2f} & vec)}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector subtraction is not commutative. (v1 - v2 == v2 - v1) is only true when v1 is same as v2. Example: CVector2r vMinusOne(1.0f, 1.0f); CVector2r vTwo(2.0f, 2.0f); vMinusOne -= vTwo; \par
}{
Definition at line {\b 34} of file {\b Vector2f.cpp}.}\par
}
{\xe \v operator==\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CVector2f::operator== (const {\b CVector2f} & vec) const}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for equality. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if both vectors are the same \par
}}}{
Definition at line {\b 52} of file {\b Vector2f.cpp}.}\par
}
{\xe \v rotate\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:rotate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::rotate (float fDegrees)}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this vector represents a position, rotate it clockwise by the given number of degrees. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fDegrees} \cell }{The angle in degrees in which to rotate this vector when it represents a position \cell }
{\row }
}
}{
Definition at line {\b 238} of file {\b Vector2f.cpp}.}\par
}
{\xe \v set\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::set (float fX, float fY)}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element to the values given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fX} \cell }{The X component \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fY} \cell }{The Y component \cell }
{\row }
}
}{
Definition at line {\b 76} of file {\b Vector2f.cpp}.}\par
}
{\xe \v setZero\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:setZero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector2f::setZero (void )}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element within the vector's set to zero. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A zero vector is a special case. It does not have a direction, and it's magnitude is zero. \par
 \par
}{
Definition at line {\b 82} of file {\b Vector2f.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v x\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::x}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The x component of the vector. }}\par
{
Definition at line {\b 262} of file {\b Vector2f.h}.}\par
}
{\xe \v y\:DCL::CVector2f}
{\xe \v DCL::CVector2f\:y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector2f::y}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The y component of the vector. }}\par
{
Definition at line {\b 263} of file {\b Vector2f.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Vector2f.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector2f.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CVector3f Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CVector3f}
{\xe \v DCL::CVector3f}
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 3 floats. }}\par
{
{\f2 #include <Vector3f.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} (float fX, float fY, float fZ)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to the ones given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} (const {\b CVector3f} &vector)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values from the given {\b CVector3f}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b operator+} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} & {\b operator+=} (const {\b CVector3f} &vec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b operator-} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} & {\b operator-=} (const {\b CVector3f} &vec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CVector3f} {\b operator*} (const float f) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} & {\b operator*=} (const float f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for equality. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for inequality. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (float fX, float fY, float fZ)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element to the values given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZero} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element within the vector's set to zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isZero} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines whether the vector is a zero vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b negate} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Negates the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getMagnitude} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes and returns the vector's magnitude. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalise} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalises this vector so that it becomes a unit vector (Has a magnitude of 1) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDot} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the dot product (also known as inner product) between this vector and the one given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector3f} {\b getCross} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the cross product between this vector and the one given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getAngle} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the angle (in radians) between two UNIT VECTORS (Length of 1) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDistance} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes distance between this vector and the one given, treating each vector as a point in 3D space. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDistanceSquared} (const {\b CVector3f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes distance squared between this vector and the one given, treating each vector as a point in 3D space. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getAsArray} (float *pArray) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns x, y and z as an array of floats. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b multiply} (float f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies this vector by the given scalar value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b project} (const {\b CVector3f} &vOriginPosition, const {\b CVector3f} &vDirection, float fProjectionAmount)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes a new position projected from the origin position, along the given direction vector by the given float amount and stores the result in this vector. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b x}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The x component of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b y}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The y component of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b z}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The z component of the vector. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 3 floats. \par
}{
Definition at line {\b 13} of file {\b Vector3f.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CVector3f\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:CVector3f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CVector3f::CVector3f ()}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to zero. }}\par
{
Definition at line {\b 6} of file {\b Vector3f.cpp}.}\par
}
{\xe \v CVector3f\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:CVector3f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CVector3f::CVector3f (float fX, float fY, float fZ)}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to the ones given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fX} \cell }{X value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fY} \cell }{Y value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fZ} \cell }{Z value \cell }
{\row }
}
}{
Definition at line {\b 11} of file {\b Vector3f.cpp}.}\par
}
{\xe \v CVector3f\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:CVector3f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CVector3f::CVector3f (const {\b CVector3f} & vector)}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values from the given {\b CVector3f}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vector} \cell }{The vector to set this vector's values from \cell }
{\row }
}
}{
Definition at line {\b 18} of file {\b Vector3f.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getAngle\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:getAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector3f::getAngle (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the angle (in radians) between two UNIT VECTORS (Length of 1) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The angle in radians between the two vectors\par
}}No checking of vectors are unit length here. \par
 \par
}{
Definition at line {\b 136} of file {\b Vector3f.cpp}.}\par
}
{\xe \v getAsArray\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:getAsArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector3f::getAsArray (float * pArray) const}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns x, y and z as an array of floats. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pArray} \cell }{A pointer to an array of at least size 3 which will hold the component values of the vector\cell }
{\row }
}
Example: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 float} array[3];\par
vector.getAsArray(array);\par
}
 \par
}{
Definition at line {\b 157} of file {\b Vector3f.cpp}.}\par
}
{\xe \v getCross\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:getCross}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CVector3f::getCross (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the cross product between this vector and the one given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector to use in the calculation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The cross product\par
}}The cross product is a vector which is perpendicular to the two vectors it was calculated from. \par
 \par
}{
Definition at line {\b 127} of file {\b Vector3f.cpp}.}\par
}
{\xe \v getDistance\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:getDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector3f::getDistance (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes distance between this vector and the one given, treating each vector as a point in 3D space. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector, as a position in 3D space \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed distance between this and the given vector \par
}}}{
Definition at line {\b 141} of file {\b Vector3f.cpp}.}\par
}
{\xe \v getDistanceSquared\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:getDistanceSquared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector3f::getDistanceSquared (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes distance squared between this vector and the one given, treating each vector as a point in 3D space. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector, as a position in 3D space \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The computed squared distance between this and the given vector\par
}}This is faster than the {\b getDistance()} method, as no expensive square root is used. This is useful if you have many vectors/points and need to find the closest out of them all. After finding the closest, then you can squareroot the return value from this method or use {\b getDistance()} to obtain the true distance. \par
 \par
}{
Definition at line {\b 149} of file {\b Vector3f.cpp}.}\par
}
{\xe \v getDot\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:getDot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector3f::getDot (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the dot product (also known as inner product) between this vector and the one given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The dot product\par
}}Dot product is commutative (v1.getDot(v2) == v2.getDot(v1)) == always true. If returned dot product is... \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid \zwj0 vectors are pointing roughly in same direction (upto 90 degrees apart) \par
}= 0 vectors are perpendicular to one another (90 degrees) < 0 vectors are pointing in opposite directions (+90 degrees to 180 degrees) \par
 \par
}{
Definition at line {\b 122} of file {\b Vector3f.cpp}.}\par
}
{\xe \v getMagnitude\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:getMagnitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector3f::getMagnitude (void ) const}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes and returns the vector's magnitude. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The magnitude or length or norm of the vector\par
}}A vector's magnitude is also know as "the length" or norm of the vector. Uses sqrtf() so it's quite expensive. \par
}{
Definition at line {\b 98} of file {\b Vector3f.cpp}.}\par
}
{\xe \v isZero\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:isZero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CVector3f::isZero (void ) const}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines whether the vector is a zero vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the vector is a zero vector. \par
}}}{
Definition at line {\b 86} of file {\b Vector3f.cpp}.}\par
}
{\xe \v multiply\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector3f::multiply (float f)}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies this vector by the given scalar value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{The value to multiply the vector by\cell }
{\row }
}
Adjusts the magnitude of a vector, keeping the direction the same (Unless the scalar is negative, in which case the direction is reversed) \par
 \par
}{
Definition at line {\b 164} of file {\b Vector3f.cpp}.}\par
}
{\xe \v negate\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:negate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector3f::negate (void )}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Negates the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A negated vector has the same magnitude as before, however direction is reversed. \par
 \par
}{
Definition at line {\b 91} of file {\b Vector3f.cpp}.}\par
}
{\xe \v normalise\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:normalise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector3f::normalise (void )}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalises this vector so that it becomes a unit vector (Has a magnitude of 1) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses sqrtf() so it's quite expensive. If the vector has zero length(magnitude), then it is not modified. \par
}{
Definition at line {\b 107} of file {\b Vector3f.cpp}.}\par
}
{\xe \v operator!=\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CVector3f::operator!= (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for inequality. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if both vectors are not the same \par
}}}{
Definition at line {\b 69} of file {\b Vector3f.cpp}.}\par
}
{\xe \v operator*\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CVector3f} DCL::CVector3f::operator* (const float f) const}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{The float value to multiply each of this vector's components by \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Adjusts the magnitude of a vector, keeping the direction the same (Unless the scalar is negative, in which case the direction is reversed) Example: {\b CVector3f} vTwo(2.0f, 2.0f, 2.0f); {\b CVector3f} vOne = vTwo * 0.5f; \par
}{
Definition at line {\b 51} of file {\b Vector3f.cpp}.}\par
}
{\xe \v operator*=\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} & DCL::CVector3f::operator*= (const float f)}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{The scalar value which to multiply each of this vector's components by\cell }
{\row }
}
Adjusts the magnitude of a vector, keeping the direction the same (Unless the scalar is negative, in which case the direction is reversed) Example: {\b CVector3f} vOne(2.0f, 2.0f, 2.0f); vOne *= 0.5f; \par
 \par
}{
Definition at line {\b 56} of file {\b Vector3f.cpp}.}\par
}
{\xe \v operator+\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CVector3f::operator+ (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector addition is commutative. (v1 + v2 == v2 + v1) is always true. Triangle law of vector addition states that when two vectors are represented as two sides of the triangle with the order of magnitude and direction, then the third side of the triangle represents the magnitude and direction of the resultant vector. Example: {\b CVector3f} vOne(1.0f, 1.0f, 1.0f); {\b CVector3f} vTwo(2.0f, 2.0f, 2.0f); {\b CVector3f} vThree = vOne + vTwo; \par
}{
Definition at line {\b 25} of file {\b Vector3f.cpp}.}\par
}
{\xe \v operator+=\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} & DCL::CVector3f::operator+= (const {\b CVector3f} & vec)}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector addition is commutative. (v1 + v2 == v2 + v1) is always true. Triangle law of vector addition states that when two vectors are represented as two sides of the triangle with the order of magnitude and direction, then the third side of the triangle represents the magnitude and direction of the resultant vector. Example: {\b CVector3f} vOne(1.0f, 1.0f, 1.0f); {\b CVector3f} vThree(2.0f, 2.0f, 2.0f); vThree += vOne; \par
}{
Definition at line {\b 30} of file {\b Vector3f.cpp}.}\par
}
{\xe \v operator-\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} DCL::CVector3f::operator- (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector subtraction is not commutative. (v1 - v2 == v2 - v1) is only true when v1 is same as v2. Example: {\b CVector3f} vOne(1.0f, 1.0f, 1.0f); {\b CVector3f} vTwo(2.0f, 2.0f, 2.0f); {\b CVector3f} vMinusOne = vOne - vTwo; \par
}{
Definition at line {\b 38} of file {\b Vector3f.cpp}.}\par
}
{\xe \v operator-=\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector3f} & DCL::CVector3f::operator-= (const {\b CVector3f} & vec)}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector subtraction is not commutative. (v1 - v2 == v2 - v1) is only true when v1 is same as v2. Example: {\b CVector3f} vMinusOne(1.0f, 1.0f, 1.0f); {\b CVector3f} vTwo(2.0f, 2.0f, 2.0f); \par
}{
Definition at line {\b 43} of file {\b Vector3f.cpp}.}\par
}
{\xe \v operator==\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CVector3f::operator== (const {\b CVector3f} & vec) const}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for equality. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if both vectors are the same \par
}}}{
Definition at line {\b 64} of file {\b Vector3f.cpp}.}\par
}
{\xe \v project\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:project}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector3f::project (const {\b CVector3f} & vOriginPosition, const {\b CVector3f} & vDirection, float fProjectionAmount)}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes a new position projected from the origin position, along the given direction vector by the given float amount and stores the result in this vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vOriginPosition} \cell }{The position in 3D space where the origin is \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vDirection} \cell }{The direction from the origin to project from the origin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fProjectionAmount} \cell }{The amount along vDirection to move to the final computed position\cell }
{\row }
}
vDirection doesn't have to be normalized, but it'd probably make more sense if it is. Use negative fProjectionAmount values to compute the projected position in the opposite direction Example... {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CVector3f vOrigin(0.0f, 0.0f, 0.0f);\par
CVector3f vDirection(1.0f, 1.0f, 1.0f);\par
CVector3f vProjectedPosition;\par
vProjectedPosition.project(vOrigin, vDirection, 2.0f);  {\cf20 // Would result in vProjectedPosition being 2.0f, 2.0f, 2.0f}\par
}
 \par
}{
Definition at line {\b 171} of file {\b Vector3f.cpp}.}\par
}
{\xe \v set\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector3f::set (float fX, float fY, float fZ)}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element to the values given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fX} \cell }{The x component's new value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fY} \cell }{The y component's new value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fZ} \cell }{The z component's new value \cell }
{\row }
}
}{
Definition at line {\b 74} of file {\b Vector3f.cpp}.}\par
}
{\xe \v setZero\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:setZero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector3f::setZero (void )}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element within the vector's set to zero. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A zero vector is a special case. It does not have a direction, and it's magnitude is zero. \par
 \par
}{
Definition at line {\b 81} of file {\b Vector3f.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v x\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector3f::x}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The x component of the vector. }}\par
{
Definition at line {\b 233} of file {\b Vector3f.h}.}\par
}
{\xe \v y\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector3f::y}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The y component of the vector. }}\par
{
Definition at line {\b 234} of file {\b Vector3f.h}.}\par
}
{\xe \v z\:DCL::CVector3f}
{\xe \v DCL::CVector3f\:z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector3f::z}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The z component of the vector. }}\par
{
Definition at line {\b 235} of file {\b Vector3f.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Vector3f.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector3f.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CVector4f Class Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CVector4f}
{\xe \v DCL::CVector4f}
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 4 floats. }}\par
{
{\f2 #include <Vector4f.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector4f} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector4f} (float fX, float fY, float fZ, float fW)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to the ones given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector4f} {\b operator+} (const {\b CVector4f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector4f} & {\b operator+=} (const {\b CVector4f} &vec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector4f} {\b operator-} (const {\b CVector4f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector4f} & {\b operator-=} (const {\b CVector4f} &vec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CVector4f} {\b operator*} (const float f) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator*=} (const float f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CVector4f} {\b operator*} (const {\b CVector4f} &v) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by another vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b CVector4f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for equality. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b CVector4f} &vec) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for inequality. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (float fX, float fY, float fZ, float fW)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element to the values given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZero} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element within the vector's set to zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isZero} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines whether the vector is a zero vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b negate} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Negates the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getMagnitude} (void) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes and returns the vector's magnitude. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalise} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalises this vector so that it becomes a unit vector (Has a magnitude of 1) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getAsArray} (float *pArray) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns x, y,z and w as an array of floats. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b multiply} (float f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies this vector by the given scalar value. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b x}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The x component of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b y}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The y component of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b z}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The z component of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b w}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The w component of the vector. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 4 floats. \par
}{
Definition at line {\b 12} of file {\b Vector4f.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CVector4f\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:CVector4f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CVector4f::CVector4f ()}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to zero. }}\par
{
Definition at line {\b 6} of file {\b Vector4f.cpp}.}\par
}
{\xe \v CVector4f\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:CVector4f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DCL::CVector4f::CVector4f (float fX, float fY, float fZ, float fW)}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, sets all values to the ones given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fX} \cell }{X value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fY} \cell }{Y value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fZ} \cell }{Z value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fW} \cell }{W value \cell }
{\row }
}
}{
Definition at line {\b 11} of file {\b Vector4f.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getAsArray\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:getAsArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector4f::getAsArray (float * pArray) const}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns x, y,z and w as an array of floats. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pArray} \cell }{A pointer to an array of at least size 4 which will hold the component values of the vector\cell }
{\row }
}
Example: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 float} array[4];\par
vector.getAsArray(array);\par
}
 \par
}{
Definition at line {\b 133} of file {\b Vector4f.cpp}.}\par
}
{\xe \v getMagnitude\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:getMagnitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector4f::getMagnitude (void ) const}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes and returns the vector's magnitude. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The magnitude or length or norm of the vector\par
}}A vector's magnitude is also know as "the length" or norm of the vector. Uses sqrtf() so it's quite expensive. \par
}{
Definition at line {\b 106} of file {\b Vector4f.cpp}.}\par
}
{\xe \v isZero\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:isZero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CVector4f::isZero (void ) const}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines whether the vector is a zero vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the vector is a zero vector. \par
}}}{
Definition at line {\b 93} of file {\b Vector4f.cpp}.}\par
}
{\xe \v multiply\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector4f::multiply (float f)}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies this vector by the given scalar value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{The value to multiply the vector by\cell }
{\row }
}
Adjusts the magnitude of a vector, keeping the direction the same (Unless the scalar is negative, in which case the direction is reversed) \par
 \par
}{
Definition at line {\b 141} of file {\b Vector4f.cpp}.}\par
}
{\xe \v negate\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:negate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector4f::negate (void )}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Negates the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A negated vector has the same magnitude as before, however direction is reversed. \par
 \par
}{
Definition at line {\b 98} of file {\b Vector4f.cpp}.}\par
}
{\xe \v normalise\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:normalise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector4f::normalise (void )}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalises this vector so that it becomes a unit vector (Has a magnitude of 1) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses sqrtf() so it's quite expensive. If the vector has zero length(magnitude), then it is not modified. \par
}{
Definition at line {\b 116} of file {\b Vector4f.cpp}.}\par
}
{\xe \v operator!=\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CVector4f::operator!= (const {\b CVector4f} & vec) const}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for inequality. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if both vectors are not the same \par
}}}{
Definition at line {\b 75} of file {\b Vector4f.cpp}.}\par
}
{\xe \v operator*\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CVector4f} DCL::CVector4f::operator* (const {\b CVector4f} & v) const}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by another vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i v} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Example: {\b CVector4f} vOne(3.0f, 3.0f, 3.0f, 3.0f); {\b CVector4f} vTwo(2.0f, 2.0f, 2.0f, 2.0f); {\b CVector4f} vResult = vOne * vTwo; \par
}{
Definition at line {\b 60} of file {\b Vector4f.cpp}.}\par
}
{\xe \v operator*\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CVector4f} DCL::CVector4f::operator* (const float f) const}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{The float value to multiply each of this vector's components by \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Adjusts the magnitude of a vector, keeping the direction the same (Unless the scalar is negative, in which case the direction is reversed) Example: {\b CVector4f} vTwo(2.0f, 2.0f, 2.0f, 2.0f); {\b CVector4f} vOne = vTwo * 0.5f; \par
}{
Definition at line {\b 47} of file {\b Vector4f.cpp}.}\par
}
{\xe \v operator*=\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector4f::operator*= (const float f)}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplication by scalar. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{The scalar value which to multiply each of this vector's components by\cell }
{\row }
}
Adjusts the magnitude of a vector, keeping the direction the same (Unless the scalar is negative, in which case the direction is reversed) Example: {\b CVector4f} vOne(2.0f, 2.0f, 2.0f, 2.0f); vOne *= 0.5f; \par
 \par
}{
Definition at line {\b 52} of file {\b Vector4f.cpp}.}\par
}
{\xe \v operator+\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector4f} DCL::CVector4f::operator+ (const {\b CVector4f} & vec) const}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector addition is commutative. (v1 + v2 == v2 + v1) is always true. Triangle law of vector addition states that when two vectors are represented as two sides of the triangle with the order of magnitude and direction, then the third side of the triangle represents the magnitude and direction of the resultant vector. Example: {\b CVector4f} vOne(1.0f, 1.0f, 1.0f, 1.0f); {\b CVector4f} vTwo(2.0f, 2.0f, 2.0f, 2.0f); {\b CVector4f} vThree = vOne + vTwo; \par
}{
Definition at line {\b 19} of file {\b Vector4f.cpp}.}\par
}
{\xe \v operator+=\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector4f} & DCL::CVector4f::operator+= (const {\b CVector4f} & vec)}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Addition operator which adds two vectors together. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector addition is commutative. (v1 + v2 == v2 + v1) is always true. Triangle law of vector addition states that when two vectors are represented as two sides of the triangle with the order of magnitude and direction, then the third side of the triangle represents the magnitude and direction of the resultant vector. Example: {\b CVector4f} vOne(1.0f, 1.0f, 1.0f, 1.0f); {\b CVector4f} vThree(2.0f, 2.0f, 2.0f, 2.0f); vThree += vOne; \par
}{
Definition at line {\b 24} of file {\b Vector4f.cpp}.}\par
}
{\xe \v operator-\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector4f} DCL::CVector4f::operator- (const {\b CVector4f} & vec) const}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector subtraction is not commutative. (v1 - v2 == v2 - v1) is only true when v1 is same as v2. Example: {\b CVector4f} vOne(1.0f, 1.0f, 1.0f, 1.0f); {\b CVector4f} vTwo(2.0f, 2.0f, 2.0f, 2.0f); {\b CVector4f} vMinusOne = vOne - vTwo; \par
}{
Definition at line {\b 33} of file {\b Vector4f.cpp}.}\par
}
{\xe \v operator-=\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector4f} & DCL::CVector4f::operator-= (const {\b CVector4f} & vec)}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtraction operator. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector in the operation \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result\par
}}Vector subtraction is not commutative. (v1 - v2 == v2 - v1) is only true when v1 is same as v2. Example: {\b CVector4f} vMinusOne(1.0f, 1.0f, 1.0f, 1.0f); {\b CVector4f} vTwo(2.0f, 2.0f, 2.0f, 2.0f); vMinusOne -= vTwo; \par
}{
Definition at line {\b 38} of file {\b Vector4f.cpp}.}\par
}
{\xe \v operator==\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCL::CVector4f::operator== (const {\b CVector4f} & vec) const}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for equality. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{The other vector \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if both vectors are the same \par
}}}{
Definition at line {\b 70} of file {\b Vector4f.cpp}.}\par
}
{\xe \v set\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector4f::set (float fX, float fY, float fZ, float fW)}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element to the values given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fX} \cell }{The x component's new value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fY} \cell }{The y component's new value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fZ} \cell }{The z component's new value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fW} \cell }{The w component's new value \cell }
{\row }
}
}{
Definition at line {\b 80} of file {\b Vector4f.cpp}.}\par
}
{\xe \v setZero\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:setZero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCL::CVector4f::setZero (void )}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets each element within the vector's set to zero. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A zero vector is a special case. It does not have a direction, and it's magnitude is zero. \par
 \par
}{
Definition at line {\b 88} of file {\b Vector4f.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v w\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:w}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector4f::w}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The w component of the vector. }}\par
{
Definition at line {\b 182} of file {\b Vector4f.h}.}\par
}
{\xe \v x\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector4f::x}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The x component of the vector. }}\par
{
Definition at line {\b 179} of file {\b Vector4f.h}.}\par
}
{\xe \v y\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector4f::y}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The y component of the vector. }}\par
{
Definition at line {\b 180} of file {\b Vector4f.h}.}\par
}
{\xe \v z\:DCL::CVector4f}
{\xe \v DCL::CVector4f\:z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::CVector4f::z}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The z component of the vector. }}\par
{
Definition at line {\b 181} of file {\b Vector4f.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/{\b Vector4f.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector4f.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::SMemInfo Struct Reference\par \pard\plain 
{\tc\tcl2 \v DCL::SMemInfo}
{\xe \v DCL::SMemInfo}
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds system memory information which is set by {\b getMemInfo()} }}\par
{
{\f2 #include <Utilities.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SMemOS}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds OS memory usage. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SMemProcess}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds process memory usage. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SMemProcess} {\b proc}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SMemOS} {\b os}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operating system information. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds system memory information which is set by {\b getMemInfo()} \par
}{
Definition at line {\b 265} of file {\b Utilities.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v os\:DCL::SMemInfo}
{\xe \v DCL::SMemInfo\:os}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SMemOS} DCL::SMemInfo::os}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operating system information. }}\par
{
Definition at line {\b 301} of file {\b Utilities.h}.}\par
}
{\xe \v proc\:DCL::SMemInfo}
{\xe \v DCL::SMemInfo\:proc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SMemProcess} DCL::SMemInfo::proc}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process information. }}\par
{
Definition at line {\b 300} of file {\b Utilities.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Utilities.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::SMemInfo::SMemOS Struct Reference\par \pard\plain 
{\tc\tcl2 \v DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS}
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds OS memory usage. }}\par
{
{\f2 #include <Utilities.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iCommitTotal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of pages committed by the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iCommitLimit}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current maximum number of page commits that can be performed by the system. This number can change if memory is added or deleted, or if pagefiles have grown, shrunk, or been added. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iCommitPeak}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum number of page commit totals that have occurred since the last reboot. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iPhysicalTotal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of physical memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iPhysicalAvailable}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Amount, in pages, of physical memory available to user processes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iSystemCache}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of system cache memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iKernelTotal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of the sum of the paged and nonpaged kernel pools. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iKernelPaged}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of the paged kernel pool. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iKernelNonpaged}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of the nonpaged kernel pool. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iPageSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size, in bytes, of a page. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iHandleCount}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of open handles. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iProcessCount}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of processes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iThreadCount}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of threads. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds OS memory usage. \par
}{
Definition at line {\b 283} of file {\b Utilities.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v iCommitLimit\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iCommitLimit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iCommitLimit}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current maximum number of page commits that can be performed by the system. This number can change if memory is added or deleted, or if pagefiles have grown, shrunk, or been added. }}\par
{
Definition at line {\b 286} of file {\b Utilities.h}.}\par
}
{\xe \v iCommitPeak\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iCommitPeak}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iCommitPeak}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum number of page commit totals that have occurred since the last reboot. }}\par
{
Definition at line {\b 287} of file {\b Utilities.h}.}\par
}
{\xe \v iCommitTotal\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iCommitTotal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iCommitTotal}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of pages committed by the system. }}\par
{
Definition at line {\b 285} of file {\b Utilities.h}.}\par
}
{\xe \v iHandleCount\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iHandleCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iHandleCount}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of open handles. }}\par
{
Definition at line {\b 295} of file {\b Utilities.h}.}\par
}
{\xe \v iKernelNonpaged\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iKernelNonpaged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iKernelNonpaged}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of the nonpaged kernel pool. }}\par
{
Definition at line {\b 293} of file {\b Utilities.h}.}\par
}
{\xe \v iKernelPaged\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iKernelPaged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iKernelPaged}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of the paged kernel pool. }}\par
{
Definition at line {\b 292} of file {\b Utilities.h}.}\par
}
{\xe \v iKernelTotal\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iKernelTotal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iKernelTotal}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of the sum of the paged and nonpaged kernel pools. }}\par
{
Definition at line {\b 291} of file {\b Utilities.h}.}\par
}
{\xe \v iPageSize\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iPageSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iPageSize}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size, in bytes, of a page. }}\par
{
Definition at line {\b 294} of file {\b Utilities.h}.}\par
}
{\xe \v iPhysicalAvailable\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iPhysicalAvailable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iPhysicalAvailable}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Amount, in pages, of physical memory available to user processes. }}\par
{
Definition at line {\b 289} of file {\b Utilities.h}.}\par
}
{\xe \v iPhysicalTotal\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iPhysicalTotal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iPhysicalTotal}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of physical memory. }}\par
{
Definition at line {\b 288} of file {\b Utilities.h}.}\par
}
{\xe \v iProcessCount\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iProcessCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iProcessCount}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of processes. }}\par
{
Definition at line {\b 296} of file {\b Utilities.h}.}\par
}
{\xe \v iSystemCache\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iSystemCache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iSystemCache}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount, in pages, of system cache memory. }}\par
{
Definition at line {\b 290} of file {\b Utilities.h}.}\par
}
{\xe \v iThreadCount\:DCL::SMemInfo::SMemOS}
{\xe \v DCL::SMemInfo::SMemOS\:iThreadCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemOS::iThreadCount}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of threads. }}\par
{
Definition at line {\b 297} of file {\b Utilities.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Utilities.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::SMemInfo::SMemProcess Struct Reference\par \pard\plain 
{\tc\tcl2 \v DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess}
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds process memory usage. }}\par
{
{\f2 #include <Utilities.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iPageFaultCount}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of page faults. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iPeakWorkingSetSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The peak working set size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iWorkingSetSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current working set size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iQuotaPeakPagedPoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The peak paged pool usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iQuotaPagedPoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current paged pool usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iQuotaPeakNonPagedPoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The peak nonpaged pool usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iQuotaNonPagedPoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current nonpaged pool usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iPagefileUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current pagefile usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iPeakPagefileUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The peak pagefile usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b iPrivateUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Same as PagefileUsage. The Commit Charge value in bytes for this process. Commit Charge is the total amount of private memory that the memory manager has committed for a running process. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds process memory usage. \par
}{
Definition at line {\b 268} of file {\b Utilities.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v iPageFaultCount\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iPageFaultCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iPageFaultCount}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of page faults. }}\par
{
Definition at line {\b 270} of file {\b Utilities.h}.}\par
}
{\xe \v iPagefileUsage\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iPagefileUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iPagefileUsage}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current pagefile usage. }}\par
{
Definition at line {\b 277} of file {\b Utilities.h}.}\par
}
{\xe \v iPeakPagefileUsage\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iPeakPagefileUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iPeakPagefileUsage}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The peak pagefile usage. }}\par
{
Definition at line {\b 278} of file {\b Utilities.h}.}\par
}
{\xe \v iPeakWorkingSetSize\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iPeakWorkingSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iPeakWorkingSetSize}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The peak working set size. }}\par
{
Definition at line {\b 271} of file {\b Utilities.h}.}\par
}
{\xe \v iPrivateUsage\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iPrivateUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iPrivateUsage}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Same as PagefileUsage. The Commit Charge value in bytes for this process. Commit Charge is the total amount of private memory that the memory manager has committed for a running process. }}\par
{
Definition at line {\b 279} of file {\b Utilities.h}.}\par
}
{\xe \v iQuotaNonPagedPoolUsage\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iQuotaNonPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iQuotaNonPagedPoolUsage}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current nonpaged pool usage. }}\par
{
Definition at line {\b 276} of file {\b Utilities.h}.}\par
}
{\xe \v iQuotaPagedPoolUsage\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iQuotaPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iQuotaPagedPoolUsage}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current paged pool usage. }}\par
{
Definition at line {\b 274} of file {\b Utilities.h}.}\par
}
{\xe \v iQuotaPeakNonPagedPoolUsage\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iQuotaPeakNonPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iQuotaPeakNonPagedPoolUsage}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The peak nonpaged pool usage. }}\par
{
Definition at line {\b 275} of file {\b Utilities.h}.}\par
}
{\xe \v iQuotaPeakPagedPoolUsage\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iQuotaPeakPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iQuotaPeakPagedPoolUsage}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The peak paged pool usage. }}\par
{
Definition at line {\b 273} of file {\b Utilities.h}.}\par
}
{\xe \v iWorkingSetSize\:DCL::SMemInfo::SMemProcess}
{\xe \v DCL::SMemInfo::SMemProcess\:iWorkingSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int DCL::SMemInfo::SMemProcess::iWorkingSetSize}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current working set size. }}\par
{
Definition at line {\b 272} of file {\b Utilities.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Utilities.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::SProfilerResults Struct Reference\par \pard\plain 
{\tc\tcl2 \v DCL::SProfilerResults}
{\xe \v DCL::SProfilerResults}
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used by {\b CProfiler} class to return a vector of this struct containing the profiler's results. }}\par
{
{\f2 #include <Profiler.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b strSectionName}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The section's name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dAccumulatedTimeSeconds}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The total accumulated time in seconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b fPercentageOfMain}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The percentage of the "main" section that this section takes up. \par
 }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used by {\b CProfiler} class to return a vector of this struct containing the profiler's results. \par
}{
Definition at line {\b 17} of file {\b Profiler.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dAccumulatedTimeSeconds\:DCL::SProfilerResults}
{\xe \v DCL::SProfilerResults\:dAccumulatedTimeSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DCL::SProfilerResults::dAccumulatedTimeSeconds}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The total accumulated time in seconds. }}\par
{
Definition at line {\b 20} of file {\b Profiler.h}.}\par
}
{\xe \v fPercentageOfMain\:DCL::SProfilerResults}
{\xe \v DCL::SProfilerResults\:fPercentageOfMain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float DCL::SProfilerResults::fPercentageOfMain}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The percentage of the "main" section that this section takes up. \par
 }}\par
{
Definition at line {\b 21} of file {\b Profiler.h}.}\par
}
{\xe \v strSectionName\:DCL::SProfilerResults}
{\xe \v DCL::SProfilerResults\:strSectionName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string DCL::SProfilerResults::strSectionName}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The section's name. }}\par
{
Definition at line {\b 19} of file {\b Profiler.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Profiler.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CProfiler::SSection Struct Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CProfiler::SSection}
{\xe \v DCL::CProfiler::SSection}
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Members needed by each code section. }}\par
{
{\f2 #include <Profiler.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerMinimal} {\b timer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimal timer object used to time this section. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dAccumulatedTimeInSeconds}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total accumulated time since call or calls between begin and end. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iBeginCalledCount}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times {\b begin()} has been called for this named section since {\b begin()} was called on "main" section. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Members needed by each code section. \par
}{
Definition at line {\b 101} of file {\b Profiler.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dAccumulatedTimeInSeconds\:DCL::CProfiler::SSection}
{\xe \v DCL::CProfiler::SSection\:dAccumulatedTimeInSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DCL::CProfiler::SSection::dAccumulatedTimeInSeconds}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total accumulated time since call or calls between begin and end. }}\par
{
Definition at line {\b 104} of file {\b Profiler.h}.}\par
}
{\xe \v iBeginCalledCount\:DCL::CProfiler::SSection}
{\xe \v DCL::CProfiler::SSection\:iBeginCalledCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DCL::CProfiler::SSection::iBeginCalledCount}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times {\b begin()} has been called for this named section since {\b begin()} was called on "main" section. }}\par
{
Definition at line {\b 105} of file {\b Profiler.h}.}\par
}
{\xe \v timer\:DCL::CProfiler::SSection}
{\xe \v DCL::CProfiler::SSection\:timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTimerMinimal} DCL::CProfiler::SSection::timer}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimal timer object used to time this section. }}\par
{
Definition at line {\b 103} of file {\b Profiler.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/{\b Profiler.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DCL::CImageAtlasDetails::STexCoords Struct Reference\par \pard\plain 
{\tc\tcl2 \v DCL::CImageAtlasDetails::STexCoords}
{\xe \v DCL::CImageAtlasDetails::STexCoords}
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds texture coordinates for each of the four corners of an image. }}\par
{
{\f2 #include <ImageAtlas.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b vTL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Top left texture coordinate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b vTR}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Top right texture coordinate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b vBL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bottom left texture coordinate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVector2f} {\b vBR}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bottom right texture coordinate. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds texture coordinates for each of the four corners of an image. \par
}{
Definition at line {\b 21} of file {\b ImageAtlas.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v vBL\:DCL::CImageAtlasDetails::STexCoords}
{\xe \v DCL::CImageAtlasDetails::STexCoords\:vBL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CImageAtlasDetails::STexCoords::vBL}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bottom left texture coordinate. }}\par
{
Definition at line {\b 25} of file {\b ImageAtlas.h}.}\par
}
{\xe \v vBR\:DCL::CImageAtlasDetails::STexCoords}
{\xe \v DCL::CImageAtlasDetails::STexCoords\:vBR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CImageAtlasDetails::STexCoords::vBR}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bottom right texture coordinate. }}\par
{
Definition at line {\b 26} of file {\b ImageAtlas.h}.}\par
}
{\xe \v vTL\:DCL::CImageAtlasDetails::STexCoords}
{\xe \v DCL::CImageAtlasDetails::STexCoords\:vTL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CImageAtlasDetails::STexCoords::vTL}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Top left texture coordinate. }}\par
{
Definition at line {\b 23} of file {\b ImageAtlas.h}.}\par
}
{\xe \v vTR\:DCL::CImageAtlasDetails::STexCoords}
{\xe \v DCL::CImageAtlasDetails::STexCoords\:vTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CVector2f} DCL::CImageAtlasDetails::STexCoords::vTR}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Top right texture coordinate. }}\par
{
Definition at line {\b 24} of file {\b ImageAtlas.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/{\b ImageAtlas.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FiniteStateMachine.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/FiniteStateMachine.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/FiniteStateMachine.cpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "finiteStateMachine.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     CFiniteStateMachine::~CFiniteStateMachine()\par
00007     \{\par
00008         removeAllStates();\par
00009     \}\par
00010 \par
00011     {\cf18 void} CFiniteStateMachine::update({\cf18 void})\par
00012     \{\par
00013         {\cf20 // Find currently set state}\par
00014         std::map<std::string, CFiniteStateBase*>::iterator it = _mmapStates.find(_mstrCurrentState);\par
00015         {\cf20 // _mstrCurrentState might not be set, aka empty}\par
00016         {\cf19 if} (it != _mmapStates.end())\par
00017             it->second->onActive({\cf17 this});\par
00018     \}\par
00019 \par
00020     {\cf18 void} CFiniteStateMachine::switchToState({\cf17 const} std::string& strStateName)\par
00021     \{\par
00022         {\cf20 // Find named state}\par
00023         std::map<std::string, CFiniteStateBase*>::iterator it = _mmapStates.find(strStateName);\par
00024         ThrowIfTrue(it == _mmapStates.end(), {\cf22 "CFiniteStateMachine::switchToState(\\""} + strStateName + {\cf22 "\\") failed. State name doesn't exist."});\par
00025 \par
00026         {\cf20 // Find currently set state}\par
00027         std::map<std::string, CFiniteStateBase*>::iterator itCurrentState = _mmapStates.find(_mstrCurrentState);\par
00028 \par
00029         {\cf20 // If the states are the same, do nothing.}\par
00030         {\cf19 if} (it == itCurrentState)\par
00031         \{\par
00032             {\cf19 return};\par
00033         \}\par
00034 \par
00035         {\cf20 // _mstrCurrentState might not be set, aka empty}\par
00036         {\cf19 if} (itCurrentState != _mmapStates.end())\par
00037             itCurrentState->second->onExit();   {\cf20 // Exit current state}\par
00038 \par
00039         {\cf20 // Enter new state}\par
00040         it->second->onEnter();\par
00041 \par
00042         {\cf20 // Set new state to currently set state}\par
00043         _mstrCurrentState = strStateName;\par
00044     \}\par
00045 \par
00046     {\cf18 void} CFiniteStateMachine::addState({\cf17 const} std::string& strStateName, CFiniteStateBase* pState)\par
00047     \{\par
00048         std::map<std::string, CFiniteStateBase*>::iterator it = _mmapStates.find(strStateName);\par
00049         ThrowIfTrue(it != _mmapStates.end(), {\cf22 "CFiniteStateMachine::addState(\\""} + strStateName + {\cf22 "\\") failed. State name already exists."});\par
00050         ThrowIfFalse(pState, {\cf22 "CFiniteStateMachine::addState(\\""} + strStateName + {\cf22 "\\") failed. The given state pointer was 0."});\par
00051         _mmapStates[strStateName] = pState;\par
00052     \}\par
00053 \par
00054     {\cf18 void} CFiniteStateMachine::removeState({\cf17 const} std::string& strStateName)\par
00055     \{\par
00056         std::map<std::string, CFiniteStateBase*>::iterator it = _mmapStates.find(strStateName);\par
00057         ThrowIfTrue(it == _mmapStates.end(), {\cf22 "CFiniteStateMachine::removeState(\\""} + strStateName + {\cf22 "\\") failed. State name doesn't exist."});\par
00058 \par
00059         {\cf20 // If this is the currently set state, call it's onExit method}\par
00060         {\cf19 if} (_mstrCurrentState == it->first)\par
00061         \{\par
00062             it->second->onExit();\par
00063             _mstrCurrentState.clear();\par
00064         \}\par
00065 \par
00066         {\cf17 delete} it->second;\par
00067         _mmapStates.erase(it);\par
00068     \}\par
00069 \par
00070     {\cf18 bool} CFiniteStateMachine::getStateExists({\cf17 const} std::string& strStateName)\par
00071     \{\par
00072         std::map<std::string, CFiniteStateBase*>::iterator it = _mmapStates.find(strStateName);\par
00073         {\cf19 return} (it != _mmapStates.end());\par
00074     \}\par
00075 \par
00076     {\cf18 void} CFiniteStateMachine::removeAllStates({\cf18 void})\par
00077     \{\par
00078         std::map<std::string, CFiniteStateBase*>::iterator it = _mmapStates.begin();\par
00079         {\cf19 while} (it != _mmapStates.end())\par
00080         \{\par
00081             {\cf20 // If this is the currently set state, call it's onExit method}\par
00082             {\cf19 if} (_mstrCurrentState == it->first)\par
00083             \{\par
00084                 it->second->onExit();\par
00085                 _mstrCurrentState.clear();\par
00086             \}\par
00087 \par
00088             {\cf17 delete} it->second;\par
00089             _mmapStates.erase(it);\par
00090             it = _mmapStates.begin();\par
00091         \}\par
00092         _mmapStates.clear();\par
00093     \}\par
00094 \par
00095     {\cf18 int} CFiniteStateMachine::getNumberStates({\cf18 void})\par
00096     \{\par
00097         {\cf19 return} ({\cf18 int})_mmapStates.size();\par
00098     \}\par
00099 \par
00100     CFiniteStateBase* CFiniteStateMachine::getState({\cf18 unsigned} {\cf18 int} uiIndex)\par
00101     \{\par
00102         ThrowIfTrue(uiIndex >= ({\cf18 unsigned} {\cf18 int})_mmapStates.size(), {\cf22 "CFiniteStateMachine::getState() failed. Given invalid index."});\par
00103         std::map<std::string, CFiniteStateBase*>::iterator it = _mmapStates.begin();\par
00104         {\cf18 unsigned} {\cf18 int} uiCount = 0;\par
00105         {\cf19 while} (uiCount < uiIndex)\par
00106         \{\par
00107             uiCount++;\par
00108             it++;\par
00109         \}\par
00110         {\cf19 return} it->second;\par
00111     \}\par
00112 \par
00113     CFiniteStateBase* CFiniteStateMachine::getState({\cf17 const} std::string strStateName)\par
00114     \{\par
00115         std::map<std::string, CFiniteStateBase*>::iterator it = _mmapStates.find(strStateName);\par
00116         ThrowIfTrue(it == _mmapStates.end(), {\cf22 "CFiniteStateMachine::getState() failed. "} + strStateName + {\cf22 " couldn't be found."});\par
00117         {\cf19 return} it->second;\par
00118     \}\par
00119 \par
00120 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/FiniteStateMachine.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/FiniteStateMachine.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/FiniteStateMachine.h}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains finite state machine stuff. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <map>}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CFiniteStateBase}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finite state base class with which to derive our FSM state classes from for use with the {\b CFiniteStateMachine} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CFiniteStateMachine}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a generic finite state machine used alongside classes derived from {\b CFiniteStateBase}. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains finite state machine stuff. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b FiniteStateMachine.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FiniteStateMachine.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/FiniteStateMachine.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/FiniteStateMachine.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef FINITESTATEMACHINE_H}\par
00007 {\cf21 #define FINITESTATEMACHINE_H}\par
00008 \par
00009 {\cf21 #include <map>}\par
00010 {\cf21 #include <string>}\par
00011 \par
00012 {\cf17 namespace }DCL\par
00013 \{\par
00014     {\cf17 class }CFiniteStateMachine;\par
00015 \par
00020     {\cf17 class }CFiniteStateBase\par
00021     \{\par
00022     {\cf17 public}:\par
00024         {\cf17 virtual} {\cf18 void} onEnter({\cf18 void}) = 0;\par
00025 \par
00027         {\cf17 virtual} {\cf18 void} onExit({\cf18 void}) = 0;\par
00028 \par
00033         {\cf17 virtual} {\cf18 void} onActive(CFiniteStateMachine* pFSM) = 0;\par
00034     \};\par
00035 \par
00076     {\cf17 class }CFiniteStateMachine\par
00077     \{\par
00078     {\cf17 public}:\par
00079 \par
00083         ~CFiniteStateMachine();\par
00084 \par
00088         {\cf18 void} update({\cf18 void});\par
00089 \par
00097         {\cf18 void} switchToState({\cf17 const} std::string& strStateName);\par
00098 \par
00109         {\cf18 void} addState({\cf17 const} std::string& strStateName, CFiniteStateBase* pState);\par
00110 \par
00117         {\cf18 void} removeState({\cf17 const} std::string& strStateName);\par
00118 \par
00123         {\cf18 bool} getStateExists({\cf17 const} std::string& strStateName);\par
00124 \par
00128         {\cf18 void} removeAllStates({\cf18 void});\par
00129 \par
00133         {\cf18 int} getNumberStates({\cf18 void});\par
00134 \par
00141         CFiniteStateBase* getState({\cf18 unsigned} {\cf18 int} uiIndex);\par
00142 \par
00149         CFiniteStateBase* getState({\cf17 const} std::string strStateName);\par
00150     {\cf17 private}:\par
00151         std::string _mstrCurrentState;                          \par
00152         std::map<std::string, CFiniteStateBase*> _mmapStates;   \par
00153     \};\par
00154 \par
00155 \}   {\cf20 // namespace DCL}\par
00156 \par
00157 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GeneticAlgorithm.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/GeneticAlgorithm.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/GeneticAlgorithm.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "GeneticAlgorithm.h"}\par
00002 {\cf21 #include "../Core/Utilities.h"}\par
00003 {\cf21 #include "../Core/Exceptions.h"}\par
00004 \par
00005 {\cf21 #include <algorithm>}\par
00006 \par
00007 {\cf17 namespace }DCL\par
00008 \{\par
00009     CGenome::CGenome()\par
00010     \{\par
00011         dFitness = 0;\par
00012     \}\par
00013 \par
00014     CGenome::CGenome(std::vector<double>& vecNeuralNetworkWeights, {\cf18 double} dNetworkFitness)\par
00015     \{\par
00016         dFitness = dNetworkFitness;\par
00017         vecWeights = vecNeuralNetworkWeights;\par
00018     \}\par
00019 \par
00020     CGenome::CGenome({\cf17 const} CNeuralNetworkFeedForward& neuralNetwork, {\cf18 double} dNetworkFitness)\par
00021     \{\par
00022         dFitness = dNetworkFitness;\par
00023         vecWeights = neuralNetwork.getNeuronWeights();\par
00024     \}\par
00025 \par
00026     {\cf18 void} CGenome::set(std::vector<double>& vecNeuralNetworkWeights, {\cf18 double} dNetworkFitness)\par
00027     \{\par
00028         dFitness = dNetworkFitness;\par
00029         vecWeights = vecNeuralNetworkWeights;\par
00030     \}\par
00031 \par
00032     {\cf18 void} CGenome::set({\cf17 const} CNeuralNetworkFeedForward& neuralNetwork, {\cf18 double} dNetworkFitness)\par
00033     \{\par
00034         dFitness = dNetworkFitness;\par
00035         vecWeights = neuralNetwork.getNeuronWeights();\par
00036     \}\par
00037 \par
00038     CGenome CGeneticsTraining::rouletteWheelSelection({\cf17 const} std::vector<CGenome>& vecPopulation){\cf17  const}\par
00039 {\cf17     }\{\par
00040         {\cf20 // Make sure the vector contains stuff}\par
00041         ThrowIfFalse(vecPopulation.size(), {\cf22 "CGeneticsTraining::rouletteWheelSelection() failed as the given CGenome vector was empty."});\par
00042 \par
00043         {\cf20 // Compute total fitness of all the elements in the vector}\par
00044         {\cf18 double} dTotalFitness = 0;\par
00045         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vecPopulation.size(); ui++)\par
00046         \{\par
00047             dTotalFitness += vecPopulation[ui].dFitness;\par
00048         \}\par
00049 \par
00050         {\cf20 // Now compute a random value between 0 and dTotalFitness.}\par
00051         {\cf20 // Think of this as a portion of the entire wheel.}\par
00052         {\cf18 double} dPortion = randDouble() * dTotalFitness;\par
00053 \par
00054         {\cf20 // Now go through the vector of genomes, adding their fitness scores as we go}\par
00055         {\cf20 // and if the sub total is greater than the above dTotalFitness,}\par
00056         {\cf20 // we've found our index.}\par
00057         {\cf18 double} dSubTotal = 0;\par
00058         CGenome selectedGenome = vecPopulation[0];\par
00059         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vecPopulation.size(); ui++)\par
00060         \{\par
00061             dSubTotal += vecPopulation[ui].dFitness;\par
00062             {\cf19 if} (dSubTotal > dPortion)\par
00063             \{\par
00064                 selectedGenome = vecPopulation[ui];\par
00065                 {\cf19 break};\par
00066             \}\par
00067         \}\par
00068         {\cf19 return} selectedGenome;\par
00069     \}\par
00070 \par
00071     {\cf18 void} CGeneticsTraining::computeFitness({\cf17 const} std::vector<double>& vecPopulationFitness, {\cf18 double}& dWorstFitness, {\cf18 double}& dAverageFitness, {\cf18 double}& dBestFitness, {\cf18 double}& dTotalFitness){\cf17  const}\par
00072 {\cf17     }\{\par
00073         dWorstFitness = 999999999999999;\par
00074         dBestFitness = -999999999999999;\par
00075         dTotalFitness = 0;\par
00076         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vecPopulationFitness.size(); ui++)\par
00077         \{\par
00078             {\cf20 // Total fitness}\par
00079             dTotalFitness += vecPopulationFitness[ui];\par
00080 \par
00081             {\cf20 // Worst fitness}\par
00082             {\cf19 if} (dWorstFitness > vecPopulationFitness[ui])\par
00083                 dWorstFitness = vecPopulationFitness[ui];\par
00084 \par
00085             {\cf20 // Best fitness}\par
00086             {\cf19 if} (dBestFitness < vecPopulationFitness[ui])\par
00087                 dBestFitness = vecPopulationFitness[ui];\par
00088         \}\par
00089 \par
00090         dAverageFitness = 0;\par
00091         {\cf19 if} (vecPopulationFitness.size())\par
00092             dAverageFitness = dTotalFitness / vecPopulationFitness.size();\par
00093     \}\par
00094 \par
00095     {\cf18 void} CGeneticsTraining::computeFitness({\cf17 const} std::vector<CGenome>& vecPopulation, {\cf18 double}& dWorstFitness, {\cf18 double}& dAverageFitness, {\cf18 double}& dBestFitness, {\cf18 double}& dTotalFitness){\cf17  const}\par
00096 {\cf17     }\{\par
00097         dWorstFitness = 999999999999999;\par
00098         dBestFitness = -999999999999999;\par
00099         dTotalFitness = 0;\par
00100         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vecPopulation.size(); ui++)\par
00101         \{\par
00102             {\cf20 // Total fitness}\par
00103             dTotalFitness += vecPopulation[ui].dFitness;\par
00104 \par
00105             {\cf20 // Worst fitness}\par
00106             {\cf19 if} (dWorstFitness > vecPopulation[ui].dFitness)\par
00107                 dWorstFitness = vecPopulation[ui].dFitness;\par
00108 \par
00109             {\cf20 // Best fitness}\par
00110             {\cf19 if} (dBestFitness < vecPopulation[ui].dFitness)\par
00111                 dBestFitness = vecPopulation[ui].dFitness;\par
00112         \}\par
00113 \par
00114         dAverageFitness = 0;\par
00115         {\cf19 if} (vecPopulation.size())\par
00116             dAverageFitness = dTotalFitness / vecPopulation.size();\par
00117     \}\par
00118 \par
00119     {\cf18 void} CGeneticsTraining::crossover(\par
00120         std::vector<double>& vecMumWeights,\par
00121         std::vector<double>& vecDadWeights,\par
00122         std::vector<double>& vecChildAWeights,\par
00123         std::vector<double>& vecChildBWeights,\par
00124         {\cf18 double} dCrossoverRate){\cf17  const}\par
00125 {\cf17     }\{\par
00126         {\cf20 // Error checking to make sure vector sizes are equal}\par
00127         {\cf19 if} (vecMumWeights.size() != vecDadWeights.size())\par
00128             ThrowIfTrue(1, {\cf22 "CGeneticsTraining::crossover() failed. The passed parent vectors are not the same size."});\par
00129 \par
00130         {\cf20 // Determine whether we should perform the crossover...}\par
00131         {\cf20 // First by calculating a random value an determining whether it is below the given crossover rate.}\par
00132         {\cf20 // And second, if both parents are the same}\par
00133         {\cf19 if} (randDouble() > dCrossoverRate || vecMumWeights == vecDadWeights)\par
00134         \{\par
00135             vecChildAWeights = vecMumWeights;\par
00136             vecChildBWeights = vecDadWeights;\par
00137             {\cf19 return};\par
00138         \}\par
00139 \par
00140         {\cf20 // If we get here, mum and dad are different and a crossover is to be performed.}\par
00141 \par
00142         {\cf20 // Determine a random cross over point}\par
00143         {\cf18 int} iCrossoverPoint = randInt(0, ({\cf18 int})vecMumWeights.size() - 1);\par
00144 \par
00145         {\cf20 // Clear the child weights}\par
00146         vecChildAWeights.clear();\par
00147         vecChildBWeights.clear();\par
00148 \par
00149         {\cf20 // Give the children weights from mum and dad, before the crossover point}\par
00150         {\cf19 for} ({\cf18 int} i = 0; i < iCrossoverPoint; i++)\par
00151         \{\par
00152             {\cf20 // Child A gets all of mum's weights, before the crossover point}\par
00153             vecChildAWeights.push_back(vecMumWeights[i]);\par
00154 \par
00155             {\cf20 // The other child, all of dad's, before the crossover point}\par
00156             vecChildBWeights.push_back(vecDadWeights[i]);\par
00157         \}\par
00158         {\cf20 // Give the children weights from dad and mum, after the crossover point}\par
00159         {\cf19 for} ({\cf18 int} i = iCrossoverPoint; i < vecMumWeights.size(); i++)\par
00160         \{\par
00161             {\cf20 // Child A gets all of dad's weights, after the crossover point}\par
00162             vecChildAWeights.push_back(vecDadWeights[i]);\par
00163 \par
00164             {\cf20 // The other child, all of mum's, after the crossover point}\par
00165             vecChildBWeights.push_back(vecMumWeights[i]);\par
00166         \}\par
00167     \}\par
00168 \par
00169     {\cf18 void} CGeneticsTraining::crossoverBetweenNeurons(\par
00170         std::vector<double>& vecMumWeights,\par
00171         std::vector<double>& vecDadWeights,\par
00172         std::vector<double>& vecChildAWeights,\par
00173         std::vector<double>& vecChildBWeights,\par
00174         {\cf17 const} std::vector<int>& vecSplitPoints,\par
00175         {\cf18 double} dCrossoverRate){\cf17  const}\par
00176 {\cf17     }\{\par
00177         {\cf20 // Error checking to make sure vector sizes are equal}\par
00178         {\cf19 if} (vecMumWeights.size() != vecDadWeights.size())\par
00179             ThrowIfTrue(1, {\cf22 "CGeneticsTraining::crossoverBetweenNeurons() failed. The passed parent vectors are not the same size."});\par
00180         {\cf20 // Error checking to make sure the given split points vector is of adequate size}\par
00181         ThrowIfTrue(vecSplitPoints.size() < 2, {\cf22 "CGeneticsTraining::crossoverBetweenNeurons() failed. The passed vecSplitPoints vector's size is too small. Must be at least 2."});\par
00182 \par
00183         {\cf20 // Determine whether we should perform the crossover...}\par
00184         {\cf20 // First by calculating a random value an determining whether it is below the given crossover rate.}\par
00185         {\cf20 // And second, if both parents are the same}\par
00186         {\cf19 if} (randDouble() > dCrossoverRate || vecMumWeights == vecDadWeights)\par
00187         \{\par
00188             {\cf20 // Just pass on the parents as the children.}\par
00189             vecChildAWeights = vecMumWeights;\par
00190             vecChildBWeights = vecDadWeights;\par
00191             {\cf19 return};\par
00192         \}\par
00193 \par
00194         {\cf20 // If we get here, mum and dad are different and a crossover is to be performed.}\par
00195 \par
00196         {\cf20 // Using the vector holding where we are allowed to split the weights, so that they do not split a portion of a single neuron,}\par
00197         {\cf20 // determine two crossover points}\par
00198         {\cf18 int} iRand1 = randInt(0, ({\cf18 int})vecSplitPoints.size() - 2);\par
00199         {\cf18 int} iCrossoverPoint1 = vecSplitPoints[iRand1];\par
00200         {\cf18 int} iRand2 = randInt(iRand1+1, ({\cf18 int})vecSplitPoints.size() - 1);\par
00201         {\cf18 int} iCrossoverPoint2 = vecSplitPoints[iRand2];\par
00202 \par
00203         {\cf20 // Clear the child weights}\par
00204         vecChildAWeights.clear();\par
00205         vecChildBWeights.clear();\par
00206 \par
00207         {\cf20 // Give the children weights from mum and dad}\par
00208         {\cf19 for} ({\cf18 int} i = 0; i < (int)vecMumWeights.size(); i++)\par
00209         \{\par
00210             {\cf20 // If outside of the crossover points}\par
00211             {\cf19 if} (i < iCrossoverPoint1 || i > iCrossoverPoint2)\par
00212             \{\par
00213                 {\cf20 // Child A gets all of mum's weights}\par
00214                 vecChildAWeights.push_back(vecMumWeights[i]);\par
00215 \par
00216                 {\cf20 // The other child, all of dad's}\par
00217                 vecChildBWeights.push_back(vecDadWeights[i]);\par
00218             \}\par
00219             {\cf19 else}\par
00220             \{\par
00221                 {\cf20 // Child A gets all of dad's weights}\par
00222                 vecChildAWeights.push_back(vecDadWeights[i]);\par
00223 \par
00224                 {\cf20 // The other child, all of mum's}\par
00225                 vecChildBWeights.push_back(vecMumWeights[i]);\par
00226             \}\par
00227         \}\par
00228     \}\par
00229 \par
00230     {\cf18 void} CGeneticsTraining::mutate(std::vector<double>& vecNetworkWeights, {\cf18 double} dMutationProbability, {\cf18 double} dMutationMaxAmount){\cf17  const}\par
00231 {\cf17     }\{\par
00232         ThrowIfFalse(vecNetworkWeights.size(), {\cf22 "CGeneticsTraining::mutate() failed. Given network weights vector of zero size."});\par
00233         {\cf20 // Go through each weight and perhaps mutate it}\par
00234         {\cf19 for} ({\cf18 int} i = 0; i < (int)vecNetworkWeights.size(); i++)\par
00235         \{\par
00236             {\cf19 if} (randDouble() < dMutationProbability)\par
00237             \{\par
00238                 vecNetworkWeights[i] += randomClamped() * dMutationMaxAmount;\par
00239             \}\par
00240         \}\par
00241     \}\par
00242 \par
00243     {\cf18 void} CGeneticsTraining::insertElite(std::vector<CGenome>& vecOldPop, std::vector<CGenome>& vecNewPop, {\cf18 int} iNumberOfElite, {\cf18 int} iNumCopiesOfEachElite){\cf17  const}\par
00244 {\cf17     }\{\par
00245         {\cf20 // Sort the old population by fitness so that the fitest are towards the end of the vector}\par
00246         std::sort(vecOldPop.begin(), vecOldPop.end());\par
00247 \par
00248         {\cf20 // For each number of elite to insert}\par
00249         {\cf19 for} ({\cf18 int} i = 0; i < iNumberOfElite; i++)\par
00250         \{\par
00251             {\cf20 // Add X copies of each elite}\par
00252             {\cf19 for} ({\cf18 int} j = 0; j < iNumCopiesOfEachElite; j++)\par
00253             \{\par
00254                 {\cf20 // Make sure there is room for the elite}\par
00255                 {\cf19 if} (vecNewPop.size() < vecOldPop.size())\par
00256                 \{\par
00257                     vecNewPop.push_back(vecOldPop[vecOldPop.size() - 1 - i]);\par
00258                 \}\par
00259                 {\cf19 else}\par
00260                 \{\par
00261                     {\cf19 break};\par
00262                 \}\par
00263             \}\par
00264         \}\par
00265     \}\par
00266 \par
00267     std::vector<CGenome> CGeneticsTraining::createNewGeneration(\par
00268         {\cf17 const} std::vector<CGenome>& genomes,\par
00269         {\cf17 const} std::vector<int>& vecSplitsPoints,\par
00270         {\cf18 double} dMutationProbability,\par
00271         {\cf18 double} dMutationMaxAmount,\par
00272         {\cf18 double} dCrossoverRate,\par
00273         {\cf18 int} iNumberOfElite,\par
00274         {\cf18 int} iNumCopiesOfEachElite){\cf17  const}\par
00275 {\cf17     }\{\par
00276         {\cf20 // Error checking}\par
00277         ThrowIfFalse(genomes.size(), {\cf22 "CGeneticsTraining::createNewGeneration() failed, as it was given a vector of CGenome objects of zero size."});\par
00278         ThrowIfTrue(iNumberOfElite < 0 || iNumCopiesOfEachElite < 0, {\cf22 "CGeneticsTraining::createNewGeneration() failed, as it was given values less than zero for iNumberOfElite or iNumCopiesOfEachElite."});\par
00279 \par
00280         {\cf20 // The old population of genomes}\par
00281         std::vector<CGenome> vecOldPop = genomes;\par
00282 \par
00283         {\cf20 // Compute worst, average, best and total fitness of the entire population}\par
00284         {\cf18 double} dWorstFitness, dAverageFitness, dBestFitness, dTotalFitness;\par
00285         computeFitness(vecOldPop, dWorstFitness, dAverageFitness, dBestFitness, dTotalFitness);\par
00286 \par
00287         {\cf20 // Create the new population of genomes}\par
00288         std::vector<CGenome> vecNewPop;\par
00289 \par
00290         {\cf20 // Insert the elite}\par
00291         insertElite(vecOldPop, vecNewPop, iNumberOfElite, iNumCopiesOfEachElite);\par
00292 \par
00293         {\cf19 while} (vecNewPop.size() < vecOldPop.size())\par
00294         \{\par
00295             {\cf20 // Use roulette wheel selection to choose a mum and dad}\par
00296             CGenome mum = rouletteWheelSelection(vecOldPop);\par
00297             CGenome dad = rouletteWheelSelection(vecOldPop);\par
00298 \par
00299             {\cf20 // Perform some crossover to create the babies}\par
00300             CGenome baby1;\par
00301             CGenome baby2;\par
00302             crossoverBetweenNeurons(mum.vecWeights, dad.vecWeights, baby1.vecWeights, baby2.vecWeights, vecSplitsPoints, dCrossoverRate);\par
00303 \par
00304             {\cf20 // Now mutate the babies (Yeuck!)}\par
00305             mutate(baby1.vecWeights, dMutationProbability, dMutationMaxAmount);\par
00306             mutate(baby2.vecWeights, dMutationProbability, dMutationMaxAmount);\par
00307 \par
00308             {\cf20 // Now add the new babies into the new population of genomes}\par
00309             vecNewPop.push_back(baby1);\par
00310 \par
00311             {\cf20 // We check the new population size as the population size may be an odd number and if we add two}\par
00312             {\cf20 // babies, we'll create an oversized population.}\par
00313             {\cf19 if} (vecNewPop.size() < vecOldPop.size())\par
00314                 vecNewPop.push_back(baby2);\par
00315         \}\par
00316 \par
00317         {\cf20 // Error checking}\par
00318         {\cf19 return} vecNewPop;\par
00319     \}\par
00320 \par
00321 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/GeneticAlgorithm.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/GeneticAlgorithm.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/GeneticAlgorithm.h}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Genetic algorithm training for neural networks. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "neuralNetFeedForward.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CGenome}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is used with the {\b CGeneticsTraining} class with methods which are used to create an entire new population of networks from an existing one. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CGeneticsTraining}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the genetics training class which is used with the neural network class to train the weights of that class. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Genetic algorithm training for neural networks. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b GeneticAlgorithm.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GeneticAlgorithm.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/GeneticAlgorithm.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/GeneticAlgorithm.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef GENETICALGORITHM_H}\par
00007 {\cf21 #define GENETICALGORITHM_H}\par
00008 \par
00009 {\cf21 #include "neuralNetFeedForward.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00030     {\cf17 class }CGenome\par
00031     \{\par
00032     {\cf17 public}:\par
00034         CGenome();\par
00035 \par
00040         CGenome(std::vector<double>& vecNeuralNetworkWeights, {\cf18 double} dNetworkFitness);\par
00041 \par
00046         CGenome({\cf17 const} CNeuralNetworkFeedForward& neuralNetwork, {\cf18 double} dNetworkFitness);\par
00047 \par
00052         {\cf18 void} set(std::vector<double>& vecNeuralNetworkWeights, {\cf18 double} dNetworkFitness);\par
00053 \par
00058         {\cf18 void} set({\cf17 const} CNeuralNetworkFeedForward& neuralNetwork, {\cf18 double} dNetworkFitness);\par
00059 \par
00060         std::vector<double> vecWeights;     \par
00061         {\cf18 double} dFitness;                    \par
00062 \par
00067         {\cf17 friend} {\cf18 bool} operator<({\cf17 const} CGenome& lhs, {\cf17 const} CGenome& rhs)\par
00068         \{\par
00069             {\cf19 return} (lhs.dFitness < rhs.dFitness);\par
00070         \}\par
00071     \};\par
00072 \par
00108     {\cf17 class }CGeneticsTraining\par
00109     \{\par
00110     {\cf17 public}:\par
00111 \par
00125         CGenome rouletteWheelSelection({\cf17 const} std::vector<CGenome>& vecPopulation) {\cf17 const};\par
00126 \par
00135         {\cf18 void} computeFitness({\cf17 const} std::vector<double>& vecPopulationFitness, {\cf18 double}& dWorstFitness, {\cf18 double}& dAverageFitness, {\cf18 double}& dBestFitness, {\cf18 double}& dTotalFitness) {\cf17 const};\par
00136 \par
00144         {\cf18 void} computeFitness({\cf17 const} std::vector<CGenome>& vecPopulation, {\cf18 double}& dWorstFitness, {\cf18 double}& dAverageFitness, {\cf18 double}& dBestFitness, {\cf18 double}& dTotalFitness) {\cf17 const};\par
00145 \par
00163         {\cf18 void} crossover(\par
00164             std::vector<double>& vecMumWeights,\par
00165             std::vector<double>& vecDadWeights,\par
00166             std::vector<double>& vecChildAWeights,\par
00167             std::vector<double>& vecChildBWeights,\par
00168             {\cf18 double} dCrossoverRate = 0.7) {\cf17 const};\par
00169 \par
00188         {\cf18 void} crossoverBetweenNeurons(\par
00189             std::vector<double>& vecMumWeights,\par
00190             std::vector<double>& vecDadWeights,\par
00191             std::vector<double>& vecChildAWeights,\par
00192             std::vector<double>& vecChildBWeights,\par
00193             {\cf17 const} std::vector<int>& vecSplitPoints,\par
00194             {\cf18 double} dCrossoverRate = 0.7) {\cf17 const};\par
00195 \par
00206         {\cf18 void} mutate(std::vector<double>& vecNetworkWeights, {\cf18 double} dMutationProbability = 0.001, {\cf18 double} dMutationMaxAmount = 0.3) {\cf17 const};\par
00207 \par
00226         {\cf18 void} insertElite(std::vector<CGenome>& vecOldPop, std::vector<CGenome>& vecNewPop, {\cf18 int} iNumberOfElite = 2, {\cf18 int} iNumCopiesOfEachElite = 1) {\cf17 const};\par
00227 \par
00241         std::vector<CGenome> createNewGeneration(\par
00242             {\cf17 const} std::vector<CGenome>& genomes,\par
00243             {\cf17 const} std::vector<int>& vecSplitsPoints,\par
00244             {\cf18 double} dMutationProbability = 0.001,\par
00245             {\cf18 double} dMutationMaxAmount = 0.3,\par
00246             {\cf18 double} dCrossoverRate = 0.7,\par
00247             {\cf18 int} iNumberOfElite = 2,\par
00248             {\cf18 int} iNumCopiesOfEachElite = 1) {\cf17 const};\par
00249 \par
00250     {\cf17 private}:\par
00251 \par
00252     \};\par
00253 \par
00254 \}   {\cf20 // namespace DCL}\par
00255 \par
00256 {\cf21 #endif }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NeuralNetFeedForward.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "neuralNetFeedForward.h"}\par
00002 {\cf21 #include "../Core/Utilities.h"}\par
00003 {\cf21 #include "../Core/Exceptions.h"}\par
00004 \par
00005 {\cf17 namespace }DCL\par
00006 \{\par
00007     CNeuron::CNeuron({\cf18 int} iNumInputs)\par
00008     \{\par
00009         {\cf20 // We need an additional weight for the bias of this neuron}\par
00010         miNumInputs = iNumInputs + 1;\par
00011         {\cf19 for} ({\cf18 int} i = 0; i < iNumInputs + 1; i++)\par
00012         \{\par
00013             {\cf20 // Set weights to random values between -1 and +1}\par
00014             mvecInputWeights.push_back(randomClamped());\par
00015         \}\par
00016     \}\par
00017 \par
00018     CNeuronLayer::CNeuronLayer({\cf18 int} iNumNeurons, {\cf18 int} iNumInputsPerNeuron)\par
00019     \{\par
00020         miNumNeurons = iNumNeurons;\par
00021         {\cf19 for} ({\cf18 int} i = 0; i < iNumNeurons; i++)\par
00022         \{\par
00023             mvecNeurons.push_back(CNeuron(iNumInputsPerNeuron));\par
00024         \}\par
00025     \}\par
00026 \par
00027     CNeuralNetworkFeedForward::CNeuralNetworkFeedForward()\par
00028     \{\par
00029         create(1, 1, 0, 0);\par
00030     \}\par
00031 \par
00032     CNeuralNetworkFeedForward::CNeuralNetworkFeedForward({\cf18 int} iNumInputs, {\cf18 int} iNumOutputs, {\cf18 int} iNumLayers, {\cf18 int} iNumNeuronsPerLayer)\par
00033     \{\par
00034         create(iNumInputs, iNumOutputs, iNumLayers, iNumNeuronsPerLayer);\par
00035     \}\par
00036 \par
00037     {\cf18 void} CNeuralNetworkFeedForward::create({\cf18 int} iNumInputs, {\cf18 int} iNumOutputs, {\cf18 int} iNumLayers, {\cf18 int} iNumNeuronsPerLayer)\par
00038     \{\par
00039         {\cf20 // Check for valid parameters}\par
00040         ThrowIfTrue(iNumInputs < 1, {\cf22 "CNeuralNetworkFeedForward::create() given invalid number of inputs. Must be at least 1"});\par
00041         ThrowIfTrue(iNumOutputs < 1, {\cf22 "CNeuralNetworkFeedForward::create() given invalid number of outputs. Must be at least 1"});\par
00042         ThrowIfTrue(iNumLayers < 0, {\cf22 "CNeuralNetworkFeedForward::create() given invalid number of layers. Must be at least 0"});\par
00043         ThrowIfTrue(iNumNeuronsPerLayer < 1 && iNumLayers > 0, {\cf22 "CNeuralNetworkFeedForward::create() given invalid number of neurons per layer. Must be at least 1 if iNumLayers is > 0"});\par
00044 \par
00045         {\cf20 // Clear everything}\par
00046         _mvecLayers.clear();\par
00047 \par
00048         {\cf20 // Set given parameters}\par
00049         _miNumInputs = iNumInputs;\par
00050         _miNumOutputs = iNumOutputs;\par
00051         _miNumLayers = iNumLayers;\par
00052         _miNumNeuronsPerLayer = iNumNeuronsPerLayer;\par
00053 \par
00054         {\cf20 // Set default bias}\par
00055         _mdBias = -1;\par
00056 \par
00057         {\cf20 // Set default sigmoid response}\par
00058         _mdSigmoidResponse = 1;\par
00059 \par
00060         {\cf19 if} (_miNumLayers)\par
00061         \{\par
00062             {\cf20 // Create the first layer of neurons which have the number of inputs set to the number of inputs of the network.}\par
00063             _mvecLayers.push_back(CNeuronLayer(_miNumNeuronsPerLayer, _miNumInputs));\par
00064 \par
00065             {\cf20 // Create the other layers}\par
00066             {\cf20 // iNumLayers -1 because we've already created a layer above}\par
00067             {\cf19 for} ({\cf18 int} i = 0; i < _miNumLayers - 1; i++)\par
00068             \{\par
00069                 {\cf20 // Create the layer, using the number of inputs set to the number of neurons per layer}\par
00070                 _mvecLayers.push_back(CNeuronLayer(_miNumNeuronsPerLayer, _miNumNeuronsPerLayer));\par
00071             \}\par
00072 \par
00073             {\cf20 // Create the output layer}\par
00074             _mvecLayers.push_back(CNeuronLayer(_miNumOutputs, _miNumNeuronsPerLayer));\par
00075         \}\par
00076         {\cf19 else}\par
00077         \{\par
00078             {\cf20 // Create the output layer}\par
00079             _mvecLayers.push_back(CNeuronLayer(_miNumOutputs, _miNumInputs));\par
00080         \}\par
00081     \}\par
00082 \par
00083     std::vector<double> CNeuralNetworkFeedForward::getNeuronWeights({\cf18 void}){\cf17  const}\par
00084 {\cf17     }\{\par
00085         std::vector<double> vecWeights;\par
00086 \par
00087         {\cf20 // For each layer (+1 as we are also returning the output layer)}\par
00088         {\cf19 for} ({\cf18 int} iLayer = 0; iLayer < _miNumLayers + 1; iLayer++)\par
00089         \{\par
00090             {\cf20 // For each neuron in each layer}\par
00091             {\cf19 for} ({\cf18 int} iNeuron = 0; iNeuron < _mvecLayers[iLayer].miNumNeurons; iNeuron++)\par
00092             \{\par
00093                 {\cf20 // For each weight in each neuron, not including the bias of the neuron}\par
00094                 {\cf19 for} ({\cf18 int} iWeight = 0; iWeight < _mvecLayers[iLayer].mvecNeurons[iNeuron].miNumInputs; iWeight++)\par
00095                 \{\par
00096                     vecWeights.push_back(_mvecLayers[iLayer].mvecNeurons[iNeuron].mvecInputWeights[iWeight]);\par
00097                 \}\par
00098             \}\par
00099         \}\par
00100         {\cf19 return} vecWeights;\par
00101     \}\par
00102 \par
00103     {\cf18 int} CNeuralNetworkFeedForward::getNumberOfWeights({\cf18 void}){\cf17  const}\par
00104 {\cf17     }\{\par
00105         {\cf18 int} iNumberOfWeights = 0;\par
00106         {\cf20 // For each layer (+1 as we are also returning the output layer)}\par
00107         {\cf19 for} ({\cf18 int} iLayer = 0; iLayer < _miNumLayers + 1; iLayer++)\par
00108         \{\par
00109             {\cf20 // For each neuron in each layer}\par
00110             {\cf19 for} ({\cf18 int} iNeuron = 0; iNeuron < _mvecLayers[iLayer].miNumNeurons; iNeuron++)\par
00111             \{\par
00112                 {\cf20 // For each weight in each neuron, not including the bias of the neuron}\par
00113                 {\cf19 for} ({\cf18 int} iWeight = 0; iWeight < _mvecLayers[iLayer].mvecNeurons[iNeuron].miNumInputs; iWeight++)\par
00114                 \{\par
00115                     iNumberOfWeights++;\par
00116                 \}\par
00117             \}\par
00118         \}\par
00119         {\cf19 return} iNumberOfWeights;\par
00120     \}\par
00121 \par
00122     {\cf18 void} CNeuralNetworkFeedForward::replaceWeights({\cf17 const} std::vector<double>& newWeights)\par
00123     \{\par
00124         {\cf18 int} iIndex = 0;\par
00125 \par
00126         {\cf20 // For each layer (+1 as we are also replacing the output layer)}\par
00127         {\cf19 for} ({\cf18 int} iLayer = 0; iLayer < _miNumLayers + 1; iLayer++)\par
00128         \{\par
00129             {\cf20 // For each neuron in each layer}\par
00130             {\cf19 for} ({\cf18 int} iNeuron = 0; iNeuron < _mvecLayers[iLayer].miNumNeurons; iNeuron++)\par
00131             \{\par
00132                 {\cf20 // For each weight in each neuron, not including the bias of the neuron}\par
00133                 {\cf19 for} ({\cf18 int} iWeight = 0; iWeight < _mvecLayers[iLayer].mvecNeurons[iNeuron].miNumInputs; iWeight++)\par
00134                 \{\par
00135                     _mvecLayers[iLayer].mvecNeurons[iNeuron].mvecInputWeights[iWeight] = newWeights[iIndex++];\par
00136                 \}\par
00137             \}\par
00138         \}\par
00139     \}\par
00140 \par
00141     std::vector<double> CNeuralNetworkFeedForward::update(std::vector<double>& vecInputs)\par
00142     \{\par
00143         ThrowIfTrue(vecInputs.size() != _miNumInputs, {\cf22 "CNeuralNetworkFeedForward::update() failed. Was given a vector of inputs which are not equal to in size of the network's number of inputs"});\par
00144         std::vector<double> vecOutputs;\par
00145 \par
00146         {\cf18 int} cWeight = 0;\par
00147 \par
00148         {\cf20 // For each layer (+1 as we are also updating the output layer)}\par
00149         {\cf19 for} ({\cf18 int} iLayer = 0; iLayer < _miNumLayers + 1; iLayer++)\par
00150         \{\par
00151             {\cf20 // If we've used the inputs, we need to set the inputs to be the outputs of the previous layer}\par
00152             {\cf19 if} (iLayer > 0)\par
00153                 vecInputs = vecOutputs;\par
00154 \par
00155             {\cf20 // Clear the outputs, as we're going to calculate them below}\par
00156             vecOutputs.clear();\par
00157 \par
00158             {\cf20 // Used to count through each weight in the inputs below.}\par
00159             cWeight = 0;\par
00160 \par
00161             {\cf18 int} iNumInputs = 0;\par
00162 \par
00163             {\cf20 // For each neuron in each layer}\par
00164             {\cf20 // multiply the input by the weight for that input, then use the sigmoid}\par
00165             {\cf20 // function to smooth it out to get the final output.}\par
00166             {\cf19 for} ({\cf18 int} iNeuron = 0; iNeuron < _mvecLayers[iLayer].miNumNeurons; iNeuron++)\par
00167             \{\par
00168                 {\cf18 double} dAccumulatedInput = 0;\par
00169                 iNumInputs = _mvecLayers[iLayer].mvecNeurons[iNeuron].miNumInputs;\par
00170 \par
00171                 {\cf20 // For each weight, not including the bias (the -1)}\par
00172                 {\cf19 for} ({\cf18 int} iWeight = 0; iWeight < iNumInputs - 1; iWeight++)\par
00173                 \{\par
00174                     dAccumulatedInput += _mvecLayers[iLayer].mvecNeurons[iNeuron].mvecInputWeights[iWeight] * vecInputs[cWeight++];\par
00175                 \}\par
00176 \par
00177                 {\cf20 // Multiply by the bias}\par
00178                 dAccumulatedInput += _mvecLayers[iLayer].mvecNeurons[iNeuron].mvecInputWeights[iNumInputs - 1] * _mdBias;\par
00179 \par
00180                 {\cf20 // Pass the final computed input value, multiplied by the weights, with the bias applied, to the sigmoid function to}\par
00181                 {\cf20 // obtain the final output value and store that in the vector of outputs.}\par
00182                 vecOutputs.push_back(sigmoid(dAccumulatedInput, _mdSigmoidResponse));\par
00183 \par
00184                 cWeight = 0;\par
00185             \}\par
00186         \}\par
00187         {\cf19 return} vecOutputs;\par
00188     \}\par
00189 \par
00190     {\cf18 void} CNeuralNetworkFeedForward::setWeightBias({\cf18 double} dWeightBias)\par
00191     \{\par
00192         _mdBias = dWeightBias;\par
00193     \}\par
00194 \par
00195     {\cf18 void} CNeuralNetworkFeedForward::setSigmoidResponse({\cf18 double} dResponse)\par
00196     \{\par
00197         ThrowIfTrue(areDoublesEqual(0, dResponse), {\cf22 "CNeuralNetworkFeedForward::setSigmoidResponse() failed. The given value should not be zero. Otherwise a divide by zero error occurs."});\par
00198         _mdSigmoidResponse = dResponse;\par
00199     \}\par
00200 \par
00201     std::vector<int> CNeuralNetworkFeedForward::calculateSplitPoints({\cf18 void})\par
00202     \{\par
00203         std::vector<int> vecSplitPoints;\par
00204 \par
00205         {\cf18 int} iWeightCounter = 0;\par
00206 \par
00207         {\cf20 // For each layer (+1 as we are also giving the output layer)}\par
00208         {\cf19 for} ({\cf18 int} iLayer = 0; iLayer < _miNumLayers + 1; iLayer++)\par
00209         \{\par
00210             {\cf20 // For each neuron in each layer}\par
00211             {\cf19 for} ({\cf18 int} iNeuron = 0; iNeuron < _mvecLayers[iLayer].miNumNeurons; iNeuron++)\par
00212             \{\par
00213                 {\cf20 // For each weight in each neuron, not including the bias of the neuron}\par
00214                 {\cf19 for} ({\cf18 int} iWeight = 0; iWeight < _mvecLayers[iLayer].mvecNeurons[iNeuron].miNumInputs; iWeight++)\par
00215                 \{\par
00216                     iWeightCounter++;\par
00217                 \}\par
00218                 vecSplitPoints.push_back(iWeightCounter - 1);\par
00219             \}\par
00220         \}\par
00221         {\cf19 return} vecSplitPoints;\par
00222     \}\par
00223 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.h}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Feed forward neural network. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CNeuron}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron of a neural network. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CNeuronLayer}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A neuron layer. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CNeuralNetworkFeedForward}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a "feed forward" neural network. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Feed forward neural network. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b NeuralNetFeedForward.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NeuralNetFeedForward.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/NeuralNetFeedForward.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef NEURALNETFEEDFORWARD_H}\par
00007 {\cf21 #define NEURALNETFEEDFORWARD_H}\par
00008 \par
00009 {\cf21 #include <vector>}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00017     {\cf17 class }CNeuron\par
00018     \{\par
00019     {\cf17 public}:\par
00027         CNeuron({\cf18 int} iNumInputs);\par
00028 \par
00029         std::vector<double> mvecInputWeights;   \par
00030 \par
00037         {\cf18 int} miNumInputs;\par
00038     \};\par
00039 \par
00043     {\cf17 class }CNeuronLayer\par
00044     \{\par
00045     {\cf17 public}:\par
00052         CNeuronLayer({\cf18 int} iNumNeurons, {\cf18 int} iNumInputsPerNeuron);\par
00053 \par
00055         std::vector<CNeuron> mvecNeurons;\par
00056 \par
00061         {\cf18 int} miNumNeurons;\par
00062     \};\par
00063 \par
00199     {\cf17 class }CNeuralNetworkFeedForward\par
00200     \{\par
00201     {\cf17 public}:\par
00205         CNeuralNetworkFeedForward();\par
00206 \par
00215         CNeuralNetworkFeedForward({\cf18 int} iNumInputs, {\cf18 int} iNumOutputs, {\cf18 int} iNumLayers, {\cf18 int} iNumNeuronsPerLayer);\par
00216 \par
00223         {\cf18 void} create({\cf18 int} iNumInputs, {\cf18 int} iNumOutputs, {\cf18 int} iNumLayers, {\cf18 int} iNumNeuronsPerLayer);\par
00224 \par
00228         std::vector<double> getNeuronWeights({\cf18 void}) {\cf17 const};\par
00229 \par
00233         {\cf18 int} getNumberOfWeights({\cf18 void}) {\cf17 const};\par
00234 \par
00238         {\cf18 void} replaceWeights({\cf17 const} std::vector<double>& newWeights);\par
00239 \par
00246         std::vector<double> update(std::vector<double>& vecInputs);\par
00247 \par
00253         {\cf18 void} setWeightBias({\cf18 double} dWeightBias = -1);\par
00254 \par
00262         {\cf18 void} setSigmoidResponse({\cf18 double} dResponse = 1);\par
00263 \par
00273         std::vector<int> calculateSplitPoints({\cf18 void});\par
00274     {\cf17 private}:\par
00275 \par
00276         {\cf18 int} _miNumInputs;           \par
00277         {\cf18 int} _miNumOutputs;          \par
00278         {\cf18 int} _miNumLayers;           \par
00279         {\cf18 int} _miNumNeuronsPerLayer;  \par
00280         {\cf18 double} _mdBias;             \par
00281         {\cf18 double} _mdSigmoidResponse;  \par
00282 \par
00288         std::vector<CNeuronLayer> _mvecLayers;\par
00289     \};\par
00290 \par
00291 \}   {\cf20 // namespace DCL}\par
00292 \par
00293 {\cf21 #endif }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioManager.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioManager.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioManager.cpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AudioManager.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     CAudioManager::CAudioManager({\cf18 int} iFrequency, {\cf18 int} iNumberOfChannels, {\cf18 int} iChunkSizeInSamples)\par
00007     \{\par
00008         {\cf19 if} (SDL_Init(SDL_INIT_AUDIO) < 0)\par
00009         \{\par
00010             std::string strError({\cf22 "SDL could not initialize: "});\par
00011             strError.append(SDL_GetError());\par
00012             ThrowIfTrue(1, strError);\par
00013         \}\par
00014         {\cf20 /*}\par
00015 {\cf20         if (Mix_OpenAudio(iFrequency, MIX_DEFAULT_FORMAT, iNumberOfChannels, iChunkSizeInSamples) < 0)}\par
00016 {\cf20         \{}\par
00017 {\cf20             std::string strError("SDL_mixer could not initialize: ");}\par
00018 {\cf20             strError.append(Mix_GetError());}\par
00019 {\cf20             ThrowIfTrue(1, strError);}\par
00020 {\cf20         \}}\par
00021 {\cf20         */}\par
00022     \}\par
00023 \par
00024     CAudioManager::~CAudioManager({\cf18 void})\par
00025     \{\par
00026         Mix_CloseAudio();\par
00027         SDL_QuitSubSystem(SDL_INIT_AUDIO);\par
00028     \}\par
00029 \par
00030     {\cf18 bool} CAudioManager::isAudioPlaying({\cf18 void})\par
00031     \{\par
00032         {\cf19 if} (Mix_Playing(-1) > 0)\par
00033             {\cf19 return} {\cf17 true};\par
00034         {\cf19 return} {\cf17 false};\par
00035     \}\par
00036 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioManager.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioManager.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioManager.h}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Audio manager. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../../DynamicLibs/SDL3/include/SDL3/SDL.h"}\par
{\f2 #include "../../../DynamicLibs/SDL3Mixer/include/SDL3_mixer/SDL_mixer.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CAudioManager}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Audio manager. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b AudioManager.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioManager.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioManager.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioManager.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef AUDIOMANAGER_H}\par
00007 {\cf21 #define AUDIOMANAGER_H}\par
00008 \par
00009 {\cf21 #include "../../../DynamicLibs/SDL3/include/SDL3/SDL.h"}\par
00010 {\cf21 #include "../../../DynamicLibs/SDL3Mixer/include/SDL3_mixer/SDL_mixer.h"}\par
00011 \par
00012 {\cf17 namespace }DCL\par
00013 \{\par
00021     {\cf17 class }CAudioManager\par
00022     \{\par
00023     {\cf17 public}:\par
00027         CAudioManager({\cf18 int} iFrequency = 44100, {\cf18 int} iNumberOfChannels = 2, {\cf18 int} iChunkSizeInSamples = 2048);\par
00028 {\cf21 #}\par
00030         ~CAudioManager({\cf18 void});\par
00031 \par
00037         {\cf18 bool} isAudioPlaying({\cf18 void});\par
00038 \par
00039     {\cf17 private}:\par
00040     \par
00041     \};\par
00042 \par
00043 \}   {\cf20 // namespace DCL}\par
00044 \par
00045 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioSample.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioSample.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioSample.cpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AudioSample.h"}\par
00002 \par
00003 {\cf21 #include "../Core/Exceptions.h"}\par
00004 \par
00005 {\cf17 namespace }DCL\par
00006 \{\par
00007     CAudioSample::CAudioSample()\par
00008     \{\par
00009         _mpSampleChunk = 0;\par
00010     \}\par
00011 \par
00012     CAudioSample::~CAudioSample()\par
00013     \{\par
00014         free();\par
00015     \}\par
00016 \par
00017     {\cf18 void} CAudioSample::load({\cf17 const} std::string& sampleFilename)\par
00018     \{\par
00019         _mpSampleChunk = Mix_LoadWAV(sampleFilename.c_str());\par
00020         {\cf19 if} (!_mpSampleChunk)\par
00021         \{\par
00022             std::string strError({\cf22 "CAudioSample::load(\\""});\par
00023             strError.append(sampleFilename);\par
00024             strError.append({\cf22 "\\") failed. SDL::Mix_LoadWav() failed: "});\par
00025             strError.append(Mix_GetError());\par
00026             ThrowIfTrue(1, strError);\par
00027         \}\par
00028     \}\par
00029 \par
00030     {\cf18 void} CAudioSample::play({\cf18 int} iWhichChannel, {\cf18 int} iNumberOfLoops)\par
00031     \{\par
00032         {\cf19 if} (!_mpSampleChunk)\par
00033             {\cf19 return};\par
00034         Mix_PlayChannel(iWhichChannel, _mpSampleChunk, iNumberOfLoops);\par
00035     \}\par
00036 \par
00037     {\cf18 void} CAudioSample::free({\cf18 void})\par
00038     \{\par
00039         {\cf19 if} (_mpSampleChunk)\par
00040         \{\par
00041             Mix_FreeChunk(_mpSampleChunk);\par
00042             _mpSampleChunk = 0;\par
00043         \}\par
00044     \}\par
00045 \par
00046 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioSample.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioSample.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioSample.h}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../../DynamicLibs/SDL3/include/SDL3/SDL.h"}\par
{\f2 #include "../../../DynamicLibs/SDL3Mixer/include/SDL3_mixer/SDL_mixer.h"}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CAudioSample}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Audio sample for playback with the {\b CAudioManager} class. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b AudioSample.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioSample.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioSample.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Audio/AudioSample.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef AUDIOSAMPLE_H}\par
00007 {\cf21 #define AUDIOSAMPLE_H}\par
00008 \par
00009 {\cf21 #include "../../../DynamicLibs/SDL3/include/SDL3/SDL.h"}\par
00010 {\cf21 #include "../../../DynamicLibs/SDL3Mixer/include/SDL3_mixer/SDL_mixer.h"}\par
00011 \par
00012 {\cf21 #include <string>}\par
00013 \par
00014 {\cf17 namespace }DCL\par
00015 \{\par
00020     {\cf17 class }CAudioSample\par
00021     \{\par
00022     {\cf17 public}:\par
00023 \par
00025         CAudioSample();\par
00026 \par
00028         ~CAudioSample();\par
00029 \par
00035         {\cf18 void} load({\cf17 const} std::string& sampleFilename);\par
00036 \par
00045         {\cf18 void} play({\cf18 int} iWhichChannel = -1, {\cf18 int} iNumberOfLoops = -1);\par
00046 \par
00050         {\cf18 void} free({\cf18 void});\par
00051 \par
00052     {\cf17 private}:\par
00053         Mix_Chunk* _mpSampleChunk;  \par
00054     \};\par
00055 \par
00056 \}   {\cf20 // namespace DCL}\par
00057 \par
00058 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Colourf.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colourf.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colourf.cpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Colourf.h"}\par
00002 {\cf21 #include "Utilities.h"}\par
00003 \par
00004 {\cf21 #include <algorithm>}\par
00005 \par
00006 {\cf17 namespace }DCL\par
00007 \{\par
00008     CColourf::CColourf()\par
00009     \{\par
00010         set(1.0f, 1.0f, 1.0f, 1.0f);\par
00011     \}\par
00012 \par
00013     CColourf::CColourf({\cf18 float} fRed, {\cf18 float} fGreen, {\cf18 float} fBlue, {\cf18 float} fAlpha)\par
00014     \{\par
00015         set(fRed, fGreen, fBlue, fAlpha);\par
00016     \}\par
00017 \par
00018     {\cf18 void} CColourf::set({\cf18 float} fRed, {\cf18 float} fGreen, {\cf18 float} fBlue, {\cf18 float} fAlpha)\par
00019     \{\par
00020         clamp(fRed, 0.0f, 1.0f);\par
00021         clamp(fGreen, 0.0f, 1.0f);\par
00022         clamp(fBlue, 0.0f, 1.0f);\par
00023         clamp(fAlpha, 0.0f, 1.0f);\par
00024         red = fRed;\par
00025         green = fGreen;\par
00026         blue = fBlue;\par
00027         alpha = fAlpha;\par
00028     \}\par
00029 \par
00030     {\cf18 void} CColourf::setFromHSB({\cf18 float} fHueAmount, {\cf18 float} fSaturation, {\cf18 float} fBrightness)\par
00031     \{\par
00032         {\cf20 // Clamp each passed value}\par
00033         clamp(fHueAmount, 0.0f, 1.0f);\par
00034         clamp(fSaturation, 0.0f, 1.0f);\par
00035         clamp(fBrightness, 0.0f, 1.0f);\par
00036 \par
00037         {\cf20 // Compute colour}\par
00038         fHueAmount *= 360.0f;\par
00039         {\cf18 float} fReciprical60 = 1.0f / 60.0f;\par
00040         {\cf19 if} (fHueAmount <= 60.0f)    {\cf20 // Inc green}\par
00041         \{\par
00042             red = 1.0f;\par
00043             green = fHueAmount * fReciprical60;\par
00044             blue = 0.0f;\par
00045         \}\par
00046         {\cf19 else} {\cf19 if} (fHueAmount <= 120.0f)  {\cf20 // Dec red}\par
00047         \{\par
00048             red = 1.0f - ((fHueAmount - 60.0f) * fReciprical60);\par
00049             green = 1.0f;\par
00050             blue = 0.0f;\par
00051         \}\par
00052         {\cf19 else} {\cf19 if} (fHueAmount <= 180.0f)  {\cf20 // Inc blue}\par
00053         \{\par
00054             red = 0.0f;\par
00055             green = 1.0f;\par
00056             blue = (fHueAmount - 120.0f) * fReciprical60;\par
00057         \}\par
00058         {\cf19 else} {\cf19 if} (fHueAmount <= 240.0f)  {\cf20 // Dec green}\par
00059         \{\par
00060             red = 0.0f;\par
00061             green = 1.0f - ((fHueAmount - 180.0f) * fReciprical60);\par
00062             blue = 1.0f;\par
00063         \}\par
00064         {\cf19 else} {\cf19 if} (fHueAmount <= 300.0f)  {\cf20 // Inc red}\par
00065         \{\par
00066             red = (fHueAmount - 240.0f) * fReciprical60;\par
00067             green = 0.0f;\par
00068             blue = 1.0f;\par
00069         \}\par
00070         {\cf19 else} {\cf20 // dec blue}\par
00071         \{\par
00072             red = 1.0f;\par
00073             green = 0.0f;\par
00074             blue = 1.0f - ((fHueAmount - 300.0f) * fReciprical60);\par
00075         \}\par
00076 \par
00077         {\cf20 // Now RGB is set, apply saturation}\par
00078         {\cf18 float} fSaturationScaleR = 1.0f - red;\par
00079         {\cf18 float} fSaturationScaleG = 1.0f - green;\par
00080         {\cf18 float} fSaturationScaleB = 1.0f - blue;\par
00081         red += fSaturationScaleR * fSaturation;\par
00082         green += fSaturationScaleG * fSaturation;\par
00083         blue += fSaturationScaleB * fSaturation;\par
00084         clamp(red, 0.0f, 1.0f);\par
00085         clamp(green, 0.0f, 1.0f);\par
00086         clamp(blue, 0.0f, 1.0f);\par
00087 \par
00088         {\cf20 // Now saturation is added, apply brightness}\par
00089         {\cf18 float} fBrightnessInv = 1.0f - fBrightness;\par
00090         red -= fBrightnessInv;\par
00091         green -= fBrightnessInv;\par
00092         blue -= fBrightnessInv;\par
00093         clamp(red, 0.0f, 1.0f);\par
00094         clamp(green, 0.0f, 1.0f);\par
00095         clamp(blue, 0.0f, 1.0f);\par
00096     \}\par
00097 \par
00098     {\cf18 void} CColourf::getHSB({\cf18 float}& fHue, {\cf18 float}& fSaturation, {\cf18 float}& fBrightness){\cf17  const}\par
00099 {\cf17     }\{\par
00100         {\cf20 // Get maximum and minimum values of current RGB values}\par
00101         {\cf18 float} cmax = std::max(red, std::max(green, blue));\par
00102         {\cf18 float} cmin = std::min(red, std::min(green, blue));\par
00103         {\cf18 float} diff = cmax - cmin; {\cf20 // diff of cmax and cmin.}\par
00104         fHue = -1, fSaturation = -1;\par
00105 \par
00106         {\cf20 // If cmax and cmax are equal then fHue = 0}\par
00107         {\cf19 if} (cmax == cmin)\par
00108             fHue = 0;\par
00109 \par
00110         {\cf20 // If cmax equal r then compute fHue}\par
00111         {\cf19 else} {\cf19 if} (cmax == red)\par
00112             fHue = float(fmod(60 * ((green - blue) / diff) + 360, 360));\par
00113 \par
00114         {\cf20 // If cmax equal g then compute fHue}\par
00115         {\cf19 else} {\cf19 if} (cmax == green)\par
00116             fHue = float(fmod(60 * ((blue - red) / diff) + 120, 360));\par
00117 \par
00118         {\cf20 // If cmax equal b then compute fHue}\par
00119         {\cf19 else} {\cf19 if} (cmax == blue)\par
00120             fHue = float(fmod(60 * ((red - green) / diff) + 240, 360));\par
00121 \par
00122         fHue /= 360.0f;\par
00123 \par
00124         {\cf20 // If cmax equal zero}\par
00125         {\cf19 if} (cmax == 0)\par
00126             fSaturation = 0;\par
00127         {\cf19 else}\par
00128             fSaturation = (diff / cmax);{\cf20 // *100;}\par
00129 \par
00130         {\cf20 // Compute fBrightness}\par
00131         fBrightness = cmax;{\cf20 // *100;}\par
00132     \}\par
00133 \par
00134     CColourf CColourf::interpolate({\cf17 const} CColourf other, {\cf18 float} fValue){\cf17  const}\par
00135 {\cf17     }\{\par
00136         clamp(fValue, 0.0f, 1.0f);\par
00137 \par
00138         CColourf colour;\par
00139         {\cf18 float} fDiff = red - other.red;      {\cf20 // -1.0f (This is 0.0f and other is 1.0f) to 1.0f (This is 1.0f and other is 0.0f)}\par
00140         fDiff *= -1.0f;                     {\cf20 // 1.0f (This is 0.0f and other is 1.0f) to -1.0f (This is 1.0f and other is 0.0f)}\par
00141         colour.red = red + (fDiff * fValue);\par
00142 \par
00143         fDiff = green - other.green;\par
00144         fDiff *= -1.0f;\par
00145         colour.green = green + (fDiff * fValue);\par
00146 \par
00147         fDiff = blue - other.blue;\par
00148         fDiff *= -1.0f;\par
00149         colour.blue = blue + (fDiff * fValue);\par
00150 \par
00151         fDiff = alpha - other.alpha;\par
00152         fDiff *= -1.0f;\par
00153         colour.alpha = alpha + (fDiff * fValue);\par
00154         {\cf19 return} colour;\par
00155     \}\par
00156 \par
00157 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colourf.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colourf.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colourf.h}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CColourf class for representing a colour using a float for each colour component RGBA, totalling 16 bytes (4 bytes per float * 4 components) }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CColourf}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using a float for each colour component RGBA, totalling 16 bytes (4 bytes per float * 4 components) }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CColourf class for representing a colour using a float for each colour component RGBA, totalling 16 bytes (4 bytes per float * 4 components) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gives more range for the colour at the expense of memory usage \par
}{
Definition in file {\b Colourf.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Colourf.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colourf.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colourf.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef COLOURF_H}\par
00007 {\cf21 #define COLOURF_H}\par
00008 \par
00009 {\cf17 namespace }DCL\par
00010 \{\par
00012     {\cf17 class }CColourf\par
00013     \{\par
00014     {\cf17 public}:\par
00016         CColourf();\par
00017 \par
00024         CColourf({\cf18 float} fRed, {\cf18 float} fGreen, {\cf18 float} fBlue, {\cf18 float} fAlpha);\par
00025 \par
00034         {\cf18 void} set({\cf18 float} fRed, {\cf18 float} fGreen, {\cf18 float} fBlue, {\cf18 float} fAlpha);\par
00035 \par
00046         {\cf18 void} setFromHSB({\cf18 float} fHueAmount, {\cf18 float} fSaturation = 1.0f, {\cf18 float} fBrightness = 1.0f);\par
00047 \par
00053         {\cf18 void} getHSB({\cf18 float}& fHue, {\cf18 float}& fSaturation, {\cf18 float}& fBrightness) {\cf17 const};\par
00054 \par
00064         CColourf interpolate({\cf17 const} CColourf other, {\cf18 float} fValue) {\cf17 const};\par
00065 \par
00069         {\cf18 bool} operator == ({\cf17 const} CColourf& col)\par
00070         \{\par
00071             {\cf19 if} (red == col.red && green == col.green && blue == col.blue && alpha == col.alpha)\par
00072                 {\cf19 return} {\cf17 true};\par
00073             {\cf19 return} {\cf17 false};\par
00074         \}\par
00075 \par
00080         CColourf operator*({\cf17 const} CColourf& other){\cf17  const}\par
00081 {\cf17         }\{\par
00082             {\cf19 return} CColourf(red * other.red, green * other.green, blue * other.blue, alpha * other.alpha);\par
00083         \}\par
00084 \par
00085         {\cf18 float} red;      \par
00086         {\cf18 float} green;    \par
00087         {\cf18 float} blue;     \par
00088         {\cf18 float} alpha;    \par
00089     \};\par
00090 \par
00091 \}   {\cf20 // namespace DCL}\par
00092 \par
00093 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Colouruc.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colouruc.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colouruc.cpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Colouruc.h"}\par
00002 {\cf21 #include "Utilities.h"}\par
00003 \par
00004 {\cf21 #include <algorithm>}\par
00005 \par
00006 {\cf17 namespace }DCL\par
00007 \{\par
00008     CColouruc::CColouruc()\par
00009     \{\par
00010         set(255, 255, 255, 255);\par
00011     \}\par
00012 \par
00013     CColouruc::CColouruc({\cf18 unsigned} {\cf18 char} ucRed, {\cf18 unsigned} {\cf18 char} ucGreen, {\cf18 unsigned} {\cf18 char} ucBlue, {\cf18 unsigned} {\cf18 char} ucAlpha)\par
00014     \{\par
00015         set(ucRed, ucGreen, ucBlue, ucAlpha);\par
00016     \}\par
00017 \par
00018     {\cf18 void} CColouruc::set({\cf18 unsigned} {\cf18 char} ucRed, {\cf18 unsigned} {\cf18 char} ucGreen, {\cf18 unsigned} {\cf18 char} ucBlue, {\cf18 unsigned} {\cf18 char} ucAlpha)\par
00019     \{\par
00020         red = ucRed;\par
00021         green = ucGreen;\par
00022         blue = ucBlue;\par
00023         alpha = ucAlpha;\par
00024     \}\par
00025 \par
00026     {\cf18 void} CColouruc::setFromHSB({\cf18 float} fHueAmount, {\cf18 float} fSaturation, {\cf18 float} fBrightness)\par
00027     \{\par
00028         {\cf20 // Clamp each passed value}\par
00029         clamp(fHueAmount, 0.0f, 1.0f);\par
00030         clamp(fSaturation, 0.0f, 1.0f);\par
00031         clamp(fBrightness, 0.0f, 1.0f);\par
00032 \par
00033         {\cf20 // Compute colour}\par
00034         fHueAmount *= 360.0f;\par
00035         {\cf18 float} fReciprical60 = 1.0f / 60.0f;\par
00036         {\cf18 float} fRed, fGreen, fBlue;\par
00037         {\cf19 if} (fHueAmount <= 60.0f)    {\cf20 // Inc green}\par
00038         \{\par
00039             fRed = 1.0f;\par
00040             fGreen = fHueAmount * fReciprical60;\par
00041             fBlue = 0.0f;\par
00042         \}\par
00043         {\cf19 else} {\cf19 if} (fHueAmount <= 120.0f)  {\cf20 // Dec red}\par
00044         \{\par
00045             fRed = 1.0f - ((fHueAmount - 60.0f) * fReciprical60);\par
00046             fGreen = 1.0f;\par
00047             fBlue = 0.0f;\par
00048         \}\par
00049         {\cf19 else} {\cf19 if} (fHueAmount <= 180.0f)  {\cf20 // Inc blue}\par
00050         \{\par
00051             fRed = 0.0f;\par
00052             fGreen = 1.0f;\par
00053             fBlue = (fHueAmount - 120.0f) * fReciprical60;\par
00054         \}\par
00055         {\cf19 else} {\cf19 if} (fHueAmount <= 240.0f)  {\cf20 // Dec green}\par
00056         \{\par
00057             fRed = 0.0f;\par
00058             fGreen = 1.0f - ((fHueAmount - 180.0f) * fReciprical60);\par
00059             fBlue = 1.0f;\par
00060         \}\par
00061         {\cf19 else} {\cf19 if} (fHueAmount <= 300.0f)  {\cf20 // Inc red}\par
00062         \{\par
00063             fRed = (fHueAmount - 240.0f) * fReciprical60;\par
00064             fGreen = 0.0f;\par
00065             fBlue = 1.0f;\par
00066         \}\par
00067         {\cf19 else} {\cf20 // dec blue}\par
00068         \{\par
00069             fRed = 1.0f;\par
00070             fGreen = 0.0f;\par
00071             fBlue = 1.0f - ((fHueAmount - 300.0f) * fReciprical60);\par
00072         \}\par
00073 \par
00074         {\cf20 // Now RGB is set, apply saturation}\par
00075         {\cf18 float} fSaturationScaleR = 1.0f - fRed;\par
00076         {\cf18 float} fSaturationScaleG = 1.0f - fGreen;\par
00077         {\cf18 float} fSaturationScaleB = 1.0f - fBlue;\par
00078         fRed += fSaturationScaleR * fSaturation;\par
00079         fGreen += fSaturationScaleG * fSaturation;\par
00080         fBlue += fSaturationScaleB * fSaturation;\par
00081         clamp(fRed, 0.0f, 1.0f);\par
00082         clamp(fGreen, 0.0f, 1.0f);\par
00083         clamp(fBlue, 0.0f, 1.0f);\par
00084 \par
00085         {\cf20 // Now saturation is added, apply brightness}\par
00086         {\cf18 float} fBrightnessInv = 1.0f - fBrightness;\par
00087         fRed -= fBrightnessInv;\par
00088         fGreen -= fBrightnessInv;\par
00089         fBlue -= fBrightnessInv;\par
00090         clamp(fRed, 0.0f, 1.0f);\par
00091         clamp(fGreen, 0.0f, 1.0f);\par
00092         clamp(fBlue, 0.0f, 1.0f);\par
00093 \par
00094         {\cf20 // Convert float to unsigned char}\par
00095         red = {\cf18 unsigned} char(fRed * 255);\par
00096         green = {\cf18 unsigned} char(fGreen * 255);\par
00097         blue = {\cf18 unsigned} char(fBlue * 255);\par
00098     \}\par
00099 \par
00100     {\cf18 void} CColouruc::getHSB({\cf18 float}& fHue, {\cf18 float}& fSaturation, {\cf18 float}& fBrightness){\cf17  const}\par
00101 {\cf17     }\{\par
00102         {\cf20 // Convert unsigned char to float}\par
00103         {\cf18 float} fOneOver255 = 1.0f / 255.0f;\par
00104         {\cf18 float} fRed = float(red) * fOneOver255;\par
00105         {\cf18 float} fGreen = float(green) * fOneOver255;\par
00106         {\cf18 float} fBlue = float(blue) * fOneOver255;\par
00107 \par
00108         {\cf20 // Get maximum and minimum values of current RGB values}\par
00109         {\cf18 float} cmax = std::max(fRed, std::max(fGreen, fBlue));\par
00110         {\cf18 float} cmin = std::min(fRed, std::min(fGreen, fBlue));\par
00111         {\cf18 float} diff = cmax - cmin; {\cf20 // diff of cmax and cmin.}\par
00112         fHue = -1, fSaturation = -1;\par
00113 \par
00114         {\cf20 // If cmax and cmax are equal then fHue = 0}\par
00115         {\cf19 if} (cmax == cmin)\par
00116             fHue = 0;\par
00117 \par
00118         {\cf20 // If cmax equal r then compute fHue}\par
00119         {\cf19 else} {\cf19 if} (cmax == fRed)\par
00120             fHue = float(fmod(60 * ((fGreen - fBlue) / diff) + 360, 360));\par
00121 \par
00122         {\cf20 // If cmax equal g then compute fHue}\par
00123         {\cf19 else} {\cf19 if} (cmax == green)\par
00124             fHue = float(fmod(60 * ((fBlue - fRed) / diff) + 120, 360));\par
00125 \par
00126         {\cf20 // If cmax equal b then compute fHue}\par
00127         {\cf19 else} {\cf19 if} (cmax == blue)\par
00128             fHue = float(fmod(60 * ((fRed - fGreen) / diff) + 240, 360));\par
00129 \par
00130         fHue /= 360.0f;\par
00131 \par
00132         {\cf20 // If cmax equal zero}\par
00133         {\cf19 if} (cmax == 0)\par
00134             fSaturation = 0;\par
00135         {\cf19 else}\par
00136             fSaturation = (diff / cmax);{\cf20 // *100;}\par
00137 \par
00138         {\cf20 // Compute fBrightness}\par
00139         fBrightness = cmax;{\cf20 // *100;}\par
00140     \}\par
00141 \par
00142     CColouruc CColouruc::interpolate({\cf17 const} CColouruc other, {\cf18 float} fValue){\cf17  const}\par
00143 {\cf17     }\{\par
00144         clamp(fValue, 0.0f, 1.0f);\par
00145 \par
00146         CColouruc colour;\par
00147         {\cf18 int} iDiff = red - other.red;    {\cf20 // In range of -255 to 255}\par
00148         colour.red = red + {\cf18 unsigned} char({\cf18 float}(iDiff) * -fValue);\par
00149 \par
00150         iDiff = green - other.green;\par
00151         colour.green = green + {\cf18 unsigned} char({\cf18 float}(iDiff) * -fValue);\par
00152 \par
00153         iDiff = blue - other.blue;\par
00154         colour.blue = blue + {\cf18 unsigned} char({\cf18 float}(iDiff) * -fValue);\par
00155 \par
00156         iDiff = alpha - other.alpha;\par
00157         colour.alpha = alpha + {\cf18 unsigned} char({\cf18 float}(iDiff) * -fValue);\par
00158         \par
00159         {\cf19 return} colour;\par
00160     \}\par
00161 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colouruc.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colouruc.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colouruc.h}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CColouruc class for representing a colour using an unsigned char for each colour component RGBA, totalling 4 bytes (1 byte per unsigned char * 4 components) }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CColouruc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to represent a colour using an unsigned char for each colour component RGBA, totalling 4 bytes (1 byte per unsigned char * 4 components) }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CColouruc class for representing a colour using an unsigned char for each colour component RGBA, totalling 4 bytes (1 byte per unsigned char * 4 components) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gives less range for the colour with less memory usage \par
}{
Definition in file {\b Colouruc.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Colouruc.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colouruc.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Colouruc.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef COLOURUC_H}\par
00007 {\cf21 #define COLOURUC_H}\par
00008 \par
00009 {\cf17 namespace }DCL\par
00010 \{\par
00012     {\cf17 class }CColouruc\par
00013     \{\par
00014     {\cf17 public}:\par
00016         CColouruc();\par
00017 \par
00024         CColouruc({\cf18 unsigned} {\cf18 char} ucRed, {\cf18 unsigned} {\cf18 char} ucGreen, {\cf18 unsigned} {\cf18 char} ucBlue, {\cf18 unsigned} {\cf18 char} ucAlpha);\par
00025 \par
00032         {\cf18 void} set({\cf18 unsigned} {\cf18 char} ucRed, {\cf18 unsigned} {\cf18 char} ucGreen, {\cf18 unsigned} {\cf18 char} ucBlue, {\cf18 unsigned} {\cf18 char} ucAlpha);\par
00033 \par
00044         {\cf18 void} setFromHSB({\cf18 float} fHueAmount, {\cf18 float} fSaturation = 1.0f, {\cf18 float} fBrightness = 1.0f);\par
00045 \par
00051         {\cf18 void} getHSB({\cf18 float}& fHue, {\cf18 float}& fSaturation, {\cf18 float}& fBrightness) {\cf17 const};\par
00052 \par
00062         CColouruc interpolate({\cf17 const} CColouruc other, {\cf18 float} fValue) {\cf17 const};\par
00063 \par
00067         {\cf18 bool} operator == ({\cf17 const} CColouruc& col)\par
00068         \{\par
00069             {\cf19 if} (red == col.red && green == col.green && blue == col.blue && alpha == col.alpha)\par
00070                 {\cf19 return} {\cf17 true};\par
00071             {\cf19 return} {\cf17 false};\par
00072         \}\par
00073 \par
00078         CColouruc operator*({\cf17 const} CColouruc& other){\cf17  const}\par
00079 {\cf17         }\{\par
00080             {\cf19 return} CColouruc(red * other.red, green * other.green, blue * other.blue, alpha * other.alpha);\par
00081         \}\par
00082 \par
00083         {\cf18 unsigned} {\cf18 char} red;      \par
00084         {\cf18 unsigned} {\cf18 char} green;    \par
00085         {\cf18 unsigned} {\cf18 char} blue;     \par
00086         {\cf18 unsigned} {\cf18 char} alpha;    \par
00087     \};\par
00088 \par
00089 \}   {\cf20 // namespace DCL}\par
00090 \par
00091 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Exceptions.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Exceptions.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Exceptions.cpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Exceptions.h"}\par
00002 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Exceptions.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Exceptions.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Exceptions.h}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains error handling code and macros to deal with errors, warnings and logging of information to a log file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CException}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception containing information about what went wrong. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ThrowIfFalse}(x,  y)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to check a bool and if false, throw an exception which adds filename, line number and the given text. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ThrowIfTrue}(x,  y)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to check a bool and is true, throw an exception which adds filename, line number and the given text. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ThrowIfMemoryNotAllocated}(x)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to check a pointer and if 0, throw an exception stating that the memory was not allocated with filename and line number. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains error handling code and macros to deal with errors, warnings and logging of information to a log file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How we deal with error handling in Dave's Code Library.\par
We use exceptions. Although they introduce a slight performance penalty, they greatly simplify error handling. We use various macros found in this file which are used throughout the codebase to log the status of things happening to a log file, and deal with unrecoverable, exceptional errors The macros in here log information using the CLog class found in {\b Core/Logging.h}\par
The macros reduce the amount of code we have to write everywhere and do stuff such as checking for critical errors, automatically shutting down the process and writing information to a log file.\par
Within our main program loop somewhere, we'd do the following... {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 try}\par
\{\par
    {\cf20 // Main loop would go here}\par
\}\par
{\cf19 catch} (CException &exception)\par
\{\par
    {\cf20 // Deal with the exception somehow...}\par
    x->pLog->add(exception.mstrException, {\cf17 true});\par
    std::wstring strw = StringUtils::stringToWide(exception.mstrException);\par
    MessageBox(x->pWindow->getWindowHandle(), strw.c_str(), L{\cf22 "Sorry, an exception has been thrown..."}, MB_OK);\par
    __debugbreak();\par
\}\par
}
 \par
}{
Definition in file {\b Exceptions.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ThrowIfFalse\:Exceptions.h}
{\xe \v Exceptions.h\:ThrowIfFalse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ThrowIfFalse( x,  y)}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         \{                                           \\\par
        if(!x)\{                                     \\\par
        {\cf19 throw} CException(y, __FILE__, __LINE__);\}   \\\par
        \}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to check a bool and if false, throw an exception which adds filename, line number and the given text. }}\par
{
Definition at line {\b 61} of file {\b Exceptions.h}.}\par
}
{\xe \v ThrowIfMemoryNotAllocated\:Exceptions.h}
{\xe \v Exceptions.h\:ThrowIfMemoryNotAllocated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ThrowIfMemoryNotAllocated( x)}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid             \{                                           \\\par
            if(!x)\{                                     \\\par
            {\cf19 throw} CException({\cf22 "Memory allocation error."}, __FILE__, __LINE__);\}  \\\par
            \}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to check a pointer and if 0, throw an exception stating that the memory was not allocated with filename and line number. }}\par
{
Definition at line {\b 79} of file {\b Exceptions.h}.}\par
}
{\xe \v ThrowIfTrue\:Exceptions.h}
{\xe \v Exceptions.h\:ThrowIfTrue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ThrowIfTrue( x,  y)}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         \{                                           \\\par
        if(x)\{                                      \\\par
        {\cf19 throw} CException(y, __FILE__, __LINE__);\}   \\\par
        \}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to check a bool and is true, throw an exception which adds filename, line number and the given text. }}\par
{
Definition at line {\b 70} of file {\b Exceptions.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Exceptions.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Exceptions.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Exceptions.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00027 \par
00028 {\cf21 #ifndef EXCEPTIONS_H}\par
00029 {\cf21 #define EXCEPTIONS_H}\par
00030 \par
00031 {\cf21 #include <string>}\par
00032 \par
00033 {\cf17 namespace }DCL\par
00034 \{\par
00038     {\cf17 class }CException\par
00039     \{\par
00040     {\cf17 public}:\par
00048         CException(std::string strExceptionText, std::string strFilename, {\cf18 int} iLineNumber)\par
00049         \{\par
00050             mstrException = {\cf22 "File: "} + strFilename + {\cf22 "\\n"};\par
00051             mstrException += {\cf22 "Line: "} + std::to_string(iLineNumber) + {\cf22 "\\n"};\par
00052             mstrException += {\cf22 "Desc: "} + strExceptionText + {\cf22 "\\n"};\par
00053         \}\par
00054         std::string mstrException;  \par
00055     \};\par
00056 \par
00057 {\cf21 #ifndef _DEBUG}\par
00058 \par
00059 {\cf21 #ifndef ThrowIfFalse}\par
00061 {\cf21 #define ThrowIfFalse(x, y)                  \\}\par
00062 {\cf21         \{                                           \\}\par
00063 {\cf21         if(!x)\{                                     \\}\par
00064 {\cf21         throw CException(y, __FILE__, __LINE__);\}   \\}\par
00065 {\cf21         \}}\par
00066 {\cf21 #endif}\par
00067 \par
00068 {\cf21 #ifndef ThrowIfTrue}\par
00070 {\cf21 #define ThrowIfTrue(x, y)                   \\}\par
00071 {\cf21         \{                                           \\}\par
00072 {\cf21         if(x)\{                                      \\}\par
00073 {\cf21         throw CException(y, __FILE__, __LINE__);\}   \\}\par
00074 {\cf21         \}}\par
00075 {\cf21 #endif}\par
00076 \par
00077 {\cf21 #ifndef ThrowIfMemoryNotAllocated}\par
00079 {\cf21 #define ThrowIfMemoryNotAllocated(x)                \\}\par
00080 {\cf21             \{                                           \\}\par
00081 {\cf21             if(!x)\{                                     \\}\par
00082 {\cf21             throw CException("Memory allocation error.", __FILE__, __LINE__);\}  \\}\par
00083 {\cf21             \}}\par
00084 {\cf21 #endif}\par
00085 \par
00086 {\cf21 #else}\par
00087 {\cf21 #ifndef ThrowIfFalse}\par
00089 {\cf21 #define ThrowIfFalse(x, y)                  \\}\par
00090 {\cf21         \{                                           \\}\par
00091 {\cf21         if(!x)\{                                     \\}\par
00092 {\cf21         __debugbreak();                             \\}\par
00093 {\cf21         throw CException(y, __FILE__, __LINE__);\}   \\}\par
00094 {\cf21         \}}\par
00095 {\cf21 #endif}\par
00096 \par
00097 {\cf21 #ifndef ThrowIfTrue}\par
00099 {\cf21 #define ThrowIfTrue(x, y)                   \\}\par
00100 {\cf21         \{                                           \\}\par
00101 {\cf21         if(x)\{                                      \\}\par
00102 {\cf21         __debugbreak();                             \\}\par
00103 {\cf21         throw CException(y, __FILE__, __LINE__);\}   \\}\par
00104 {\cf21         \}}\par
00105 {\cf21 #endif}\par
00106 \par
00107 {\cf21 #ifndef ThrowIfMemoryNotAllocated}\par
00109 {\cf21 #define ThrowIfMemoryNotAllocated(x)                \\}\par
00110 {\cf21             \{                                           \\}\par
00111 {\cf21             if(!x)\{                                     \\}\par
00112 {\cf21             __debugbreak();                             \\}\par
00113 {\cf21             throw CException("Memory allocation error.", __FILE__, __LINE__);\}  \\}\par
00114 {\cf21             \}}\par
00115 {\cf21 #endif}\par
00116 {\cf21 #endif  }{\cf20 // #ifndef _DEBUG}\par
00117 \par
00118 \par
00119 \}   {\cf20 // namespace DCL}\par
00120 \par
00121 {\cf21 #endif }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Logging.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Logging.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Logging.cpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Logging.h"}\par
00002 {\cf21 #include "Exceptions.h"}\par
00003 {\cf21 #include <filesystem>}\par
00004 \par
00005 {\cf17 namespace }DCL\par
00006 \{\par
00007     CLogEntry::CLogEntry()\par
00008     \{\par
00009         fTimeSeconds = 0.0f;\par
00010         iTimeMin = 0;\par
00011         iTimeHours = 0;\par
00012         iTimeDays = 0;\par
00013         iTimeWeeks = 0;\par
00014 \par
00015     \}\par
00016 \par
00017     CLog::CLog()\par
00018     \{\par
00019         _mstrLogFilename = {\cf22 "log.txt"};\par
00020         clear();\par
00021     \}\par
00022 \par
00023     {\cf18 void} CLog::add({\cf17 const} std::string& {\cf18 string})\par
00024     \{\par
00025         CLogEntry logEntry;\par
00026     \par
00027         std::fstream fs;\par
00028         fs.open(_mstrLogFilename, std::ios::out | std::ios::app);\par
00029 \par
00030         {\cf20 // Store the given string in the log entry}\par
00031         logEntry.strText = string;\par
00032 \par
00033         {\cf20 // Store current runtime in the log entry}\par
00034         _timer.update();\par
00035         _timer.getClock(logEntry.fTimeSeconds, logEntry.iTimeMin, logEntry.iTimeHours, logEntry.iTimeDays, logEntry.iTimeWeeks);\par
00036 \par
00037         {\cf20 // Create the current runtime as a string in the log entry}\par
00038         logEntry.strTime += std::to_string(logEntry.iTimeWeeks) + {\cf22 "w:"};\par
00039         logEntry.strTime += std::to_string(logEntry.iTimeDays) + {\cf22 "d:"};\par
00040         logEntry.strTime += std::to_string(logEntry.iTimeHours) + {\cf22 "h:"};\par
00041         logEntry.strTime += std::to_string(logEntry.iTimeMin) + {\cf22 "m:"};\par
00042         {\cf19 if} (logEntry.fTimeSeconds < 10.0f)\par
00043             logEntry.strTime += {\cf22 "0"};\par
00044         logEntry.strTime += std::to_string({\cf18 int}(logEntry.fTimeSeconds)) + {\cf22 "s : "};\par
00045 \par
00046         {\cf20 // Output time string to file}\par
00047         fs << logEntry.strTime.c_str();\par
00048 \par
00049         {\cf20 // Output the log entry's text to the file}\par
00050         fs << {\cf18 string}.c_str();\par
00051         fs << {\cf22 "\\n"};\par
00052         fs.close();\par
00053 \par
00054         {\cf20 // Store the log entry in memory for future access.}\par
00055         _mlogEntries.push_back(logEntry);\par
00056     \}\par
00057 \par
00058     {\cf18 void} CLog::clear({\cf18 void})\par
00059     \{\par
00060         std::fstream fs;\par
00061         fs.open(_mstrLogFilename, std::ios::out | std::ios::trunc);\par
00062         fs.close();\par
00063         _mlogEntries.clear();\par
00064     \}\par
00065 \par
00066     {\cf18 bool} CLog::deleteLogFile({\cf18 void})\par
00067     \{\par
00068         {\cf17 const} std::filesystem::path file_path(_mstrLogFilename);\par
00069 \par
00070         {\cf19 try}\par
00071         \{\par
00072             {\cf19 if} (std::filesystem::exists(file_path))\par
00073             \{\par
00074                 std::filesystem::remove(file_path);\par
00075                 {\cf20 //std::cout << "File deleted successfully." << std::endl;}\par
00076             \}\par
00077             {\cf19 else}\par
00078             \{\par
00079                 {\cf20 //std::cerr << "File does not exist." << std::endl;}\par
00080             \}\par
00081         \}\par
00082         {\cf19 catch} ({\cf17 const} std::filesystem::filesystem_error& e)\par
00083         \{\par
00084             {\cf20 //std::cerr << "Error deleting file: " << e.what() << std::endl;}\par
00085             std::string strError = {\cf22 "Error deleting file: "};\par
00086             strError += e.what();\par
00087             add(strError);\par
00088             {\cf19 return} {\cf17 false};\par
00089         \}\par
00090         {\cf19 return} {\cf17 true};\par
00091     \}\par
00092 \par
00093     {\cf18 void} CLog::setLogFileName({\cf17 const} std::string& strLogFileName)\par
00094     \{\par
00095         deleteLogFile();\par
00096 \par
00097         _mstrLogFilename = strLogFileName;\par
00098         clear();\par
00099     \}\par
00100 \par
00101     {\cf18 size_t} CLog::getNumEntries({\cf18 void}){\cf17  const}\par
00102 {\cf17     }\{\par
00103         {\cf19 return} _mlogEntries.size();\par
00104     \}\par
00105 \par
00106     std::string CLog::getEntryText({\cf18 size_t} entryIndex){\cf17  const}\par
00107 {\cf17     }\{\par
00108         ThrowIfTrue(entryIndex >= _mlogEntries.size(), {\cf22 "CLog::getEntryText() with given index of "} + std::to_string(entryIndex) + {\cf22 " failed as given index is invalid."});\par
00109         {\cf19 return} _mlogEntries[entryIndex].strText;\par
00110     \}\par
00111 \par
00112     std::string CLog::getEntryTime({\cf18 size_t} entryIndex){\cf17  const}\par
00113 {\cf17     }\{\par
00114         ThrowIfTrue(entryIndex >= _mlogEntries.size(), {\cf22 "CLog::getEntryTime() with given index of "} + std::to_string(entryIndex) + {\cf22 " failed as given index is invalid."});\par
00115         {\cf19 return} _mlogEntries[entryIndex].strTime;\par
00116     \}\par
00117 \par
00118     {\cf18 void} CLog::getEntryTimes({\cf18 size_t} entryIndex, {\cf18 float}& fSecondsOut, {\cf18 int}& iMinutesOut, {\cf18 int}& iHoursOut, {\cf18 int}& iDaysOut, {\cf18 int}& iWeeksOut){\cf17  const}\par
00119 {\cf17     }\{\par
00120         ThrowIfTrue(entryIndex >= _mlogEntries.size(), {\cf22 "CLog::getEntryTimes() with given index of "} + std::to_string(entryIndex) + {\cf22 " failed as given index is invalid."});\par
00121         fSecondsOut = _mlogEntries[entryIndex].fTimeSeconds;\par
00122         iMinutesOut = _mlogEntries[entryIndex].iTimeMin;\par
00123         iHoursOut = _mlogEntries[entryIndex].iTimeHours;\par
00124         iDaysOut = _mlogEntries[entryIndex].iTimeDays;\par
00125         iWeeksOut = _mlogEntries[entryIndex].iTimeWeeks;\par
00126     \}\par
00127 \par
00128     CLogEntry CLog::getEntry({\cf18 size_t} entryIndex){\cf17  const}\par
00129 {\cf17     }\{\par
00130         ThrowIfTrue(entryIndex >= _mlogEntries.size(), {\cf22 "CLog::getEntry() with given index of "} + std::to_string(entryIndex) + {\cf22 " failed as given index is invalid."});\par
00131         {\cf19 return} _mlogEntries[entryIndex];\par
00132     \}\par
00133 \par
00134 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Logging.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Logging.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Logging.h}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various logging code. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Utilities.h"}\par
{\f2 #include "Timer.h"}\par
{\f2 #include <fstream>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CLogEntry}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Log entry object which holds information about a single log entry. Used by the {\b CLog} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CLog}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logging of text to a text file. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various logging code. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b Logging.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Logging.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Logging.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Logging.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef LOGGING_H}\par
00007 {\cf21 #define LOGGING_H}\par
00008 \par
00009 {\cf21 #include "Utilities.h"}\par
00010 {\cf21 #include "Timer.h"}\par
00011 {\cf20 //#include "vector3f.h"}\par
00012 {\cf20 //#include "openGLExtensions.h"}\par
00013 \par
00014 {\cf21 #include <fstream>}\par
00015 {\cf21 #include <string>}\par
00016 {\cf21 #include <vector>}\par
00017 \par
00018 {\cf17 namespace }DCL\par
00019 \{\par
00023     {\cf17 class }CLogEntry\par
00024     \{\par
00025     {\cf17 public}:\par
00026         CLogEntry();\par
00027 \par
00028         std::string strText;    \par
00029         {\cf18 float} fTimeSeconds;     \par
00030         {\cf18 int} iTimeMin;           \par
00031         {\cf18 int} iTimeHours;         \par
00032         {\cf18 int} iTimeDays;          \par
00033         {\cf18 int} iTimeWeeks;         \par
00034         std::string strTime;    \par
00035 \par
00036     \};\par
00037 \par
00066     {\cf17 class }CLog\par
00067     \{\par
00068     {\cf17 public}:\par
00072         CLog();\par
00073 \par
00077         {\cf18 void} add({\cf17 const} std::string& {\cf18 string});\par
00078 \par
00080         {\cf18 void} clear({\cf18 void});\par
00081 \par
00088         {\cf18 bool} deleteLogFile({\cf18 void});\par
00089 \par
00096         {\cf18 void} setLogFileName({\cf17 const} std::string& strFilename = {\cf22 "log.txt"});\par
00097 \par
00101         {\cf18 size_t} getNumEntries({\cf18 void}) {\cf17 const};\par
00102 \par
00109         std::string getEntryText({\cf18 size_t} entryIndex) {\cf17 const};\par
00110 \par
00117         std::string getEntryTime({\cf18 size_t} entryIndex) {\cf17 const};\par
00118 \par
00129         {\cf18 void} getEntryTimes({\cf18 size_t} entryIndex, {\cf18 float} &fSecondsOut, {\cf18 int} &iMinutesOut, {\cf18 int} &iHoursOut, {\cf18 int} &iDaysOut, {\cf18 int} &iWeeksOut) {\cf17 const};\par
00130 \par
00137         CLogEntry getEntry({\cf18 size_t} entryIndex) {\cf17 const};\par
00138 \par
00139     {\cf17 private}:\par
00140         std::string _mstrLogFilename;           \par
00141         std::vector<CLogEntry> _mlogEntries;    \par
00142         CTimer _timer;                          \par
00143     \};\par
00144 \par
00145 \}   {\cf20 // namespace DCL}\par
00146 \par
00147 {\cf21 #endif }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Multithreading.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Multithreading.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Multithreading.cpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Multithreading.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005 \par
00006 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Multithreading.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Multithreading.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Multithreading.h}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains multithreaded related code. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains multithreaded related code. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b Multithreading.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Multithreading.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Multithreading.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Multithreading.h}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef MULTITHREADING_H}\par
00007 {\cf21 #define MULTITHREADING_H}\par
00008 \par
00009 {\cf17 namespace }DCL\par
00010 \{\par
00011 \par
00012 \}   {\cf20 // namespace DCL}\par
00013 \par
00014 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Profiler.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Profiler.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Profiler.cpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Profiler.h"}\par
00002 {\cf21 #include "Exceptions.h"}\par
00003 \par
00004 {\cf21 #include <algorithm>}\par
00005 \par
00006 {\cf17 namespace }DCL\par
00007 \{\par
00008     CProfiler::CProfiler()\par
00009     \{\par
00010         reset();\par
00011     \}\par
00012 \par
00013     {\cf18 void} CProfiler::reset({\cf18 void})\par
00014     \{\par
00015         {\cf20 // Remove all sections}\par
00016         _mmapSections.clear();\par
00017 \par
00018         _mfUpdateResultsText = 0.0f;\par
00019     \}\par
00020 \par
00021     {\cf18 void} CProfiler::begin({\cf17 const} std::string& strSectionName)\par
00022     \{\par
00023         {\cf20 // Add named section if it doesn't exist.}\par
00024         {\cf17 auto} it = _mmapSections.find(strSectionName);\par
00025         {\cf19 if} (_mmapSections.end() == it)\par
00026         \{\par
00027             SSection newSection;\par
00028             newSection.dAccumulatedTimeInSeconds = 0;\par
00029             newSection.iBeginCalledCount = 0;\par
00030             _mmapSections[strSectionName] = newSection;\par
00031             it = _mmapSections.find(strSectionName);\par
00032         \}\par
00033 \par
00034         {\cf20 // If this section is "main", then reset all sections}\par
00035         {\cf19 if} ({\cf22 "main"} == strSectionName)\par
00036         \{\par
00037             {\cf17 auto} it2 = _mmapSections.begin();\par
00038             {\cf19 while} (it2 != _mmapSections.end())\par
00039             \{\par
00040                 it2->second.dAccumulatedTimeInSeconds = 0;\par
00041                 it2->second.iBeginCalledCount = 0;\par
00042                 it2++;\par
00043             \}\par
00044         \}\par
00045 \par
00046         it->second.timer.update();\par
00047         it->second.iBeginCalledCount++;\par
00048         {\cf19 if} (it->second.iBeginCalledCount == 1)\par
00049             it->second.dAccumulatedTimeInSeconds = 0;\par
00050     \}\par
00051 \par
00052     {\cf18 void} CProfiler::end({\cf17 const} std::string& strSectionName)\par
00053     \{\par
00054         {\cf20 // If named section doesn't exist, throw an exception.}\par
00055         {\cf17 auto} it = _mmapSections.find(strSectionName);\par
00056         ThrowIfTrue(_mmapSections.end() == it, {\cf22 "CProfiler::end(\\""} + strSectionName + {\cf22 "\\") failed. The named section doesn't exist."});\par
00057 \par
00058         {\cf20 // Update this section's accumulated time}\par
00059         it->second.timer.update();\par
00060         it->second.dAccumulatedTimeInSeconds += it->second.timer.getSecondsPast();\par
00061 \par
00062         {\cf20 // If this section is "main", update the cached results.}\par
00063         {\cf19 if} ({\cf22 "main"} == strSectionName)\par
00064         \{\par
00065             _mvResultsCached.clear();\par
00066             _mvResultsCached = getResults({\cf17 false});\par
00067         \}\par
00068     \}\par
00069 \par
00070     {\cf18 double} CProfiler::getSectionTime({\cf17 const} std::string& strSectionName)\par
00071     \{\par
00072         {\cf20 // If named section doesn't exist, throw an exception.}\par
00073         {\cf17 auto} it = _mmapSections.find(strSectionName);\par
00074         ThrowIfTrue(_mmapSections.end() == it, {\cf22 "CProfiler::getSectionTime(\\""} + strSectionName + {\cf22 "\\") failed. The named section doesn't exist."});\par
00075         {\cf19 return} it->second.dAccumulatedTimeInSeconds;\par
00076     \}\par
00077 \par
00078     {\cf18 size_t} CProfiler::getSectionNumber({\cf18 void})\par
00079     \{\par
00080         {\cf19 return} _mmapSections.size();\par
00081     \}\par
00082 \par
00084     {\cf18 bool} sortByVal({\cf17 const} std::pair<std::string, CProfiler::SSection>& a, {\cf17 const} std::pair<std::string, CProfiler::SSection>& b)\par
00085     \{\par
00086         {\cf19 return} (a.second.dAccumulatedTimeInSeconds > b.second.dAccumulatedTimeInSeconds);\par
00087     \}\par
00088 \par
00089     std::vector<SProfilerResults> CProfiler::getResults({\cf18 bool} bReturnCachedResults)\par
00090     \{\par
00091         {\cf19 if} (bReturnCachedResults)\par
00092         \{\par
00093             {\cf19 return} _mvResultsCached;\par
00094         \}\par
00095 \par
00096         {\cf20 // Will hold the final results}\par
00097         std::vector<SProfilerResults> vResults;\par
00098 \par
00099         {\cf20 // Create a vector of pairs}\par
00100         std::vector<std::pair<std::string, CProfiler::SSection>> vec;\par
00101 \par
00102         {\cf20 // Copy key-value pairs from the map to the vector}\par
00103         std::map<std::string, CProfiler::SSection> ::iterator it;\par
00104         {\cf19 for} (it = _mmapSections.begin(); it != _mmapSections.end(); it++)\par
00105         \{\par
00106             vec.push_back(make_pair(it->first, it->second));\par
00107         \}\par
00108 \par
00109         {\cf20 // Sort the vector by increasing order of its pair's second value's dAccumulatedTimeInSeconds value.}\par
00110         sort(vec.begin(), vec.end(), sortByVal);\par
00111 \par
00112         {\cf20 // Find main and get it's accumulated time}\par
00113         {\cf17 auto} itMain = _mmapSections.find({\cf22 "main"});\par
00114         ThrowIfTrue(_mmapSections.end() == itMain, {\cf22 "CProfiler::getResults() failed. The \\"main\\" section doesn't exist."});\par
00115         {\cf18 double} dMainTime = itMain->second.dAccumulatedTimeInSeconds;\par
00116 \par
00117         {\cf20 // Prevent divide by zero error below.}\par
00118         {\cf19 if} (dMainTime <= 0)\par
00119             dMainTime = 0.00001;\par
00120 \par
00121         {\cf20 // Now copy vector to vector and return}\par
00122         {\cf19 for} ({\cf18 size_t} i = 0; i < vec.size(); i++)\par
00123         \{\par
00124             SProfilerResults results;\par
00125             results.dAccumulatedTimeSeconds = vec[i].second.dAccumulatedTimeInSeconds;\par
00126             results.fPercentageOfMain = float(results.dAccumulatedTimeSeconds / dMainTime);\par
00127             results.fPercentageOfMain *= 100;\par
00128             results.strSectionName = vec[i].first;\par
00129             vResults.push_back(results);\par
00130         \}\par
00131         {\cf19 return} vResults;\par
00132     \}\par
00133 \par
00134     {\cf20 /*}\par
00135 {\cf20     void CProfiler::printResults(void)}\par
00136 {\cf20     \{}\par
00137 {\cf20         CResourceFont* pFont = x->pResource->getFont(x->pResource->defaultRes.font_default);}\par
00138 {\cf20         float fTextHeight = pFont->getTextHeight() + 2;}\par
00139 {\cf20 }\par
00140 {\cf20         // Update text string vector with results every so often}\par
00141 {\cf20         _mTimerMinimal.update();}\par
00142 {\cf20         _mfUpdateResultsText -= (float)_mTimerMinimal.getSecondsPast();}\par
00143 {\cf20         if (_mfUpdateResultsText <= 0.0f)}\par
00144 {\cf20         \{}\par
00145 {\cf20             _mfUpdateResultsText = 1.0f;}\par
00146 {\cf20             _mvecstrResultsText.clear();}\par
00147 {\cf20 }\par
00148 {\cf20             // Get sorted vector of results}\par
00149 {\cf20             std::vector<SProfilerResults> vResults = getResults();}\par
00150 {\cf20             _mvecstrResultsText.push_back("CProfiler::printResults()");}\par
00151 {\cf20             for (size_t i = 0; i < vResults.size(); i++)}\par
00152 {\cf20             \{}\par
00153 {\cf20                 std::string strTxt;}\par
00154 {\cf20                 StringUtils::appendFloat(strTxt, vResults[i].fPercentageOfMain, 1);}\par
00155 {\cf20                 strTxt += "% of main. (";}\par
00156 {\cf20                 StringUtils::appendDouble(strTxt, 1000 * vResults[i].dAccumulatedTimeSeconds, 4);}\par
00157 {\cf20                 strTxt += ") ms. \\"";}\par
00158 {\cf20                 strTxt += vResults[i].strSectionName;}\par
00159 {\cf20                 strTxt += "\\"";}\par
00160 {\cf20                 _mvecstrResultsText.push_back(strTxt);}\par
00161 {\cf20             \}}\par
00162 {\cf20         \}}\par
00163 {\cf20 }\par
00164 {\cf20         CVector2f vTextPos(5, 5);}\par
00165 {\cf20         for (size_t i = 0; i < _mvecstrResultsText.size(); i++)}\par
00166 {\cf20         \{}\par
00167 {\cf20             pFont->print(_mvecstrResultsText[i], int(vTextPos.x), int(vTextPos.y), x->pWindow->getWidth(), x->pWindow->getHeight());}\par
00168 {\cf20             vTextPos.y += fTextHeight;}\par
00169 {\cf20         \}}\par
00170 {\cf20     \}}\par
00171 {\cf20     */}\par
00172 \par
00173 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Profiler.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Profiler.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Profiler.h}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a simple profiler for timing various sections of code. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TimerMinimal.h"}\par
{\f2 #include <map>}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DCL::SProfilerResults}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used by {\b CProfiler} class to return a vector of this struct containing the profiler's results. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CProfiler}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to deal with time profiling. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DCL::CProfiler::SSection}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Members needed by each code section. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a simple profiler for timing various sections of code. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b Profiler.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Profiler.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Profiler.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Profiler.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef PROFILER_H}\par
00007 {\cf21 #define PROFILER_H}\par
00008 \par
00009 {\cf21 #include "TimerMinimal.h"}\par
00010 \par
00011 {\cf21 #include <map>}\par
00012 {\cf21 #include <string>}\par
00013 \par
00014 {\cf17 namespace }DCL\par
00015 \{\par
00017     {\cf17 struct }SProfilerResults\par
00018     \{\par
00019         std::string strSectionName;     \par
00020         {\cf18 double} dAccumulatedTimeSeconds; \par
00021         {\cf18 float} fPercentageOfMain;        \par
00022     \};\par
00023 \par
00048     {\cf17 class }CProfiler\par
00049     \{\par
00050     {\cf17 public}:\par
00051         CProfiler();\par
00052 \par
00058         {\cf18 void} begin({\cf17 const} std::string& strSectionName = {\cf22 "main"});\par
00059 \par
00063         {\cf18 void} end({\cf17 const} std::string& strSectionName = {\cf22 "main"});\par
00064 \par
00066         {\cf18 void} reset({\cf18 void});\par
00067 \par
00074         {\cf18 double} getSectionTime({\cf17 const} std::string& strSectionName = {\cf22 "main"});\par
00075 \par
00079         {\cf18 size_t} getSectionNumber({\cf18 void});\par
00080 \par
00090         std::vector<SProfilerResults> getResults({\cf18 bool} bReturnCachedResults = {\cf17 true});\par
00091 \par
00092         {\cf20 /*}\par
00097         void printResults(void);\par
00098         */\par
00099 \par
00101         {\cf17 struct }SSection\par
00102         \{\par
00103             CTimerMinimal timer;                \par
00104             {\cf18 double} dAccumulatedTimeInSeconds;   \par
00105             {\cf18 int} iBeginCalledCount;              \par
00106         \};\par
00107 \par
00108 \par
00109     {\cf17 private}:\par
00110         std::map<std::string, SSection> _mmapSections;  \par
00111         {\cf18 float} _mfUpdateResultsText;                     \par
00112         std::vector<std::string> _mvecstrResultsText;   \par
00113 \par
00114         CTimerMinimal _mTimerMinimal;\par
00115 \par
00117         std::vector<SProfilerResults> _mvResultsCached;\par
00118     \};\par
00119 \}   {\cf20 // namespace DCL}\par
00120 \par
00121 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Singleton.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Singleton.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Singleton.h}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the template class CSingleton which to derive any classes we wish to act as singletons. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CSingleton< T >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton class to inherit from. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the template class CSingleton which to derive any classes we wish to act as singletons. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b Singleton.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Singleton.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Singleton.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Singleton.h}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef SINGLETON_H}\par
00007 {\cf21 #define SINGLETON_H}\par
00008 \par
00009 {\cf17 namespace }DCL\par
00010 \{\par
00028     {\cf17 template} <{\cf17 class} T>\par
00029     {\cf17 class }CSingleton\par
00030     \{\par
00031     {\cf17 public}:\par
00032         {\cf17 virtual} ~CSingleton()\par
00033         \{\par
00034             {\cf19 if} (pInstance)\par
00035             \{\par
00036                 {\cf17 delete} pInstance;\par
00037                 pInstance = 0;\par
00038             \}\par
00039         \}\par
00040 \par
00046         {\cf17 static} T* getPointer({\cf18 void})\par
00047         \{\par
00048             {\cf19 if} (!pInstance)\par
00049             \{\par
00050                 pInstance = {\cf17 new} T();\par
00051             \}\par
00052             {\cf19 return} pInstance;\par
00053         \}\par
00054 \par
00055     {\cf17 protected}:\par
00056         {\cf17 static} T* pInstance;    \par
00057     \};\par
00058     {\cf17 template} <{\cf17 class} T> T* CSingleton<T>::pInstance = 0;\par
00059 \par
00060 \}   {\cf20 // namespace DCL}\par
00061 \par
00062 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StringUtils.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/StringUtils.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/StringUtils.cpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "StringUtils.h"}\par
00002 {\cf21 #include "Exceptions.h"}\par
00003 {\cf21 #include "Logging.h"}\par
00004 \par
00005 {\cf21 #include <filesystem>}\par
00006 {\cf21 #define NOMINMAX                }{\cf20 // Set this before including windows.h so that the min/max macros located in algorithm header take precedence}\par
00007 {\cf21 #define WIN32_LEAN_AND_MEAN     }{\cf20 // Exclude rarely used stuff from Windows headers}\par
00008 {\cf21 #include <Windows.h>}\par
00009 \par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00013     {\cf17 namespace }StringUtils\par
00014     \{\par
00015 \par
00016         std::wstring stringToWide({\cf17 const} std::string& {\cf18 string})\par
00017         \{\par
00018             {\cf19 if} ({\cf18 string}.empty())\par
00019                 {\cf19 return} std::wstring();\par
00020             {\cf18 int} iSize = MultiByteToWideChar(CP_UTF8, 0, &{\cf18 string}[0], ({\cf18 int}){\cf18 string}.size(), NULL, 0);\par
00021             std::wstring wstrOut(iSize, 0);\par
00022             MultiByteToWideChar(CP_UTF8, 0, &{\cf18 string}[0], ({\cf18 int}){\cf18 string}.size(), &wstrOut[0], iSize);\par
00023             {\cf19 return} wstrOut;\par
00024         \}\par
00025 \par
00026         std::string wideToString({\cf17 const} std::wstring& wstring)\par
00027         \{\par
00028             {\cf19 if} (wstring.empty())\par
00029                 {\cf19 return} std::string();\par
00030             {\cf18 int} iSize = WideCharToMultiByte(CP_UTF8, 0, &wstring[0], ({\cf18 int})wstring.size(), NULL, 0, NULL, NULL);\par
00031             std::string strOut(iSize, 0);\par
00032             WideCharToMultiByte(CP_UTF8, 0, &wstring[0], ({\cf18 int})wstring.size(), &strOut[0], iSize, NULL, NULL);\par
00033             {\cf19 return} strOut;\par
00034         \}\par
00035 \par
00036         std::vector<std::string> getFilesInDir({\cf17 const} std::string& strDirectory, {\cf18 bool} bRecursiveDirs)\par
00037         \{\par
00038             std::vector<std::string> filenames;\par
00039             {\cf19 if} (bRecursiveDirs)\par
00040             \{\par
00041                 {\cf19 for} ({\cf17 const} {\cf17 auto}& filename : std::filesystem::recursive_directory_iterator(strDirectory))\par
00042                 \{\par
00043                     {\cf19 if} (filename.is_regular_file())\par
00044                         filenames.push_back(filename.path().string());\par
00045                 \}\par
00046             \}\par
00047             {\cf19 else}\par
00048             \{\par
00049                 {\cf19 for} ({\cf17 const} {\cf17 auto}& filename : std::filesystem::directory_iterator(strDirectory))\par
00050                 \{\par
00051                     {\cf19 if} (filename.is_regular_file())\par
00052                         filenames.push_back(filename.path().string());\par
00053                 \}\par
00054             \}\par
00055             {\cf19 return} filenames;\par
00056         \}\par
00057 \par
00058         std::vector<std::string> getFilesInDir({\cf17 const} std::string& strDirectory, {\cf17 const} std::string& ext, {\cf18 bool} bRecursiveDirs)\par
00059         \{\par
00060             {\cf20 // Make sure the given extension has the "." character}\par
00061             ThrowIfTrue(0 == ext.length(), {\cf22 "CStringHelper::getFilesInDir() extension has length of zero."});\par
00062             std::string strExt;\par
00063             {\cf19 if} (ext.c_str()[0] != {\cf23 '.'})\par
00064                 strExt.append({\cf22 "."});\par
00065             strExt.append(ext);\par
00066 \par
00067             std::vector<std::string> filenames;\par
00068             {\cf19 if} (bRecursiveDirs)\par
00069             \{\par
00070                 {\cf19 for} ({\cf17 const} {\cf17 auto}& filename : std::filesystem::recursive_directory_iterator(strDirectory))\par
00071                 \{\par
00072                     {\cf19 if} (filename.is_regular_file())\par
00073                     \{\par
00074                         {\cf19 if} (filename.path().extension() == strExt)\par
00075                             filenames.push_back(filename.path().string());\par
00076                     \}\par
00077                 \}\par
00078             \}\par
00079             {\cf19 else}\par
00080             \{\par
00081                 {\cf19 for} ({\cf17 const} {\cf17 auto}& filename : std::filesystem::directory_iterator(strDirectory))\par
00082                 \{\par
00083                     {\cf19 if} (filename.is_regular_file())\par
00084                     \{\par
00085                         {\cf19 if} (filename.path().extension() == strExt)\par
00086                             filenames.push_back(filename.path().string());\par
00087                     \}\par
00088                 \}\par
00089             \}\par
00090             {\cf19 return} filenames;\par
00091         \}\par
00092 \par
00093         std::vector<std::string> getDirsInDir({\cf17 const} std::string& strDirectory, {\cf18 bool} bRecursiveDirs)\par
00094         \{\par
00095             std::vector<std::string> dirnames;\par
00096             {\cf19 if} (bRecursiveDirs)\par
00097             \{\par
00098                 {\cf19 for} ({\cf17 const} {\cf17 auto}& dirname : std::filesystem::recursive_directory_iterator(strDirectory))\par
00099                 \{\par
00100                     {\cf19 if} (dirname.is_directory())\par
00101                         dirnames.push_back(dirname.path().string());\par
00102                 \}\par
00103             \}\par
00104             {\cf19 else}\par
00105             \{\par
00106                 {\cf19 for} ({\cf17 const} {\cf17 auto}& dirname : std::filesystem::directory_iterator(strDirectory))\par
00107                 \{\par
00108                     {\cf19 if} (dirname.is_directory())\par
00109                         dirnames.push_back(dirname.path().string());\par
00110                 \}\par
00111             \}\par
00112             {\cf19 return} dirnames;\par
00113         \}\par
00114 \par
00115         std::string getCurrentDirectory({\cf18 void})\par
00116         \{\par
00117             {\cf19 return} std::filesystem::current_path().string();\par
00118         \}\par
00119 \par
00120         {\cf18 void} stringToLowercase(std::string& str)\par
00121         \{\par
00122             std::transform(str.begin(), str.end(), str.begin(), []({\cf18 unsigned} {\cf18 char} c) \{ return std::tolower(c); \});\par
00123         \}\par
00124 \par
00125         std::string addFilenameExtension({\cf17 const} std::string& strFilenameExtension, {\cf17 const} std::string& strFilename)\par
00126         \{\par
00127             {\cf20 // Make sure valid values given.}\par
00128             ThrowIfTrue(0 == strFilenameExtension.length(), {\cf22 "CStringHelper::addFilenameExtension() failed. Given extension name of zero length."});\par
00129             ThrowIfTrue(0 == strFilename.length(), {\cf22 "CStringHelper::addFilenameExtension() failed. Given file name of zero length."});\par
00130 \par
00131             {\cf20 // Append "." to extension if needed}\par
00132             std::string strExt = strFilenameExtension;\par
00133             {\cf19 if} (strExt.c_str()[0] != {\cf23 '.'})\par
00134             \{\par
00135                 std::string::iterator itBegin = strExt.begin();\par
00136                 strExt.insert(itBegin, {\cf23 '.'});\par
00137             \}\par
00138             std::string strFile = strFilename;\par
00139             {\cf20 // Find last position of "." in given file name and remove everything after it}\par
00140             {\cf17 auto} {\cf17 const} pos = strFile.find_last_of({\cf23 '.'});\par
00141             {\cf19 if} (pos != std::string::npos)   {\cf20 // If "." found}\par
00142             \{\par
00143                 {\cf20 // Remove "." and all following text}\par
00144                 strFile.erase(pos, strFile.length() - pos);\par
00145             \}\par
00146             {\cf20 // Append extension to filename}\par
00147             strFile.append(strExt);\par
00148 \par
00149             {\cf20 // Make all lowercase}\par
00150             stringToLowercase(strFile);\par
00151             {\cf19 return} strFile;\par
00152         \}\par
00153 \par
00154         {\cf18 void} appendInt(std::string& {\cf18 string}, {\cf18 int} iInt)\par
00155         \{\par
00156             {\cf18 string} += std::to_string(iInt);\par
00157         \}\par
00158 \par
00159         {\cf18 void} appendUInt(std::string& {\cf18 string}, {\cf18 unsigned} {\cf18 int} uiInt)\par
00160         \{\par
00161             {\cf18 string} += std::to_string(uiInt);\par
00162         \}\par
00163 \par
00164         {\cf18 void} appendFloat(std::string& {\cf18 string}, {\cf18 float} fValue, {\cf18 unsigned} {\cf18 int} uiNumDecimalPoints)\par
00165         \{\par
00166             {\cf19 switch} (uiNumDecimalPoints)\par
00167             \{\par
00168             {\cf19 case} 0: {\cf18 string} += std::format({\cf22 "\{:.0f\}"}, fValue);    {\cf19 break};\par
00169             {\cf19 case} 1: {\cf18 string} += std::format({\cf22 "\{:.1f\}"}, fValue);    {\cf19 break};\par
00170             {\cf19 case} 2: {\cf18 string} += std::format({\cf22 "\{:.2f\}"}, fValue);    {\cf19 break};\par
00171             {\cf19 case} 3: {\cf18 string} += std::format({\cf22 "\{:.3f\}"}, fValue);    {\cf19 break};\par
00172             {\cf19 case} 4: {\cf18 string} += std::format({\cf22 "\{:.4f\}"}, fValue);    {\cf19 break};\par
00173             {\cf19 case} 5: {\cf18 string} += std::format({\cf22 "\{:.5f\}"}, fValue);    {\cf19 break};\par
00174             {\cf19 case} 6: {\cf18 string} += std::format({\cf22 "\{:.6f\}"}, fValue);    {\cf19 break};\par
00175             {\cf19 case} 7: {\cf18 string} += std::format({\cf22 "\{:.7f\}"}, fValue);    {\cf19 break};\par
00176             {\cf19 case} 8: {\cf18 string} += std::format({\cf22 "\{:.8f\}"}, fValue);    {\cf19 break};\par
00177             {\cf19 case} 9: {\cf18 string} += std::format({\cf22 "\{:.9f\}"}, fValue);    {\cf19 break};\par
00178             {\cf19 default}:{\cf18 string} += std::format({\cf22 "\{:.2f\}"}, fValue);\par
00179             \}\par
00180         \}\par
00181 \par
00182         {\cf18 void} appendDouble(std::string& {\cf18 string}, {\cf18 double} dValue, {\cf18 unsigned} {\cf18 int} uiNumDecimalPoints)\par
00183         \{\par
00184             {\cf19 switch} (uiNumDecimalPoints)\par
00185             \{\par
00186             {\cf19 case} 0: {\cf18 string} += std::format({\cf22 "\{:.0f\}"}, dValue);    {\cf19 break};\par
00187             {\cf19 case} 1: {\cf18 string} += std::format({\cf22 "\{:.1f\}"}, dValue);    {\cf19 break};\par
00188             {\cf19 case} 2: {\cf18 string} += std::format({\cf22 "\{:.2f\}"}, dValue);    {\cf19 break};\par
00189             {\cf19 case} 3: {\cf18 string} += std::format({\cf22 "\{:.3f\}"}, dValue);    {\cf19 break};\par
00190             {\cf19 case} 4: {\cf18 string} += std::format({\cf22 "\{:.4f\}"}, dValue);    {\cf19 break};\par
00191             {\cf19 case} 5: {\cf18 string} += std::format({\cf22 "\{:.5f\}"}, dValue);    {\cf19 break};\par
00192             {\cf19 case} 6: {\cf18 string} += std::format({\cf22 "\{:.6f\}"}, dValue);    {\cf19 break};\par
00193             {\cf19 case} 7: {\cf18 string} += std::format({\cf22 "\{:.7f\}"}, dValue);    {\cf19 break};\par
00194             {\cf19 case} 8: {\cf18 string} += std::format({\cf22 "\{:.8f\}"}, dValue);    {\cf19 break};\par
00195             {\cf19 case} 9: {\cf18 string} += std::format({\cf22 "\{:.9f\}"}, dValue);    {\cf19 break};\par
00196             {\cf19 default}:{\cf18 string} += std::format({\cf22 "\{:.2f\}"}, dValue);\par
00197             \}\par
00198         \}\par
00199 {\cf20 /*}\par
00200 {\cf20         void appendCVector3f(std::string& string, const CVector3f& vector, unsigned int uiNumDecimalPoints, const std::string& strSeperatorText)}\par
00201 {\cf20         \{}\par
00202 {\cf20             std::string strTmp;}\par
00203 {\cf20             appendFloat(strTmp, vector.x, uiNumDecimalPoints);}\par
00204 {\cf20             string += strTmp;}\par
00205 {\cf20             string += strSeperatorText;}\par
00206 {\cf20 }\par
00207 {\cf20             strTmp.clear();}\par
00208 {\cf20             appendFloat(strTmp, vector.y, uiNumDecimalPoints);}\par
00209 {\cf20             string += strTmp;}\par
00210 {\cf20             string += strSeperatorText;}\par
00211 {\cf20 }\par
00212 {\cf20             strTmp.clear();}\par
00213 {\cf20             appendFloat(strTmp, vector.z, uiNumDecimalPoints);}\par
00214 {\cf20             string += strTmp;}\par
00215 {\cf20         \}}\par
00216 {\cf20 */}\par
00217         std::vector<std::string> splitString({\cf17 const} std::string& {\cf18 string}, {\cf17 const} std::string& strSplitChars)\par
00218         \{\par
00219             std::vector<std::string> out;\par
00220 \par
00221             {\cf20 // If no strSplitChars found, simply add the entire string and return the result}\par
00222             {\cf18 size_t} pos = {\cf18 string}.find(strSplitChars, 0);\par
00223             {\cf19 if} (std::string::npos == pos)\par
00224             \{\par
00225                 out.push_back({\cf18 string});\par
00226                 {\cf19 return} out;\par
00227             \}\par
00228 \par
00229             {\cf20 // If we get here, strSplitChars has been found in the string}\par
00230             std::string strLine;\par
00231             std::string strAll = string;\par
00232             {\cf19 while} (std::string::npos != pos)\par
00233             \{\par
00234                 {\cf20 // Copy character upto the position of the found strSplitChars into strLine}\par
00235                 strLine.assign(strAll, 0, pos);\par
00236 \par
00237                 {\cf20 // Add the line to the output}\par
00238                 out.push_back(strLine);\par
00239 \par
00240                 {\cf20 // Reset strLine}\par
00241                 strLine.clear();\par
00242 \par
00243                 {\cf20 // Remove all characters including the strSplitChars from strAll}\par
00244                 strAll.erase(0, pos + strSplitChars.length());\par
00245 \par
00246                 {\cf20 // Find next position of strSplitChars in strAll}\par
00247                 pos = strAll.find(strSplitChars, 0);\par
00248             \}\par
00249             {\cf20 // If strAll still contains characters, add them to the vector}\par
00250             {\cf19 if} (strAll.length())\par
00251             \{\par
00252                 out.push_back(strAll);\par
00253             \}\par
00254 \par
00255             {\cf19 return} out;\par
00256         \}\par
00257 \par
00258         {\cf18 bool} representsNumber({\cf17 const} std::string& {\cf18 string})\par
00259         \{\par
00260             {\cf19 return} (std::all_of({\cf18 string}.begin(), {\cf18 string}.end(), ::isdigit));\par
00261         \}\par
00262 \par
00263         {\cf18 void} stringWrite({\cf17 const} std::string& strString, std::ofstream& file)\par
00264         \{\par
00265             ThrowIfFalse(file.is_open(), {\cf22 "StringUtils::stringWrite() failed. The given ofstream is not open."});\par
00266             {\cf18 size_t} size = strString.size();\par
00267             file.write(({\cf18 char}*)&size, {\cf17 sizeof}(size));\par
00268             file.write(strString.c_str(), size);\par
00269             ThrowIfFalse(file.good(), {\cf22 "StringUtils::stringWrite() failed. The ofstream is not good."});\par
00270         \}\par
00271 \par
00272         {\cf18 void} stringRead(std::string& strString, std::ifstream& file)\par
00273         \{\par
00274             ThrowIfFalse(file.is_open(), {\cf22 "StringUtils::stringRead() failed. The given ofstream is not open."});\par
00275             strString.clear();\par
00276             {\cf18 size_t} size;\par
00277             file.read(({\cf18 char}*)&size, {\cf17 sizeof}(size));\par
00278             strString.resize(size);\par
00279             {\cf20 //file.read(&strString[0], size);}\par
00280             file.read(({\cf18 char}*)strString.c_str(), size);\par
00281             ThrowIfFalse(file.good(), {\cf22 "StringUtils::stringRead() failed. The ifstream is not good."});\par
00282         \}\par
00283 \par
00284         std::string blenderAnimFilename({\cf17 const} std::string& strBasename, {\cf17 const} std::string& strExtension, {\cf18 int} iFrameNumber)\par
00285         \{\par
00286             ThrowIfTrue(iFrameNumber < 0 || iFrameNumber > 9999, {\cf22 "StringUtils::blenderAnimFilename() given invalid iFrameNumber."});\par
00287             std::string output;\par
00288             output = strBasename;\par
00289             {\cf19 if} (iFrameNumber < 10)\par
00290             \{\par
00291                 output += {\cf22 "000"};\par
00292                 output += std::to_string(iFrameNumber);\par
00293             \}\par
00294             {\cf19 else} {\cf19 if} (iFrameNumber < 100)\par
00295             \{\par
00296                 output += {\cf22 "00"};\par
00297                 output += std::to_string(iFrameNumber);\par
00298             \}\par
00299             {\cf19 else} {\cf19 if} (iFrameNumber < 1000)\par
00300             \{\par
00301                 output += {\cf22 "0"};\par
00302                 output += std::to_string(iFrameNumber);\par
00303             \}\par
00304             {\cf19 else}\par
00305             \{\par
00306                 output += std::to_string(iFrameNumber);\par
00307             \}\par
00308 \par
00309             {\cf20 // Append "." to extension if needed}\par
00310             std::string strExt = strExtension;\par
00311             {\cf19 if} (strExt.c_str()[0] != {\cf23 '.'})\par
00312             \{\par
00313                 std::string::iterator itBegin = strExt.begin();\par
00314                 strExt.insert(itBegin, {\cf23 '.'});\par
00315             \}\par
00316             output += strExt;\par
00317             {\cf19 return} output;\par
00318         \}\par
00319 \par
00320         {\cf18 float} stringToFloat({\cf17 const} std::string& {\cf18 string})\par
00321         \{\par
00322             {\cf18 float} strfloat = std::stof({\cf18 string});\par
00323             {\cf19 return} strfloat;\par
00324         \}\par
00325 \par
00326         {\cf18 int} stringToInt({\cf17 const} std::string& {\cf18 string})\par
00327         \{\par
00328             {\cf18 int} strInt = std::stoi({\cf18 string});\par
00329             {\cf19 return} strInt;\par
00330         \}\par
00331     \}\par
00332 \par
00333 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/StringUtils.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/StringUtils.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/StringUtils.h}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various string utility functions. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL::StringUtils}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various functions for messing around with strings. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::wstring {\b DCL::StringUtils::stringToWide} (const std::string &string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a string to wide string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b DCL::StringUtils::wideToString} (const std::wstring &wstring)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a wide string to a string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b DCL::StringUtils::getFilesInDir} (const std::string &strDirectory, bool bRecursiveDirs=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of strings holding each filename stored within the given directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b DCL::StringUtils::getFilesInDir} (const std::string &strDirectory, const std::string &ext, bool bRecursiveDirs=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of strings holding each filename stored within the given directory which have the given filename extension. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b DCL::StringUtils::getDirsInDir} (const std::string &strDirectory, bool bRecursiveDirs=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of strings holding each directory stored within the given directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b DCL::StringUtils::getCurrentDirectory} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::StringUtils::stringToLowercase} (std::string &str)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given string to lowercase. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b DCL::StringUtils::addFilenameExtension} (const std::string &strFilenameExtension, const std::string &strFilename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes the given filename and filename extension and adds the given filename extension to the end of the given filename and returns the result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::StringUtils::appendInt} (std::string &string, int iInt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append an integer to given string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::StringUtils::appendUInt} (std::string &string, unsigned int uiInt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append an integer to given string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::StringUtils::appendFloat} (std::string &string, float fValue, unsigned int uiNumDecimalPoints=2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append float to given string with the given number of decimals. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::StringUtils::appendDouble} (std::string &string, double dValue, unsigned int uiNumDecimalPoints=2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append double to given string with the given number of decimals. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b DCL::StringUtils::splitString} (const std::string &string, const std::string &strSplitChars="\\n")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a string, finds each occurrence of strSplitChars and returns a vector of strings which contains strings that are either side of the strSplitChars, with the strSplitChars removed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b DCL::StringUtils::representsNumber} (const std::string &string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given string has nothing but digits. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::StringUtils::stringWrite} (const std::string &strString, std::ofstream &file)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes out a string to an already opened ofstream. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::StringUtils::stringRead} (std::string &strString, std::ifstream &file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b DCL::StringUtils::blenderAnimFilename} (const std::string &strBasename="image", const std::string &strExtension=".png", int iFrameNumber=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blender animation frame filename helper. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b DCL::StringUtils::stringToFloat} (const std::string &string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given string to a float. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b DCL::StringUtils::stringToInt} (const std::string &string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given string to an int. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various string utility functions. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b StringUtils.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StringUtils.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/StringUtils.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/StringUtils.h}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef STRINGUTILS_H}\par
00007 {\cf21 #define STRINGUTILS_H}\par
00008 \par
00009 {\cf20 //#include "vector3f.h"}\par
00010 \par
00011 {\cf21 #include <string>}\par
00012 {\cf21 #include <vector>}\par
00013 \par
00014 {\cf17 namespace }DCL\par
00015 \{\par
00017     {\cf17 namespace }StringUtils\par
00018     \{\par
00023         std::wstring stringToWide({\cf17 const} std::string& {\cf18 string});\par
00024 \par
00029         std::string wideToString({\cf17 const} std::wstring& wstring);\par
00030 \par
00038         std::vector<std::string> getFilesInDir({\cf17 const} std::string& strDirectory, {\cf18 bool} bRecursiveDirs = {\cf17 false});\par
00039 \par
00049         std::vector<std::string> getFilesInDir({\cf17 const} std::string& strDirectory, {\cf17 const} std::string& ext, {\cf18 bool} bRecursiveDirs = {\cf17 false});\par
00050 \par
00058         std::vector<std::string> getDirsInDir({\cf17 const} std::string& strDirectory, {\cf18 bool} bRecursiveDirs = {\cf17 false});\par
00059 \par
00063         std::string getCurrentDirectory({\cf18 void});\par
00064 \par
00068         {\cf18 void} stringToLowercase(std::string& str);\par
00069 \par
00080         std::string addFilenameExtension({\cf17 const} std::string& strFilenameExtension, {\cf17 const} std::string& strFilename);\par
00081 \par
00086         {\cf18 void} appendInt(std::string& {\cf18 string}, {\cf18 int} iInt);\par
00087 \par
00091         {\cf18 void} appendUInt(std::string& {\cf18 string}, {\cf18 unsigned} {\cf18 int} uiInt);\par
00092 \par
00100         {\cf18 void} appendFloat(std::string& {\cf18 string}, {\cf18 float} fValue, {\cf18 unsigned} {\cf18 int} uiNumDecimalPoints = 2);\par
00101 \par
00109         {\cf18 void} appendDouble(std::string& {\cf18 string}, {\cf18 double} dValue, {\cf18 unsigned} {\cf18 int} uiNumDecimalPoints = 2);\par
00110 \par
00111         {\cf20 /*}\par
00122 //      void appendCVector3f(std::string& string, const CVector3f& vector, unsigned int uiNumDecimalPoints = 1, const std::string& strSeperatorText = ", ");\par
00123 */\par
00124 \par
00136         std::vector<std::string> splitString({\cf17 const} std::string& {\cf18 string}, {\cf17 const} std::string& strSplitChars = {\cf22 "\\n"});\par
00137 \par
00142         {\cf18 bool} representsNumber({\cf17 const} std::string& {\cf18 string});\par
00143 \par
00152         {\cf18 void} stringWrite({\cf17 const} std::string& strString, std::ofstream& file);\par
00153 \par
00161         {\cf18 void} stringRead(std::string& strString, std::ifstream& file);\par
00162 \par
00177         std::string blenderAnimFilename({\cf17 const} std::string& strBasename = {\cf22 "image"}, {\cf17 const} std::string& strExtension = {\cf22 ".png"}, {\cf18 int} iFrameNumber = 0);\par
00178 \par
00183         {\cf18 float} stringToFloat({\cf17 const} std::string& {\cf18 string});\par
00184 \par
00189         {\cf18 int} stringToInt({\cf17 const} std::string& {\cf18 string});\par
00190 \par
00191     \}   {\cf20 // namespace StringUtils}\par
00192 \par
00193 \}   {\cf20 // namespace DCL}\par
00194 \par
00195 {\cf21 #endif }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Timer.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Timer.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Timer.cpp}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Timer.h"}\par
00002 \par
00003 {\cf21 #include <thread>}\par
00004 \par
00005 {\cf17 namespace }DCL\par
00006 \{\par
00007     CTimer::CTimer()\par
00008     \{\par
00009         reset();\par
00010     \}\par
00011 \par
00012     {\cf18 void} CTimer::pause({\cf18 void})\par
00013     \{\par
00014         _mbPaused = {\cf17 true};\par
00015     \}\par
00016 \par
00017     {\cf18 void} CTimer::resume({\cf18 void})\par
00018     \{\par
00019         _mbPaused = {\cf17 false};\par
00020     \}\par
00021 \par
00022     {\cf18 float} CTimer::getSecondsPast({\cf18 void}){\cf17  const}\par
00023 {\cf17     }\{\par
00024         {\cf19 if} (_mbPaused)\par
00025             {\cf19 return} 0.0f;\par
00026         {\cf19 return} ({\cf18 float})_mdDeltaSec;\par
00027     \}\par
00028 \par
00029     {\cf18 void} CTimer::update({\cf18 void})\par
00030     \{\par
00031         _mdTimePointNew = std::chrono::steady_clock::now();\par
00032         _mdTimeDeltaSec = _mdTimePointNew - _mdTimePointOld;\par
00033         _mdTimePointOld = _mdTimePointNew;{\cf20 // std::chrono::steady_clock::now();}\par
00034 \par
00035         _mdDeltaSec = _mdTimeDeltaSec.count();\par
00036 \par
00037         {\cf20 // Compute FPS}\par
00038         ++_muiNumFrames;\par
00039         _mdFPSFrameTime += _mdDeltaSec * 1000.0;\par
00040         {\cf19 if} (_mdFPSFrameTime > 0.0)\par
00041         \{\par
00042             _mdFPS = _muiNumFrames * (1000.0 / _mdFPSFrameTime);\par
00043 \par
00044             _muiNumFrames = 0;\par
00045             _mdFPSFrameTime = 0.0;\par
00046         \}\par
00047 \par
00048         {\cf20 // Compute FPS smoothed}\par
00049         _mdFPSAveragedTimeCount += _mdDeltaSec;\par
00050         ++_miFPSAveragedNumCallsPerSec;\par
00051         _mdFPSAveragedAccum += _mdFPS;\par
00052         {\cf19 if} (_mdFPSAveragedTimeCount > _mdFPSAveragedRate)\par
00053         \{\par
00054             {\cf19 if} (_miFPSAveragedNumCallsPerSec < 1)\par
00055                 _miFPSAveragedNumCallsPerSec = 1;\par
00056             _mdFPSAveraged = _mdFPSAveragedAccum / _miFPSAveragedNumCallsPerSec;\par
00057             _mdFPSAveragedTimeCount = 0;\par
00058             _miFPSAveragedNumCallsPerSec = 0;\par
00059             _mdFPSAveragedAccum = 0;\par
00060         \}\par
00061 \par
00062         {\cf20 // Runtime}\par
00063         _mdRuntimeInSeconds += _mdDeltaSec;\par
00064     \}\par
00065 \par
00066     {\cf18 void} CTimer::sleep({\cf18 unsigned} {\cf18 int} uiMilliseconds){\cf17  const}\par
00067 {\cf17     }\{\par
00068         {\cf20 //Sleep(uiMilliseconds); // Legacy Windows function. Use modern crossplatform method instead...}\par
00069         std::this_thread::sleep_for(std::chrono::milliseconds(uiMilliseconds));\par
00070     \}\par
00071 \par
00072     {\cf18 void} CTimer::setAveragedFPSRate({\cf18 float} fSecondsBetweenUpdates)\par
00073     \{\par
00074         _mdFPSAveragedRate = (double)fSecondsBetweenUpdates;\par
00075         {\cf19 if} (_mdFPSAveragedRate <= 0)\par
00076             _mdFPSAveragedRate = 0.001;\par
00077     \}\par
00078 \par
00079     {\cf18 float} CTimer::getAveragedFPSRate({\cf18 void}){\cf17  const}\par
00080 {\cf17     }\{\par
00081         {\cf19 return} ({\cf18 float})_mdFPSAveragedRate;\par
00082     \}\par
00083 \par
00084     {\cf18 float} CTimer::getFPS({\cf18 void}){\cf17  const}\par
00085 {\cf17     }\{\par
00086         {\cf19 return} ({\cf18 float})_mdFPS;\par
00087     \}\par
00088 \par
00089     {\cf18 float} CTimer::getFPSAveraged({\cf18 void}){\cf17  const}\par
00090 {\cf17     }\{\par
00091         {\cf19 return} ({\cf18 float})_mdFPSAveraged;\par
00092     \}\par
00093 \par
00094     {\cf18 float} CTimer::getFPSAveragedTimeUntilNextUpdate({\cf18 void}){\cf17  const}\par
00095 {\cf17     }\{\par
00096         {\cf19 return} float(_mdFPSAveragedRate - _mdFPSAveragedTimeCount);\par
00097     \}\par
00098 \par
00099     {\cf18 void} CTimer::reset({\cf18 void})\par
00100     \{\par
00101         _mbPaused = {\cf17 false};\par
00102         _mdTimePointNew = std::chrono::steady_clock::now();\par
00103         _mdTimePointOld = _mdTimePointNew;{\cf20 // std::chrono::steady_clock::now();}\par
00104         _mdTimeDeltaSec = _mdTimePointNew - _mdTimePointOld;\par
00105         _mdDeltaSec = _mdTimeDeltaSec.count();\par
00106 \par
00107         {\cf20 // Stuff for FPS}\par
00108         _mdFPS = 1.0;                {\cf20 // Holds computed current frames per second value}\par
00109         _muiNumFrames = 0;           {\cf20 // Used to compute FPS stuff        }\par
00110         _mdFPSFrameTime = 0;         {\cf20 // Used to compute FPS stuff}\par
00111 \par
00112         {\cf20 // Stuff for FPS averaged}\par
00113         _mdFPSAveraged = 1.0;                    {\cf20 // Holds computed averaged frames per second value}\par
00114         _mdFPSAveragedRate = 3.0;                {\cf20 // Number of seconds between updating the value returned by getFPSAveraged() method.}\par
00115         _mdFPSAveragedTimeCount = 0;             {\cf20 // Used to compute FPSAveraged stuff}\par
00116         _miFPSAveragedNumCallsPerSec = 0;        {\cf20 // Used to compute FPSAveraged stuff}\par
00117         _mdFPSAveragedAccum = 0;                 {\cf20 // Used to compute FPSAveraged stuff}\par
00118 \par
00119         _mdRuntimeInSeconds = 0;\par
00120     \}\par
00121 \par
00122     {\cf18 float} CTimer::getRuntimeSeconds({\cf18 void}){\cf17  const}\par
00123 {\cf17     }\{\par
00124         {\cf19 return} ({\cf18 float})_mdRuntimeInSeconds;\par
00125     \}\par
00126 \par
00127     {\cf18 void} CTimer::getClock({\cf18 float}& fSeconds, {\cf18 int}& iMinutes, {\cf18 int}& iHours, {\cf18 int}& iDays, {\cf18 int}& iWeeks){\cf17  const}\par
00128 {\cf17     }\{\par
00129         fSeconds = 0.0f;\par
00130         iMinutes = 0;\par
00131         iHours = 0;\par
00132         iDays = 0;\par
00133         iWeeks = 0;\par
00134 \par
00135         {\cf20 // How many seconds are in a week?}\par
00136         {\cf20 // 60seconds in a minute, 60 minutes in an hour, 24 hours in a day and 7 days in a week.}\par
00137         {\cf20 // 60 * 60 = 3600 seconds per hour}\par
00138         {\cf20 // 3600 * 24 = 86400 seconds in a day}\par
00139         {\cf20 // 86400 * 7 = 604800 seconds in a week}\par
00140         {\cf18 double} seconds = _mdRuntimeInSeconds;\par
00141         {\cf19 while} (seconds >= 604800)   {\cf20 // Weeks}\par
00142         \{\par
00143             seconds -= 604800;\par
00144             iWeeks++;\par
00145         \}\par
00146         {\cf19 while} (seconds >= 86400)    {\cf20 // Days}\par
00147         \{\par
00148             seconds -= 86400;\par
00149             iDays++;\par
00150         \}\par
00151         {\cf19 while} (seconds >= 3600)     {\cf20 // Hours}\par
00152         \{\par
00153             seconds -= 3600;\par
00154             iHours++;\par
00155         \}\par
00156         {\cf19 while} (seconds >= 60)       {\cf20 // Minutes}\par
00157         \{\par
00158             seconds -= 60;\par
00159             iMinutes++;\par
00160         \}\par
00161         fSeconds = (float)seconds;  {\cf20 // Seconds}\par
00162     \}\par
00163 \par
00164     std::string CTimer::getClock({\cf18 void}){\cf17  const}\par
00165 {\cf17     }\{\par
00166         {\cf18 float} fSecs = 0.0f;\par
00167         {\cf18 int} iMins, iHours, iDays, iWeeks = 0;\par
00168         getClock(fSecs, iMins, iHours, iDays, iWeeks);\par
00169         std::string strRuntime = std::to_string(({\cf18 int})fSecs) + {\cf22 "sec "};\par
00170         strRuntime += std::to_string(iMins) + {\cf22 "min "};\par
00171         strRuntime += std::to_string(iHours) + {\cf22 "hr "};\par
00172         strRuntime += std::to_string(iDays) + {\cf22 "days "};\par
00173         strRuntime += std::to_string(iWeeks) + {\cf22 "weeks."};\par
00174         {\cf19 return} strRuntime;\par
00175     \}\par
00176 \par
00177 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Timer.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Timer.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Timer.h}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CTimer class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <chrono>}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CTimer}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with additional features compared to {\b CTimerMinimal}. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CTimer class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b Timer.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Timer.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Timer.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Timer.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef TIMER_H}\par
00007 {\cf21 #define TIMER_H}\par
00008 \par
00009 {\cf21 #include <chrono>}\par
00010 {\cf21 #include <string>}\par
00011 \par
00012 {\cf17 namespace }DCL\par
00013 \{\par
00022     {\cf17 class }CTimer\par
00023     \{\par
00024     {\cf17 public}:\par
00025 \par
00027         CTimer();\par
00028 \par
00030         {\cf18 void} update({\cf18 void});\par
00031 \par
00036         {\cf18 void} pause({\cf18 void});\par
00037 \par
00039         {\cf18 void} resume({\cf18 void});\par
00040 \par
00044         {\cf18 float} getSecondsPast({\cf18 void}) {\cf17 const};\par
00045 \par
00051         {\cf18 void} sleep({\cf18 unsigned} {\cf18 int} uiMilliseconds) {\cf17 const};\par
00052 \par
00058         {\cf18 void} setAveragedFPSRate({\cf18 float} fSecondsBetweenUpdates);\par
00059 \par
00063         {\cf18 float} getAveragedFPSRate({\cf18 void}) {\cf17 const};\par
00064 \par
00068         {\cf18 float} getFPS({\cf18 void}) {\cf17 const};\par
00069 \par
00073         {\cf18 float} getFPSAveraged({\cf18 void}) {\cf17 const};\par
00074 \par
00078         {\cf18 float} getFPSAveragedTimeUntilNextUpdate({\cf18 void}) {\cf17 const};\par
00079 \par
00083         {\cf18 void} reset({\cf18 void});\par
00084 \par
00088         {\cf18 float} getRuntimeSeconds({\cf18 void}) {\cf17 const};\par
00089 \par
00097         {\cf18 void} getClock({\cf18 float}& fSeconds, {\cf18 int}& iMinutes, {\cf18 int}& iHours, {\cf18 int}& iDays, {\cf18 int}& iWeeks) {\cf17 const};\par
00098 \par
00102         std::string getClock({\cf18 void}) {\cf17 const};\par
00103     {\cf17 private}:\par
00104         std::chrono::duration<double> _mdTimeDeltaSec;\par
00105         std::chrono::time_point<std::chrono::steady_clock> _mdTimePointOld, _mdTimePointNew;\par
00106 \par
00107         {\cf18 double} _mdDeltaSec;                     \par
00108         {\cf18 bool} _mbPaused;                         \par
00109 \par
00110         {\cf20 // Members for FPS}\par
00111         {\cf18 double} _mdFPS;                          \par
00112         {\cf18 double} _mdFPSFrameTime;                 \par
00113         {\cf18 unsigned} {\cf18 int} _muiNumFrames;             \par
00114 \par
00115         {\cf20 // Members for FPS averaged}\par
00116         {\cf18 double} _mdFPSAveraged;                  \par
00117         {\cf18 double} _mdFPSAveragedRate;              \par
00118         {\cf18 double} _mdFPSAveragedTimeCount;         \par
00119         {\cf18 int} _miFPSAveragedNumCallsPerSec;       \par
00120         {\cf18 double} _mdFPSAveragedAccum;             \par
00121         {\cf18 double} _mdRuntimeInSeconds;             \par
00122     \};\par
00123 \par
00124 \}   {\cf20 // namespace DCL}\par
00125 \par
00126 {\cf21 #endif }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TimerMinimal.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/TimerMinimal.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/TimerMinimal.cpp}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "TimerMinimal.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005     CTimerMinimal::CTimerMinimal()\par
00006     \{\par
00007         reset();\par
00008     \}\par
00009 \par
00010     {\cf18 double} CTimerMinimal::getSecondsPast({\cf18 void}){\cf17  const}\par
00011 {\cf17     }\{\par
00012         {\cf19 return} _mdDeltaSec;\par
00013     \}\par
00014 \par
00015     {\cf18 void} CTimerMinimal::update({\cf18 void})\par
00016     \{\par
00017         _mdTimePointNew = std::chrono::steady_clock::now();\par
00018         _mdTimeDeltaSec = _mdTimePointNew - _mdTimePointOld;\par
00019         _mdTimePointOld = _mdTimePointNew;\par
00020         _mdDeltaSec = _mdTimeDeltaSec.count();\par
00021     \}\par
00022 \par
00023     {\cf18 void} CTimerMinimal::reset({\cf18 void})\par
00024     \{\par
00025         _mdTimePointNew = std::chrono::steady_clock::now();\par
00026         _mdTimePointOld = _mdTimePointNew;\par
00027         _mdTimeDeltaSec = _mdTimePointNew - _mdTimePointOld;\par
00028         _mdDeltaSec = _mdTimeDeltaSec.count();\par
00029     \}\par
00030 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/TimerMinimal.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/TimerMinimal.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/TimerMinimal.h}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CTimerMinimal class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <chrono>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CTimerMinimal}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deals with time related concepts with minimal features compared to {\b CTimer}. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the CTimerMinimal class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b TimerMinimal.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TimerMinimal.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/TimerMinimal.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/TimerMinimal.h}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef TIMERMINIMAL_H}\par
00007 {\cf21 #define TIMERMINIMAL_H}\par
00008 \par
00009 {\cf21 #include <chrono>}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00020     {\cf17 class }CTimerMinimal\par
00021     \{\par
00022     {\cf17 public}:\par
00024         CTimerMinimal();\par
00025 \par
00027         {\cf18 void} update({\cf18 void});\par
00028 \par
00031         {\cf18 double} getSecondsPast({\cf18 void}) {\cf17 const};\par
00032 \par
00034         {\cf18 void} reset({\cf18 void});\par
00035 \par
00036     {\cf17 private}:\par
00037         std::chrono::duration<double> _mdTimeDeltaSec;\par
00038         std::chrono::time_point<std::chrono::steady_clock> _mdTimePointOld, _mdTimePointNew;\par
00039         {\cf18 double} _mdDeltaSec;                                                                     \par
00040     \};\par
00041 \par
00042 \}   {\cf20 // namespace DCL}\par
00043 \par
00044 {\cf21 #endif }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Utilities.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Utilities.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Utilities.cpp}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Utilities.h"}\par
00002 {\cf21 #include "Logging.h"}\par
00003 \par
00004 {\cf21 #include <algorithm>}\par
00005 {\cf21 #define NOMINMAX                }{\cf20 // Set this before including windows.h so that the min/max macros located in algorithm header take precedence}\par
00006 {\cf21 #define WIN32_LEAN_AND_MEAN     }{\cf20 // Exclude rarely used stuff from Windows headers}\par
00007 {\cf21 #include <Windows.h>}\par
00008 {\cf21 #include <psapi.h>}\par
00009 \par
00010 {\cf17 namespace }DCL\par
00011 \{\par
00012     {\cf18 bool} getFileExists({\cf17 const} std::string& strFilename)\par
00013     \{\par
00014         {\cf20 /*}\par
00015 {\cf20         FILE* f;}\par
00016 {\cf20         if (fopen_s(&f, strFilename.c_str(), "rb"))}\par
00017 {\cf20             return false;}\par
00018 {\cf20         fclose(f);}\par
00019 {\cf20         return true;}\par
00020 {\cf20         */}\par
00021         {\cf18 bool} bExists = {\cf17 false};\par
00022         std::ifstream file(strFilename);\par
00023         {\cf19 if} (file.is_open())\par
00024         \{\par
00025             bExists = {\cf17 true};\par
00026             file.close();\par
00027         \}\par
00028         {\cf19 return} bExists;\par
00029     \}\par
00030 \par
00031     {\cf18 bool} convertFileToHeader({\cf17 const} std::string &strFilename, {\cf17 const} std::string &strArrayName, {\cf18 unsigned} {\cf18 int} uiNumElementsPerRow)\par
00032     \{\par
00033         FILE* fs = NULL;  {\cf20 // Source file}\par
00034         FILE* fd = NULL;  {\cf20 // Destination file}\par
00035 \par
00036         std::string strFilenameInput = strFilename;\par
00037         std::string strFilenameOutput = strFilename;\par
00038         strFilenameOutput.append({\cf22 ".h"});\par
00039 \par
00040         {\cf20 // Open source}\par
00041         fopen_s(&fs, strFilename.c_str(), {\cf22 "rb"});\par
00042         {\cf19 if} (fs == NULL)\par
00043             {\cf19 return} {\cf17 false};\par
00044 \par
00045         {\cf20 // Open destination}\par
00046         fopen_s(&fd, strFilenameOutput.c_str(), {\cf22 "wb"});\par
00047         {\cf19 if} (fd == NULL)\par
00048         \{\par
00049             fclose(fs);\par
00050             {\cf19 return} {\cf17 false};\par
00051         \}\par
00052 \par
00053         {\cf20 // Write comment giving name of binary file that this data came from}\par
00054         fprintf(fd, {\cf22 "// Following data taken from file \\"%s\\"\\n"}, strFilename.c_str());\par
00055 \par
00056         {\cf20 // Get length of data}\par
00057         fseek(fs, 0, SEEK_END);\par
00058         {\cf18 int} length = ftell(fs);\par
00059         fseek(fs, 0, SEEK_SET);\par
00060 \par
00061         {\cf20 // Write #define for length of array}\par
00062         std::string strArrayNameUppercase = strArrayName;\par
00063         std::transform(strArrayNameUppercase.begin(), strArrayNameUppercase.end(), strArrayNameUppercase.begin(), ::toupper);\par
00064         strArrayNameUppercase.append({\cf22 "_SIZE"});\par
00065         fprintf(fd, {\cf22 "#define %s %d\\n"}, strArrayNameUppercase.c_str(), length);\par
00066 \par
00067         {\cf20 // Write start of array}\par
00068         fprintf(fd, {\cf22 "unsigned char %s[] =\\n"}, strArrayName.c_str());\par
00069         fprintf(fd, {\cf22 "\{\\n "});\par
00070 \par
00071         {\cf20 // Write out data from source binary file}\par
00072         {\cf19 while} (feof(fs) == {\cf17 false})\par
00073         \{\par
00074             {\cf18 unsigned} {\cf18 char} tmp;\par
00075             {\cf19 for} ({\cf18 int} e = 0; e < (int)uiNumElementsPerRow; e++)\par
00076             \{\par
00077                 fread(&tmp, 1, {\cf17 sizeof}({\cf18 unsigned} {\cf18 char}), fs);\par
00078                 {\cf19 if} (feof(fs) == {\cf17 false})\par
00079                     fprintf(fd, {\cf22 "0x%02x,"}, tmp);\par
00080             \}\par
00081 \par
00082             {\cf19 if} (feof(fs)) {\cf20 // Reached end of file}\par
00083             \{\par
00084                 fseek(fd, -1, SEEK_CUR);  {\cf20 // Remove last comma}\par
00085                 fprintf(fd, {\cf22 "\};"});\par
00086             \}\par
00087             fprintf(fd, {\cf22 "\\n "});\par
00088         \}\par
00089         fprintf(fd, {\cf22 "\\n"});\par
00090 \par
00091         fclose(fs);\par
00092         fclose(fd);\par
00093         {\cf19 return} {\cf17 true};\par
00094     \}\par
00095 \par
00096     {\cf18 void} getHueColour({\cf18 float} fHueAmount, {\cf18 float}& fRed, {\cf18 float}& fGreen, {\cf18 float}& fBlue)\par
00097     \{\par
00098         clamp(fHueAmount, 0.0f, 1.0f);\par
00099         fHueAmount *= 360.0f;\par
00100         {\cf19 if} (fHueAmount <= 60.0f)    {\cf20 // Inc green}\par
00101         \{\par
00102             fRed = 1.0f;\par
00103             fGreen = fHueAmount / 60.0f;\par
00104             fBlue = 0.0f;\par
00105         \}\par
00106         {\cf19 else} {\cf19 if} (fHueAmount <= 120.0f)  {\cf20 // Dec red}\par
00107         \{\par
00108             fRed = 1.0f - ((fHueAmount - 60.0f) / 60.0f);\par
00109             fGreen = 1.0f;\par
00110             fBlue = 0.0f;\par
00111         \}\par
00112         {\cf19 else} {\cf19 if} (fHueAmount <= 180.0f)  {\cf20 // Inc blue}\par
00113         \{\par
00114             fRed = 0.0f;\par
00115             fGreen = 1.0f;\par
00116             fBlue = (fHueAmount - 120.0f) / 60.0f;\par
00117         \}\par
00118         {\cf19 else} {\cf19 if} (fHueAmount <= 240.0f)  {\cf20 // Dec green}\par
00119         \{\par
00120             fRed = 0.0f;\par
00121             fGreen = 1.0f - ((fHueAmount - 180.0f) / 60.0f);\par
00122             fBlue = 1.0f;\par
00123         \}\par
00124         {\cf19 else} {\cf19 if} (fHueAmount <= 300.0f)  {\cf20 // Inc red}\par
00125         \{\par
00126             fRed = (fHueAmount - 240.0f) / 60.0f;\par
00127             fGreen = 0.0f;\par
00128             fBlue = 1.0f;\par
00129         \}\par
00130         {\cf19 else} {\cf20 // dec blue}\par
00131         \{\par
00132             fRed = 1.0f;\par
00133             fGreen = 0.0f;\par
00134             fBlue = 1.0f - ((fHueAmount - 300.0f) / 60.0f);\par
00135         \}\par
00136     \}\par
00137 {\cf20 /*}\par
00138 {\cf20 }\par
00139 {\cf20     glm::quat rotationBetweenVectors(glm::vec3 v1, glm::vec3 v2)}\par
00140 {\cf20     \{}\par
00141 {\cf20         v1 = normalize(v1);}\par
00142 {\cf20         v2 = normalize(v2);}\par
00143 {\cf20 }\par
00144 {\cf20         float cosTheta = dot(v1, v2);}\par
00145 {\cf20         glm::vec3 rotationAxis;}\par
00146 {\cf20 }\par
00147 {\cf20         // Special case when both vectors are in opposite directions}\par
00148 {\cf20         // There is no "ideal" rotation axis, so guess one. Any will do as long as it's perpendicular to v1}\par
00149 {\cf20         if (cosTheta < -1 + 0.001f)}\par
00150 {\cf20         \{   }\par
00151 {\cf20             rotationAxis = glm::cross(glm::vec3(0.0f, 0.0f, 1.0f), v1);}\par
00152 {\cf20             if (glm::length2(rotationAxis) < 0.01) // They were parallel}\par
00153 {\cf20                 rotationAxis = glm::cross(glm::vec3(1.0f, 0.0f, 0.0f), v1);}\par
00154 {\cf20             rotationAxis = normalize(rotationAxis);}\par
00155 {\cf20             return glm::angleAxis(glm::radians(180.0f), rotationAxis);}\par
00156 {\cf20         \}}\par
00157 {\cf20         rotationAxis = cross(v1, v2);}\par
00158 {\cf20         float s = sqrt((1 + cosTheta) * 2);}\par
00159 {\cf20         float invs = 1 / s;}\par
00160 {\cf20         return glm::quat(s * 0.5f, rotationAxis.x * invs, rotationAxis.y * invs, rotationAxis.z * invs);}\par
00161 {\cf20     \}}\par
00162 {\cf20 */}\par
00163 \par
00164     {\cf18 void} getMemInfo(SMemInfo& memInfo)\par
00165     \{\par
00166         SecureZeroMemory(&memInfo, {\cf17 sizeof}(SMemInfo));\par
00167 \par
00168         HANDLE hAppProcess = GetCurrentProcess();\par
00169         {\cf19 if} (!hAppProcess)   {\cf20 // Found application process handle?}\par
00170             {\cf19 return};\par
00171 \par
00172         {\cf20 // Retreive and store process mem usage}\par
00173         PROCESS_MEMORY_COUNTERS_EX pmc;\par
00174         {\cf19 if} (GetProcessMemoryInfo(hAppProcess, (PPROCESS_MEMORY_COUNTERS)&pmc, {\cf17 sizeof}(PROCESS_MEMORY_COUNTERS_EX)))\par
00175         \{\par
00176             memInfo.proc.iPageFaultCount = ({\cf18 unsigned} int)pmc.PageFaultCount;\par
00177             memInfo.proc.iPeakWorkingSetSize = ({\cf18 unsigned} int)pmc.PeakWorkingSetSize;\par
00178             memInfo.proc.iWorkingSetSize = ({\cf18 unsigned} int)pmc.WorkingSetSize;\par
00179             memInfo.proc.iQuotaPeakPagedPoolUsage = ({\cf18 unsigned} int)pmc.QuotaPeakPagedPoolUsage;\par
00180             memInfo.proc.iQuotaPagedPoolUsage = ({\cf18 unsigned} int)pmc.QuotaPagedPoolUsage;\par
00181             memInfo.proc.iQuotaPeakNonPagedPoolUsage = ({\cf18 unsigned} int)pmc.QuotaPeakNonPagedPoolUsage;\par
00182             memInfo.proc.iQuotaNonPagedPoolUsage = ({\cf18 unsigned} int)pmc.QuotaNonPagedPoolUsage;\par
00183             memInfo.proc.iPagefileUsage = ({\cf18 unsigned} int)pmc.PagefileUsage;\par
00184             memInfo.proc.iPeakPagefileUsage = ({\cf18 unsigned} int)pmc.PeakPagefileUsage;\par
00185             memInfo.proc.iPrivateUsage = ({\cf18 unsigned} int)pmc.PrivateUsage;\par
00186         \}\par
00187 \par
00188         PERFORMACE_INFORMATION pin;\par
00189         {\cf19 if} (GetPerformanceInfo(&pin, {\cf17 sizeof}(PERFORMACE_INFORMATION)))\par
00190         \{\par
00191             memInfo.os.iCommitLimit = ({\cf18 unsigned} int)pin.CommitLimit;\par
00192             memInfo.os.iCommitPeak = ({\cf18 unsigned} int)pin.CommitPeak;\par
00193             memInfo.os.iCommitTotal = ({\cf18 unsigned} int)pin.CommitTotal;\par
00194             memInfo.os.iHandleCount = ({\cf18 unsigned} int)pin.HandleCount;\par
00195             memInfo.os.iKernelNonpaged = ({\cf18 unsigned} int)pin.KernelNonpaged;\par
00196             memInfo.os.iKernelPaged = ({\cf18 unsigned} int)pin.KernelPaged;\par
00197             memInfo.os.iKernelTotal = ({\cf18 unsigned} int)pin.KernelTotal;\par
00198             memInfo.os.iPageSize = ({\cf18 unsigned} int)pin.PageSize;\par
00199             memInfo.os.iPhysicalAvailable = ({\cf18 unsigned} int)pin.PhysicalAvailable;\par
00200             memInfo.os.iPhysicalTotal = ({\cf18 unsigned} int)pin.PhysicalTotal;\par
00201             memInfo.os.iProcessCount = ({\cf18 unsigned} int)pin.ProcessCount;\par
00202             memInfo.os.iSystemCache = ({\cf18 unsigned} int)pin.SystemCache;\par
00203             memInfo.os.iThreadCount = ({\cf18 unsigned} int)pin.ThreadCount;\par
00204         \}\par
00205     \}\par
00206 \par
00207     {\cf18 int} getCPULogicalCores({\cf18 void})\par
00208     \{\par
00209         SYSTEM_INFO si;\par
00210         GetSystemInfo(&si);\par
00211         {\cf19 return} int(si.dwNumberOfProcessors);\par
00212     \}\par
00213 \par
00214 \par
00215 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Utilities.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Utilities.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Utilities.h}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various utility functions. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Timer.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DCL::SMemInfo}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds system memory information which is set by {\b getMemInfo()} }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DCL::SMemInfo::SMemProcess}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds process memory usage. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DCL::SMemInfo::SMemOS}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds OS memory usage. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b DCL::areFloatsEqual} (const float &A, const float &B)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if parsed values have a difference of less than kfEpsilon. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b DCL::areDoublesEqual} (const double &A, const double &B)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if parsed values have a difference of less than kdEpsilon. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b DCL::interpolate} (float fValA, float fValB, float fPosition)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interpolate between two given values, given a position value between 0.0f and 1.0f. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b DCL::sigmoid} (double dValue, double dResponse=1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sigmoid function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b DCL::sigmoid} (double dValue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sigmoid function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b DCL::getFileExists} (const std::string &strFilename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given disk filename exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b DCL::convertFileToHeader} (const std::string &strFilename, const std::string &strArrayName="data", unsigned int iNumElementsPerRow=20)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the contents of a file into an array, stored inside a text header file, for inclusion of external files, inside the executable of a program. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::getHueColour} (float fHueAmount, float &fRed, float &fGreen, float &fBlue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the given colour values based on given hue value (between zero and one) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Type > bool {\b DCL::isNAN} (Type type)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparing a variable when it becomes invalid always returns false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b DCL::deg2rad} (float fAngleDegrees)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts degrees to radians. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b DCL::rad2deg} (float fAngleRadians)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts radians to degrees. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b DCL::acosClamped} (float f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clamps given value within the range of -1 to +1 then performs standard acos function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::sincos} (float &outSin, float &outCos, float fScalar)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes both sin and cos of a scalar (Sometime faster to calculate both at same time) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class type > void {\b DCL::clamp} (type &valueToClamp, type valueA, type valueB)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clamps a value within given range. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class type > void {\b DCL::absolute} (type &value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets given variable to absolute value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class type > type {\b DCL::difference} (type valueA, type valueB)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the difference. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b DCL::randInt} (int ix, int iy)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random integer between x and y. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b DCL::randFloat} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random float between zero and 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b DCL::randDouble} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random double between zero and 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b DCL::randBool} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random bool. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b DCL::randomClamped} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random double in the range -1 < n < 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b DCL::randf} (float fMin, float fMax)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a random float within the specified range. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DCL::getMemInfo} ({\b SMemInfo} &memInfo)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Places memory information about the process and system into the given {\b SMemInfo} structure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b DCL::getCPULogicalCores} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns number of logical CPU cores. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::kfEpsilon} = 0.0000001f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Due to floating point errors, we use this to determine whether two floating points are roughly equal. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b DCL::kdEpsilon} = 0.000000000000001f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Due to floating point errors with doubles, we use this to determine whether two doubles points are roughly equal. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::kPi} = 3.14159265f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pi constant. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::k2Pi} = {\b kPi} * 2.0f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 * Pi (Radians in a circle) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::kPiOver2} = {\b kPi} / 2.0f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pi divided by 2 (90 degrees in radians) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::k1OverPi} = 1.0f / {\b kPi}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0f divided by PI }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::k1Over2Pi} = 1.0f / {\b k2Pi}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0f divided by 2*PI }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::kPiOver180} = {\b kPi} / 180.0f\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PI divided by 180.0f. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::k180OverPi} = 180.0f / {\b kPi}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
180.0f divided by PI }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b DCL::kMaxDouble} = (std::numeric_limits<double>::max)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum value for a double. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b DCL::kMinDouble} = (std::numeric_limits<double>::min)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum value for a double. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::kMaxFloat} = (std::numeric_limits<float>::max)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum value for a float. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DCL::kMinFloat} = (std::numeric_limits<float>::min)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum value for a float. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b DCL::kMaxInt} = (std::numeric_limits<int>::max)()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum value for an int. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains various utility functions. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b Utilities.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Utilities.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Utilities.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Core/Utilities.h}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef UTILITIES_H}\par
00007 {\cf21 #define UTILITIES_H}\par
00008 \par
00009 {\cf21 #include "Timer.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00014     {\cf17 const} {\cf18 float} kfEpsilon = 0.0000001f;\par
00015 \par
00021     {\cf17 inline} {\cf18 bool} areFloatsEqual({\cf17 const} {\cf18 float}& A, {\cf17 const} {\cf18 float}& B)\par
00022     \{\par
00023         {\cf19 return} (fabsf(A - B) < kfEpsilon);\par
00024     \}\par
00025 \par
00027     {\cf17 const} {\cf18 double} kdEpsilon = 0.000000000000001f;\par
00028     \par
00034     {\cf17 inline} {\cf18 bool} areDoublesEqual({\cf17 const} {\cf18 double}& A, {\cf17 const} {\cf18 double}& B)\par
00035     \{\par
00036         {\cf19 return} (abs(A - B) < kdEpsilon);\par
00037     \}\par
00038 \par
00045     {\cf17 inline} {\cf18 float} interpolate({\cf18 float} fValA, {\cf18 float} fValB, {\cf18 float} fPosition)\par
00046     \{\par
00047         {\cf18 float} fDiff = fValA - fValB;\par
00048         fDiff *= -1.0f;\par
00049         {\cf19 return} fValA + (fDiff * fPosition);\par
00050     \}\par
00051 \par
00063     {\cf17 inline} {\cf18 double} sigmoid({\cf18 double} dValue, {\cf18 double} dResponse = 1)\par
00064     \{\par
00065         {\cf20 // The sigmoid function looks like this...}\par
00066         {\cf20 // 1 / 1 + (e to the power of(-dValue / dResponse));}\par
00067         {\cf20 // Where e is a math constant, which is roughly 2.7183}\par
00068         {\cf20 // We use exp() to compute the exponential value of (-dValue / dResponse)}\par
00069         {\cf19 return} (1 / (1 + exp(-dValue / dResponse)));\par
00070     \}\par
00071 \par
00080     {\cf17 inline} {\cf18 double} sigmoid({\cf18 double} dValue)\par
00081     \{\par
00082         {\cf19 return} 1 / (1 + exp(-dValue));\par
00083     \}\par
00084 \par
00089     {\cf18 bool} getFileExists({\cf17 const} std::string& strFilename);\par
00090 \par
00097     {\cf18 bool} convertFileToHeader({\cf17 const} std::string &strFilename, {\cf17 const} std::string &strArrayName = {\cf22 "data"}, {\cf18 unsigned} {\cf18 int} iNumElementsPerRow = 20);\par
00098 \par
00105     {\cf17 extern} {\cf18 void} getHueColour({\cf18 float} fHueAmount, {\cf18 float}& fRed, {\cf18 float}& fGreen, {\cf18 float}& fBlue);\par
00106 \par
00107     {\cf17 const} {\cf18 float} kPi = 3.14159265f;                                      \par
00108     {\cf17 const} {\cf18 float} k2Pi = kPi * 2.0f;                                      \par
00109     {\cf17 const} {\cf18 float} kPiOver2 = kPi / 2.0f;                                  \par
00110     {\cf17 const} {\cf18 float} k1OverPi = 1.0f / kPi;                                  \par
00111     {\cf17 const} {\cf18 float} k1Over2Pi = 1.0f / k2Pi;                                \par
00112     {\cf17 const} {\cf18 float} kPiOver180 = kPi / 180.0f;                              \par
00113     {\cf17 const} {\cf18 float} k180OverPi = 180.0f / kPi;                              \par
00114     {\cf17 const} {\cf18 double}  kMaxDouble = (std::numeric_limits<double>::max)();    \par
00115     {\cf17 const} {\cf18 double}  kMinDouble = (std::numeric_limits<double>::min)();    \par
00116     {\cf17 const} {\cf18 float}   kMaxFloat = (std::numeric_limits<float>::max)();      \par
00117     {\cf17 const} {\cf18 float}   kMinFloat = (std::numeric_limits<float>::min)();      \par
00118     {\cf17 const} {\cf18 int}     kMaxInt = (std::numeric_limits<int>::max)();          \par
00119 \par
00126     {\cf17 template} <{\cf17 typename} Type>\par
00127     {\cf17 inline} {\cf18 bool} isNAN(Type type)\par
00128     \{\par
00129         {\cf19 return} type != type;\par
00130     \}\par
00131 \par
00136     {\cf17 inline} {\cf18 float} deg2rad({\cf18 float} fAngleDegrees) \{ {\cf19 return} fAngleDegrees * kPiOver180; \}\par
00137 \par
00142     {\cf17 inline} {\cf18 float} rad2deg({\cf18 float} fAngleRadians) \{ {\cf19 return} fAngleRadians * k180OverPi; \}\par
00143 \par
00148     {\cf17 inline} {\cf18 float} acosClamped({\cf18 float} f)\par
00149     \{\par
00150         {\cf19 if} (f < -1.0f)\par
00151             {\cf19 return} kPi;\par
00152         {\cf19 if} (f > 1.0f)\par
00153             {\cf19 return} 0.0f;\par
00154         {\cf19 return} acosf(f);\par
00155     \}\par
00156 \par
00162     {\cf17 inline} {\cf18 void} sincos({\cf18 float}& outSin, {\cf18 float}& outCos, {\cf18 float} fScalar)\par
00163     \{\par
00164         outSin = sinf(fScalar);\par
00165         outCos = cosf(fScalar);\par
00166     \}\par
00167 \par
00173     {\cf17 template} <{\cf17 class} type>\par
00174     {\cf17 inline} {\cf18 void} clamp(type& valueToClamp, type valueA, type valueB)\par
00175     \{\par
00176         type min;\par
00177         type max;\par
00178         {\cf19 if} (valueA < valueB)\par
00179         \{\par
00180             min = valueA;\par
00181             max = valueB;\par
00182         \}\par
00183         {\cf19 else}\par
00184         \{\par
00185             min = valueB;\par
00186             max = valueA;\par
00187         \}\par
00188         {\cf19 if} (valueToClamp < min)\par
00189             valueToClamp = min;\par
00190         {\cf19 else} {\cf19 if} (valueToClamp > max)\par
00191             valueToClamp = max;\par
00192     \}\par
00193 \par
00197     {\cf17 template} <{\cf17 class} type>\par
00198     {\cf17 inline} {\cf18 void} absolute(type& value)\par
00199     \{\par
00200         {\cf19 if} (value < 0)\par
00201             value *= -1;\par
00202     \}\par
00203 \par
00209     {\cf17 template} <{\cf17 class} type>\par
00210     {\cf17 inline} type difference(type valueA, type valueB)\par
00211     \{\par
00212         type result = valueA - valueB;\par
00213         absolute(result);\par
00214         {\cf19 return} result;\par
00215     \}\par
00216 \par
00222     {\cf17 inline} {\cf18 int} randInt({\cf18 int} ix, {\cf18 int} iy) \{ {\cf19 return} rand() % (iy - ix + 1) + ix; \}\par
00223 \par
00227     {\cf17 inline} {\cf18 float} randFloat() \{ {\cf19 return} float(rand()) / float(RAND_MAX + 1.0f); \}\par
00228 \par
00232     {\cf17 inline} {\cf18 double} randDouble() \{ {\cf19 return} double(rand()) / double(RAND_MAX + 1.0); \}\par
00233 \par
00237     {\cf17 inline} {\cf18 bool} randBool()\par
00238     \{\par
00239         {\cf19 if} (randInt(0, 1)) {\cf19 return} {\cf17 true};\par
00240         {\cf19 return} {\cf17 false};\par
00241     \}\par
00242 \par
00246     {\cf17 inline} {\cf18 double} randomClamped() \{ {\cf19 return} randDouble() - randDouble(); \}\par
00247 \par
00253     {\cf17 inline} {\cf18 float} randf({\cf18 float} fMin, {\cf18 float} fMax)\par
00254     \{\par
00255         {\cf18 float} fZeroToOne = (float)rand() / float(RAND_MAX + 1.0);\par
00256         {\cf19 return} fMin + (fMax - fMin) * fZeroToOne;\par
00257     \}\par
00258 \par
00259 {\cf20 /*}\par
00260 {\cf20     // Given two vectors, returns the rotation quaternion needed to rotate v1 to match v2}\par
00261 {\cf20 //  glm::quat rotationBetweenVectors(glm::vec3 v1, glm::vec3 v2);}\par
00262 {\cf20 */}\par
00263 \par
00265     {\cf17 struct }SMemInfo\par
00266     \{\par
00268         {\cf17 struct }SMemProcess\par
00269         \{\par
00270             {\cf18 unsigned} {\cf18 int} iPageFaultCount;               \par
00271             {\cf18 unsigned} {\cf18 int} iPeakWorkingSetSize;           \par
00272             {\cf18 unsigned} {\cf18 int} iWorkingSetSize;               \par
00273             {\cf18 unsigned} {\cf18 int} iQuotaPeakPagedPoolUsage;      \par
00274             {\cf18 unsigned} {\cf18 int} iQuotaPagedPoolUsage;          \par
00275             {\cf18 unsigned} {\cf18 int} iQuotaPeakNonPagedPoolUsage;   \par
00276             {\cf18 unsigned} {\cf18 int} iQuotaNonPagedPoolUsage;       \par
00277             {\cf18 unsigned} {\cf18 int} iPagefileUsage;                \par
00278             {\cf18 unsigned} {\cf18 int} iPeakPagefileUsage;            \par
00279             {\cf18 unsigned} {\cf18 int} iPrivateUsage;                 \par
00280         \};\par
00281 \par
00283         {\cf17 struct }SMemOS\par
00284         \{\par
00285             {\cf18 unsigned} {\cf18 int} iCommitTotal;          \par
00286             {\cf18 unsigned} {\cf18 int} iCommitLimit;          \par
00287             {\cf18 unsigned} {\cf18 int} iCommitPeak;           \par
00288             {\cf18 unsigned} {\cf18 int} iPhysicalTotal;        \par
00289             {\cf18 unsigned} {\cf18 int} iPhysicalAvailable;    \par
00290             {\cf18 unsigned} {\cf18 int} iSystemCache;          \par
00291             {\cf18 unsigned} {\cf18 int} iKernelTotal;          \par
00292             {\cf18 unsigned} {\cf18 int} iKernelPaged;          \par
00293             {\cf18 unsigned} {\cf18 int} iKernelNonpaged;       \par
00294             {\cf18 unsigned} {\cf18 int} iPageSize;             \par
00295             {\cf18 unsigned} {\cf18 int} iHandleCount;          \par
00296             {\cf18 unsigned} {\cf18 int} iProcessCount;         \par
00297             {\cf18 unsigned} {\cf18 int} iThreadCount;          \par
00298         \};\par
00299 \par
00300         SMemProcess proc;   \par
00301         SMemOS os;          \par
00302         \par
00303     \};\par
00304 \par
00308     {\cf18 void} getMemInfo(SMemInfo& memInfo);\par
00309 \par
00313     {\cf18 int} getCPULogicalCores({\cf18 void});\par
00314 \par
00315 \}   {\cf20 // Namespace DCL}\par
00316 \par
00317 {\cf21 #endif }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DavesCodeLibrary.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/DavesCodeLibrary.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/DavesCodeLibrary.cpp}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "DavesCodeLibrary.h"}\par
00002 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/DavesCodeLibrary.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/DavesCodeLibrary.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/DavesCodeLibrary.h}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Master include header file for the entire {\b DCL} library meant to be included by any applications which wish to access all the code inside {\b DCL}. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ArtificialIntelligence/FiniteStateMachine.h"}\par
{\f2 #include "ArtificialIntelligence/GeneticAlgorithm.h"}\par
{\f2 #include "ArtificialIntelligence/NeuralNetFeedForward.h"}\par
{\f2 #include "Audio/AudioManager.h"}\par
{\f2 #include "Audio/AudioSample.h"}\par
{\f2 #include "Core/Colourf.h"}\par
{\f2 #include "Core/Colouruc.h"}\par
{\f2 #include "Core/Exceptions.h"}\par
{\f2 #include "Core/Logging.h"}\par
{\f2 #include "Core/Multithreading.h"}\par
{\f2 #include "Core/Profiler.h"}\par
{\f2 #include "Core/Singleton.h"}\par
{\f2 #include "Core/StringUtils.h"}\par
{\f2 #include "Core/Timer.h"}\par
{\f2 #include "Core/TimerMinimal.h"}\par
{\f2 #include "Core/Utilities.h"}\par
{\f2 #include "Files/FileManager.h"}\par
{\f2 #include "Files/FileMemory.h"}\par
{\f2 #include "Image/Image.h"}\par
{\f2 #include "Image/ImageAtlas.h"}\par
{\f2 #include "Math/AABB.h"}\par
{\f2 #include "Math/Frustum.h"}\par
{\f2 #include "Math/Matrix.h"}\par
{\f2 #include "Math/Plane.h"}\par
{\f2 #include "Math/Quaternion.h"}\par
{\f2 #include "Math/Rect.h"}\par
{\f2 #include "Math/Vector2f.h"}\par
{\f2 #include "Math/Vector3f.h"}\par
{\f2 #include "Math/Vector4f.h"}\par
{\f2 #include "RayTracer/Ray.h"}\par
{\f2 #include "SpatialPartitioning/octTree.h"}\par
{\f2 #include "SpatialPartitioning/octTreeEntity.h"}\par
{\f2 #include "SpatialPartitioning/octTreeNode.h"}\par
{\f2 #include "SpatialPartitioning/quadTree.h"}\par
{\f2 #include "SpatialPartitioning/quadTreeEntity.h"}\par
{\f2 #include "SpatialPartitioning/quadTreeNode.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Master include header file for the entire {\b DCL} library meant to be included by any applications which wish to access all the code inside {\b DCL}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If we wish to use the code inside {\b DCL}, then when creating an executable, include this header file which includes all code of {\b DCL}. Then, link to the compiled DavesCodeLibrary.lib which can be found located at /x64/Release/DavesCodeLibrary.lib\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Todo:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid Go through ALL code and modify the comments so that duplicate "returns this or that" and mentioning of parameters in either \\brief or main stuff too. \par
Add to and check FileManager from X code project \par
Add Renderers from DCP_old \par
Add SDL2 and SDL2_Mixer \par
Check Doxygen build system is working WITHOUT having to have the thing installed. \par
}
}{
Definition in file {\b DavesCodeLibrary.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DavesCodeLibrary.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/DavesCodeLibrary.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/DavesCodeLibrary.h}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00012 {\cf21 #ifndef DAVESCODELIBRARY_H}\par
00013 {\cf21 #define DAVESCODELIBRARY_H}\par
00014 \par
00015 {\cf20 // Using Visual Studio library linking preprocessor to link some static libs...}\par
00016 {\cf20 //#pragma comment(lib, "OpenGL32.lib")}\par
00017 {\cf20 //#pragma comment(lib, "GLu32.lib")}\par
00018 {\cf20 //#pragma comment(lib, "dinput8.lib")}\par
00019 {\cf20 //#pragma comment(lib, "dxguid.lib")}\par
00020 {\cf20 //#pragma comment(lib, "psapi.lib")}\par
00021 \par
00022 {\cf20 // SDL2 and SDL_Mixer}\par
00023 {\cf21 #pragma comment(lib, "../../../Output/DynamicLibs/SDL3/x64/SDL2-2.30.6/Debug/SDL3.lib")}\par
00024 {\cf21 #pragma comment(lib, "../../external_libs/SDL2-2.30.6/lib/x64/SDL2_mixer.lib")}\par
00025 {\cf21 #pragma comment(lib, "../../external_libs/SDL2-2.30.6/lib/x64/SDL2main.lib")}\par
00026 \par
00027 \par
00032 \par
00033 {\cf21 #include "ArtificialIntelligence/FiniteStateMachine.h"}\par
00034 {\cf21 #include "ArtificialIntelligence/GeneticAlgorithm.h"}\par
00035 {\cf21 #include "ArtificialIntelligence/NeuralNetFeedForward.h"}\par
00036 {\cf21 #include "Audio/AudioManager.h"}\par
00037 {\cf21 #include "Audio/AudioSample.h"}\par
00038 {\cf21 #include "Core/Colourf.h"}\par
00039 {\cf21 #include "Core/Colouruc.h"}\par
00040 {\cf21 #include "Core/Exceptions.h"}\par
00041 {\cf21 #include "Core/Logging.h"}\par
00042 {\cf21 #include "Core/Multithreading.h"}\par
00043 {\cf21 #include "Core/Profiler.h"}\par
00044 {\cf21 #include "Core/Singleton.h"}\par
00045 {\cf21 #include "Core/StringUtils.h"}\par
00046 {\cf21 #include "Core/Timer.h"}\par
00047 {\cf21 #include "Core/TimerMinimal.h"}\par
00048 {\cf21 #include "Core/Utilities.h"}\par
00049 {\cf21 #include "Files/FileManager.h"}\par
00050 {\cf21 #include "Files/FileMemory.h"}\par
00051 {\cf21 #include "Image/Image.h"}\par
00052 {\cf21 #include "Image/ImageAtlas.h"}\par
00053 {\cf21 #include "Math/AABB.h"}\par
00054 {\cf21 #include "Math/Frustum.h"}\par
00055 {\cf21 #include "Math/Matrix.h"}\par
00056 {\cf21 #include "Math/Plane.h"}\par
00057 {\cf21 #include "Math/Quaternion.h"}\par
00058 {\cf21 #include "Math/Rect.h"}\par
00059 {\cf21 #include "Math/Vector2f.h"}\par
00060 {\cf21 #include "Math/Vector3f.h"}\par
00061 {\cf21 #include "Math/Vector4f.h"}\par
00062 {\cf21 #include "RayTracer/Ray.h"}\par
00063 {\cf20 //#include "Renderers/RendererBase.h"}\par
00064 {\cf20 //#include "Renderers/RendererManager.h"}\par
00065 {\cf20 //#include "Renderers/RendererOpenGL.h"}\par
00066 {\cf20 //#include "Renderers/RendererVulkan.h"}\par
00067 {\cf21 #include "SpatialPartitioning/octTree.h"}\par
00068 {\cf21 #include "SpatialPartitioning/octTreeEntity.h"}\par
00069 {\cf21 #include "SpatialPartitioning/octTreeNode.h"}\par
00070 {\cf21 #include "SpatialPartitioning/quadTree.h"}\par
00071 {\cf21 #include "SpatialPartitioning/quadTreeEntity.h"}\par
00072 {\cf21 #include "SpatialPartitioning/quadTreeNode.h"}\par
00073 \par
00074 {\cf21 #endif }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FileManager.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileManager.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileManager.cpp}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "FileManager.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00011     CFileManager gFileManager;\par
00012 \par
00013     CFileManager::CFileManager()\par
00014     \{\par
00015     \}\par
00016 \par
00017     {\cf18 void} CFileManager::writeString(std::ofstream& file, std::string& strString){\cf17  const}\par
00018 {\cf17     }\{\par
00019         ThrowIfFalse(file.is_open(), {\cf22 "CFileManager::write() failed. The given ofstream is not open."});\par
00020         ThrowIfTrue(file.bad(), {\cf22 "CFileManager::write() failed. The given ofstream is bad."});\par
00021 \par
00022         {\cf20 // Write out length of string}\par
00023         {\cf18 size_t} stringLength = strString.size();\par
00024         file.write(({\cf18 char}*)&stringLength, {\cf17 sizeof}({\cf18 size_t}));\par
00025 \par
00026         {\cf20 // Write out characters}\par
00027         file.write(strString.c_str(), stringLength);\par
00028 \par
00029         ThrowIfTrue(file.bad(), {\cf22 "CFileManager::write() failed. The given ofstream is bad."});\par
00030     \}\par
00031 \par
00032     {\cf18 void} CFileManager::readString(std::ifstream& file, std::string& strString){\cf17  const}\par
00033 {\cf17     }\{\par
00034         ThrowIfFalse(file.is_open(), {\cf22 "CFileManager::read() failed. The given ifstream is not open."});\par
00035         ThrowIfTrue(file.bad(), {\cf22 "CFileManager::read() failed. The given ifstream is bad."});\par
00036 \par
00037         {\cf20 // Read in length of string}\par
00038         {\cf18 size_t} stringLength;\par
00039         file.read(({\cf18 char}*)&stringLength, {\cf17 sizeof}({\cf18 size_t}));\par
00040 \par
00041         {\cf20 // Read in characters}\par
00042         {\cf18 char}* charTemp = {\cf17 new} {\cf18 char}[stringLength];\par
00043         ThrowIfFalse(charTemp, {\cf22 "CFileManager::read() failed. Temporary memory allocation failed."});\par
00044         file.read(charTemp, stringLength);\par
00045         ThrowIfTrue(file.bad(), {\cf22 "CFileManager::read() failed. The given ifstream is bad."});\par
00046 \par
00047         strString.clear();\par
00048         strString.append(charTemp);\par
00049         {\cf17 delete}[] charTemp;\par
00050     \}\par
00051 \par
00052     {\cf18 bool} CFileManager::getFileExists({\cf17 const} std::string& strFilename){\cf17  const}\par
00053 {\cf17     }\{\par
00054         {\cf20 /*}\par
00055 {\cf20         FILE* f;}\par
00056 {\cf20         if (fopen_s(&f, strFilename.c_str(), "rb"))}\par
00057 {\cf20             return false;}\par
00058 {\cf20         fclose(f);}\par
00059 {\cf20         return true;}\par
00060 {\cf20         */}\par
00061         {\cf18 bool} bExists = {\cf17 false};\par
00062         std::ifstream file(strFilename);\par
00063         {\cf19 if} (file.is_open())\par
00064         \{\par
00065             bExists = {\cf17 true};\par
00066             file.close();\par
00067         \}\par
00068         {\cf19 return} bExists;\par
00069     \}\par
00070 \par
00071     {\cf18 bool} CFileManager::deleteFile({\cf17 const} std::string& strFilenameToDelete){\cf17  const}\par
00072 {\cf17     }\{\par
00073         std::remove(strFilenameToDelete.c_str());\par
00074         {\cf19 return} !getFileExists(strFilenameToDelete);\par
00075     \}\par
00076 \par
00077     {\cf18 bool} CFileManager::renameFile({\cf17 const} std::string& strOldFilename, {\cf17 const} std::string& strNewFilename){\cf17  const}\par
00078 {\cf17     }\{\par
00079         {\cf19 if} (0 == std::rename(strOldFilename.c_str(), strNewFilename.c_str()))\par
00080             {\cf19 return} {\cf17 true};\par
00081         {\cf19 return} {\cf17 false};\par
00082     \}\par
00083 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileManager.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileManager.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileManager.h}
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../Core/Exceptions.h"}\par
{\f2 #include <string>}\par
{\f2 #include <fstream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CFileManager}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File manager responsible for dealing with files. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b FileManager.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FileManager.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileManager.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileManager.h}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef FILEMANAGER_H}\par
00007 {\cf21 #define FILEMANAGER_H}\par
00008 \par
00009 {\cf21 #include "../Core/Exceptions.h"}\par
00010 {\cf21 #include <string>}\par
00011 {\cf21 #include <fstream>}\par
00012 \par
00013 {\cf17 namespace }DCL\par
00014 \{\par
00019     {\cf17 class }CFileManager\par
00020     \{\par
00021     {\cf17 public}:\par
00023         CFileManager();\par
00024 \par
00031         {\cf18 void} writeString(std::ofstream& file, std::string& strString) {\cf17 const};\par
00032 \par
00040         {\cf18 void} readString(std::ifstream& file, std::string& strString) {\cf17 const};\par
00041 \par
00046         {\cf18 bool} getFileExists({\cf17 const} std::string& strFilename) {\cf17 const};\par
00047 \par
00055         {\cf17 template} <{\cf17 class} Type> {\cf18 void} read(std::ifstream& file, Type& data);\par
00056 \par
00064         {\cf17 template} <{\cf17 class} Type> {\cf18 void} write(std::ofstream& file, Type& data);\par
00065 \par
00072         {\cf18 bool} deleteFile({\cf17 const} std::string& strFilenameToDelete) {\cf17 const};\par
00073 \par
00079         {\cf18 bool} renameFile({\cf17 const} std::string& strOldFilename, {\cf17 const} std::string& strNewFilename) {\cf17 const};\par
00080     \};\par
00081 \par
00088     {\cf17 extern} CFileManager gFileManager;\par
00089 \par
00090     {\cf17 template}<{\cf17 class} Type> {\cf18 void} CFileManager::read(std::ifstream& file, Type& data)\par
00091     \{\par
00092         ThrowIfFalse(file.is_open(), {\cf22 "CFileManager::read() failed. The given ifstream is not open."});\par
00093         ThrowIfTrue(file.bad(), {\cf22 "CFileManager::read() failed. The given ifstream is bad."});\par
00094 \par
00095         {\cf18 size_t} stTypeSize = {\cf17 sizeof}(Type);\par
00096         file.read(({\cf18 char}*)&data, stTypeSize);\par
00097         ThrowIfTrue(file.bad(), {\cf22 "CFileManager::read() failed. The given ifstream is bad."});\par
00098     \}\par
00099 \par
00100     {\cf17 template}<{\cf17 class} Type> {\cf18 void} CFileManager::write(std::ofstream& file, Type& data)\par
00101     \{\par
00102         ThrowIfFalse(file.is_open(), {\cf22 "CFileManager::write() failed. The given ofstream is not open."});\par
00103         ThrowIfTrue(file.bad(), {\cf22 "CFileManager::write() failed. The given ofstream is bad."});\par
00104 \par
00105         {\cf18 size_t} stTypeSize = {\cf17 sizeof}(Type);\par
00106         file.write(({\cf18 char}*)&data, stTypeSize);\par
00107         ThrowIfTrue(file.bad(), {\cf22 "CFileManager::write() failed. The given ofstream is bad."});\par
00108     \}\par
00109 \par
00110 \}   {\cf20 // namespace DCL}\par
00111 \par
00112 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FileMemory.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileMemory.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileMemory.cpp}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "FileMemory.h"}\par
00002 {\cf21 #include "FileManager.h"}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     CFileMemory::CFileMemory()\par
00007     \{\par
00008         _mpchDataStart = 0;\par
00009         _mstDataSizeBytes = 0;\par
00010         _mpchSeekData = 0;\par
00011         _mstSeekPos = 0;\par
00012         _mbIsOK = {\cf17 true};\par
00013     \}\par
00014 \par
00015     CFileMemory::~CFileMemory()\par
00016     \{\par
00017         free();\par
00018     \}\par
00019 \par
00020     {\cf18 void} CFileMemory::free({\cf18 void})\par
00021     \{\par
00022         {\cf19 if} (_mpchDataStart)\par
00023         \{\par
00024             {\cf17 delete} _mpchDataStart;\par
00025             _mpchDataStart = 0;\par
00026             _mstDataSizeBytes = 0;\par
00027             _mpchSeekData = 0;\par
00028             _mstSeekPos = 0;\par
00029         \}\par
00030         _mbIsOK = {\cf17 true};\par
00031     \}\par
00032 \par
00033     {\cf18 void} CFileMemory::setFromFile({\cf17 const} std::string& strFilename)\par
00034     \{\par
00035         ThrowIfFalse(gFileManager.getFileExists(strFilename), {\cf22 "CFileMemory::setFromFile(\\""} + strFilename + {\cf22 "\\") failed. Given filename could not be found."});\par
00036 \par
00037         {\cf20 // Free CFileMemory object incase it's been used before}\par
00038         free();\par
00039 \par
00040         {\cf20 // Get file size}\par
00041         std::ifstream ifstream(strFilename, std::ios::binary | std::ios::ate);\par
00042         ThrowIfFalse(ifstream.is_open(), {\cf22 "CFileMemory::setFromFile(\\""} + strFilename + {\cf22 "\\") failed. Given filename could not be opened."});\par
00043         _mstDataSizeBytes = ifstream.tellg();\par
00044         ifstream.seekg(std::ios::beg);\par
00045 \par
00046         {\cf20 // Set members of CFileMemory object and attempt to read in the data from file into it}\par
00047         _mpchDataStart = {\cf17 new} {\cf18 char}[_mstDataSizeBytes];\par
00048         _mpchSeekData = _mpchDataStart;\par
00049         ThrowIfFalse(_mpchDataStart, {\cf22 "CFileMemory::setFromFile(\\""} + strFilename + {\cf22 "\\") failed. Unable to allocate memory for data from file."});\par
00050         ifstream.read(_mpchDataStart, _mstDataSizeBytes);\par
00051         ThrowIfFalse(ifstream.good(), {\cf22 "CFileMemory::setFromFile(\\""} + strFilename + {\cf22 "\\") failed. Error whilst reading in data from file."});\par
00052         ifstream.close();\par
00053     \}\par
00054 \par
00055     {\cf18 void} CFileMemory::setFromMem({\cf17 const} {\cf18 char}* pData, {\cf18 size_t} stDataLength)\par
00056     \{\par
00057         {\cf20 // Make sure given values are valid}\par
00058         ThrowIfFalse(stDataLength, {\cf22 "CFileMemory::setFromMem() failed. Data length given is zero."});\par
00059         ThrowIfFalse(pData, {\cf22 "CFileMemory::setFromMem() failed. Given memory address is zero."});\par
00060 \par
00061         {\cf20 // Free CFileMemory object incase it's been used before}\par
00062         free();\par
00063 \par
00064         _mstDataSizeBytes = stDataLength;\par
00065         _mpchDataStart = {\cf17 new} {\cf18 char}[stDataLength];\par
00066         ThrowIfFalse(_mpchDataStart, {\cf22 "CFileMemory::setFromMem() failed. Unable to allocate memory for storing data."});\par
00067         _mpchSeekData = _mpchDataStart;\par
00068         memcpy(_mpchDataStart, pData, stDataLength);\par
00069     \}\par
00070 \par
00071     {\cf18 void} CFileMemory::saveToFile({\cf17 const} std::string& strFilename)\par
00072     \{\par
00073         {\cf20 // Make sure we've got data to save}\par
00074         ThrowIfFalse(_mpchDataStart, {\cf22 "CFileMemory::saveToFile(\\""} + strFilename + {\cf22 "\\") failed. There is no data to save to file."});\par
00075 \par
00076         {\cf20 // Attempt to open for writing}\par
00077         std::ofstream file(strFilename, std::ios::binary | std::ios::trunc);\par
00078         ThrowIfFalse(file.is_open(), {\cf22 "CFileMemory::saveToFile(\\""} + strFilename + {\cf22 "\\") failed. Unable to open file for writing."});\par
00079 \par
00080         {\cf20 // Attempt to write data to file}\par
00081         file.write(_mpchDataStart, _mstDataSizeBytes);\par
00082         ThrowIfFalse(file.good(), {\cf22 "CFileMemory::saveToFile(\\""} + strFilename + {\cf22 "\\") failed. Error occurred whilst writing data to file."});\par
00083         file.close();\par
00084     \}\par
00085 \par
00086     {\cf18 void} CFileMemory::appendToFile(std::ofstream& file)\par
00087     \{\par
00088         {\cf20 // Make sure we've got data to save}\par
00089         ThrowIfFalse(_mpchDataStart, {\cf22 "CFileMemory::appendToFile() failed. There is no data to append to file."});\par
00090 \par
00091         {\cf20 // Make sure given file is both good and open}\par
00092         ThrowIfFalse(file.is_open(), {\cf22 "CFileMemory::appendToFile() failed. Given file is not open for writing."});\par
00093         ThrowIfFalse(file.good(), {\cf22 "CFileMemory::appendToFile() failed. Given file is not good."});\par
00094 \par
00095         {\cf20 // Attempt to append data to file}\par
00096         file.write(_mpchDataStart, _mstDataSizeBytes);\par
00097         ThrowIfFalse(file.good(), {\cf22 "CFileMemory::appendToFile() failed. Error occurred whilst appending data to given file."});\par
00098     \}\par
00099 \par
00100     {\cf18 char}* CFileMemory::getData({\cf18 void})\par
00101     \{\par
00102         {\cf19 return} _mpchDataStart;\par
00103     \}\par
00104 \par
00105     {\cf18 size_t} CFileMemory::getDataSize({\cf18 void})\par
00106     \{\par
00107         {\cf19 return} _mstDataSizeBytes;\par
00108     \}\par
00109 \par
00110     {\cf18 void} CFileMemory::seekBegin({\cf18 void})\par
00111     \{\par
00112         _mpchSeekData = _mpchDataStart;\par
00113         _mstSeekPos = 0;\par
00114     \}\par
00115 \par
00116     {\cf18 void} CFileMemory::seekEnd({\cf18 void})\par
00117     \{\par
00118         _mpchSeekData = _mpchDataStart;\par
00119         _mpchSeekData += _mstDataSizeBytes - 1;\par
00120         _mstSeekPos = _mstDataSizeBytes - 1;\par
00121 \par
00122     \}\par
00123 \par
00124     {\cf18 bool} CFileMemory::seekToPos({\cf18 size_t} stOffsetBytesFromStart)\par
00125     \{\par
00126         {\cf19 if} (stOffsetBytesFromStart >= _mstDataSizeBytes)\par
00127         \{\par
00128             _mbIsOK = {\cf17 false};\par
00129             {\cf19 return} {\cf17 false};\par
00130         \}\par
00131 \par
00132         _mpchSeekData = _mpchDataStart;\par
00133         _mstSeekPos = 0;\par
00134 \par
00135         _mpchSeekData += stOffsetBytesFromStart;\par
00136         _mstSeekPos += stOffsetBytesFromStart;\par
00137         {\cf19 return} {\cf17 true};\par
00138     \}\par
00139 \par
00140     {\cf18 bool} CFileMemory::seekOffset({\cf18 size_t} stOffsetBytes)\par
00141     \{\par
00142         {\cf19 if} (_mstSeekPos + stOffsetBytes >= _mstDataSizeBytes)\par
00143         \{\par
00144             _mbIsOK = {\cf17 false};\par
00145             {\cf19 return} {\cf17 false};\par
00146         \}\par
00147 \par
00148         _mpchSeekData += stOffsetBytes;\par
00149         _mstSeekPos += stOffsetBytes;\par
00150         {\cf19 return} {\cf17 true};\par
00151     \}\par
00152 \par
00153     {\cf18 size_t} CFileMemory::seekGetPos({\cf18 void})\par
00154     \{\par
00155         {\cf19 return} _mstSeekPos;\par
00156     \}\par
00157 \par
00158     {\cf18 bool} CFileMemory::isOK({\cf18 void})\par
00159     \{\par
00160         {\cf19 return} _mbIsOK;\par
00161     \}\par
00162 \par
00163     {\cf18 void} CFileMemory::reset({\cf18 void})\par
00164     \{\par
00165         _mbIsOK = {\cf17 true};\par
00166         seekBegin();\par
00167     \}\par
00168 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileMemory.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileMemory.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileMemory.h}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CFileMemory}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FileMemory object holds the entirety of a file in memory. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b FileMemory.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FileMemory.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileMemory.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Files/FileMemory.h}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef FILEMEMORY_H}\par
00007 {\cf21 #define FILEMEMORY_H}\par
00008 \par
00009 {\cf20 //#include "../Core/Exceptions.h"}\par
00010 {\cf20 //#include "../Core/Singleton.h"}\par
00011 {\cf21 #include <string>}\par
00012 {\cf20 //#include <fstream>}\par
00013 \par
00014 {\cf17 namespace }DCL\par
00015 \{\par
00017     {\cf17 class }CFileMemory\par
00018     \{\par
00019     {\cf17 public}:\par
00021         CFileMemory();\par
00022 \par
00024         ~CFileMemory();\par
00025 \par
00027         {\cf18 void} free({\cf18 void});\par
00028 \par
00035         {\cf18 void} setFromFile({\cf17 const} std::string& strFilename);\par
00036 \par
00042         {\cf20 // If something went wrong, an exception occurs}\par
00043         {\cf18 void} setFromMem({\cf17 const} {\cf18 char}* pData, {\cf18 size_t} stDataLength);\par
00044 \par
00051         {\cf18 void} saveToFile({\cf17 const} std::string& strFilename);\par
00052 \par
00057         {\cf20 // If something went wrong, an exception occurs.}\par
00058         {\cf18 void} appendToFile(std::ofstream& file);\par
00059 \par
00065         {\cf18 char}* getData({\cf18 void});\par
00066 \par
00072         {\cf18 size_t} getDataSize({\cf18 void});\par
00073 \par
00075         {\cf18 void} seekBegin({\cf18 void});\par
00076 \par
00080         {\cf18 void} seekEnd({\cf18 void});\par
00081 \par
00088         {\cf18 bool} seekToPos({\cf18 size_t} stOffsetBytesFromStart);\par
00089 \par
00096         {\cf18 bool} seekOffset({\cf18 size_t} stOffsetBytes);\par
00097 \par
00101         {\cf18 size_t} seekGetPos({\cf18 void});\par
00102 \par
00109         {\cf17 template} <{\cf17 class} Type> {\cf18 bool} read(Type& out);\par
00110 \par
00114         {\cf18 bool} isOK({\cf18 void});\par
00115 \par
00117         {\cf18 void} reset({\cf18 void});\par
00118     {\cf17 private}:\par
00119 \par
00120         {\cf18 char}* _mpchDataStart;       \par
00121         {\cf18 size_t} _mstDataSizeBytes;   \par
00122 \par
00123         {\cf18 char}* _mpchSeekData;        \par
00124         {\cf18 size_t} _mstSeekPos;         \par
00125 \par
00126         {\cf18 bool} _mbIsOK;               \par
00127     \};\par
00128 \par
00129     {\cf17 template}<{\cf17 class} Type> {\cf18 bool} CFileMemory::read(Type& out)\par
00130     \{\par
00131         {\cf18 size_t} stTypeSize = {\cf17 sizeof}(Type);\par
00132 \par
00133         {\cf20 // Past end of array?}\par
00134         {\cf19 if} (_mstSeekPos + stTypeSize > _mstDataSizeBytes)\par
00135         \{\par
00136             _mbIsOK = {\cf17 false};\par
00137             {\cf19 return} {\cf17 false};\par
00138         \}\par
00139 \par
00140         {\cf20 // Store value}\par
00141         out = *(Type*)_mpchSeekData;\par
00142 \par
00143         {\cf20 // Increment pointer and position}\par
00144         _mpchSeekData += stTypeSize;\par
00145         _mstSeekPos += stTypeSize;\par
00146         {\cf19 return} {\cf17 true};\par
00147     \}\par
00148 \par
00149 \}   {\cf20 // namespace DCL}\par
00150 \par
00151 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Image.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/Image.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/Image.cpp}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Image.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 {\cf21 #include "../Core/Utilities.h"}\par
00004 {\cf21 #include "../Math/Vector3f.h"}\par
00005 \par
00006 {\cf21 #define STB_IMAGE_IMPLEMENTATION}\par
00007 {\cf21 #include "stb_image.h"}\par
00008 \par
00009 {\cf21 #define STB_IMAGE_WRITE_IMPLEMENTATION}\par
00010 {\cf21 #include "stb_image_write.h"}\par
00011 \par
00012 {\cf17 namespace }DCL\par
00013 \{\par
00014     CImage::CImage()\par
00015     \{\par
00016         _mpData = 0;\par
00017         _muiDataSize = 0;\par
00018         free();\par
00019     \}\par
00020 \par
00021     CImage::~CImage()\par
00022     \{\par
00023         free();\par
00024     \}\par
00025 \par
00026     CImage& CImage::operator=({\cf17 const} CImage& other)\par
00027     \{\par
00028         {\cf20 // Guard against self assignment}\par
00029         {\cf19 if} ({\cf17 this} == &other)\par
00030             {\cf19 return} *{\cf17 this};\par
00031 \par
00032         other.copyTo(*{\cf17 this});\par
00033         {\cf19 return} *{\cf17 this};\par
00034     \}\par
00035 \par
00036 \par
00037     {\cf18 void} CImage::free({\cf18 void})\par
00038     \{\par
00039         {\cf19 if} (_mpData)\par
00040         \{\par
00041             {\cf17 delete}[] _mpData;\par
00042             _mpData = NULL;\par
00043             _muiDataSize = 0;\par
00044         \}\par
00045         _miWidth = _miHeight = _miNumChannels = 0;\par
00046     \}\par
00047 \par
00048     {\cf18 void} CImage::createBlank({\cf18 unsigned} {\cf18 int} iWidth, {\cf18 unsigned} {\cf18 int} iHeight, {\cf18 unsigned} {\cf18 short} iNumChannels)\par
00049     \{\par
00050         free();\par
00051         ThrowIfTrue(iWidth < 1, {\cf22 "CImage::createBlank() failed as given width < 1."});\par
00052         ThrowIfTrue(iHeight < 1, {\cf22 "CImage::createBlank() failed as given height < 1."});\par
00053         ThrowIfTrue(iNumChannels < 3, {\cf22 "CImage::createBlank() failed as given number of channels < 1. (Only 3 or 4 is valid)"});\par
00054         ThrowIfTrue(iNumChannels > 4, {\cf22 "CImage::createBlank() failed as given number of channels > 4. (Only 3 or 4 is valid)"});\par
00055 \par
00056         _miWidth = iWidth;\par
00057         _miHeight = iHeight;\par
00058         _miNumChannels = iNumChannels;\par
00059         _muiDataSize = _miWidth * _miHeight * _miNumChannels;\par
00060         _mpData = {\cf17 new} {\cf18 unsigned} {\cf18 char}[_muiDataSize];\par
00061         ThrowIfTrue(!_mpData, {\cf22 "CImage::createBlank() failed to allocate memory."});\par
00062 \par
00063         {\cf20 // Zero out the new memory all to zero}\par
00064         {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < _muiDataSize; ++i)\par
00065         \{\par
00066             _mpData[i] = 0;\par
00067         \}\par
00068     \}\par
00069 \par
00070     {\cf18 bool} CImage::load({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipForOpenGL)\par
00071     \{\par
00072         free();\par
00073         stbi_set_flip_vertically_on_load(bFlipForOpenGL);\par
00074 \par
00075         {\cf20 // Get number of channels in the image file}\par
00076         {\cf18 int} iDims[2];\par
00077         {\cf18 int} iNumChannels = 3;\par
00078         loadInfo(strFilename, iDims[0], iDims[1], iNumChannels);\par
00079         stbi_uc* pixels = 0;\par
00080         {\cf19 if} (4 == iNumChannels)\par
00081             pixels = stbi_load(strFilename.c_str(), &_miWidth, &_miHeight, &_miNumChannels, STBI_rgb_alpha);\par
00082         {\cf19 else} {\cf19 if} (3 == iNumChannels)\par
00083             pixels = stbi_load(strFilename.c_str(), &_miWidth, &_miHeight, &_miNumChannels, STBI_rgb);\par
00084         {\cf19 else} {\cf19 if} (1 == iNumChannels)\par
00085             pixels = stbi_load(strFilename.c_str(), &_miWidth, &_miHeight, &_miNumChannels, 1);\par
00086 \par
00087         {\cf19 if} (!pixels)\par
00088             {\cf19 return} {\cf17 false};\par
00089 \par
00090         {\cf20 // If number of channels is 1, then we convert that 1 channel to 3 and duplicate the R to G and B}\par
00091         {\cf19 if} (1 == iNumChannels)\par
00092         \{\par
00093             _miNumChannels = 3;\par
00094         \}\par
00095 \par
00096         {\cf20 // Compute size and allocate}\par
00097         _muiDataSize = _miWidth * _miHeight * _miNumChannels;\par
00098         _mpData = {\cf17 new} {\cf18 unsigned} {\cf18 char}[_muiDataSize];\par
00099 \par
00100         {\cf19 if} (1 != iNumChannels)\par
00101             memcpy(_mpData, pixels, {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(_muiDataSize));\par
00102         {\cf19 else} {\cf20 // We need to copy the R to G and B}\par
00103         \{\par
00104             {\cf18 unsigned} {\cf18 int} iPixelIndex = 0;\par
00105             {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < _muiDataSize; i += 3)\par
00106             \{\par
00107                 _mpData[i] = pixels[iPixelIndex];\par
00108                 _mpData[i + 1] = pixels[iPixelIndex];\par
00109                 _mpData[i + 2] = pixels[iPixelIndex];\par
00110                 iPixelIndex++;\par
00111             \}\par
00112         \}\par
00113         stbi_image_free(pixels);\par
00114         {\cf19 return} {\cf17 true};\par
00115     \}\par
00116 \par
00117     {\cf18 bool} CImage::loadInfo({\cf17 const} std::string& strFilename, {\cf18 int}& iWidth, {\cf18 int}& iHeight, {\cf18 int}& iComponentCount)\par
00118     \{\par
00119         {\cf20 // To query the width, height and component count of an image without having to}\par
00120         {\cf20 // decode the full file, you can use the stbi_info family of functions:}\par
00121         {\cf20 //}\par
00122         {\cf20 //   int ix,iy,n,ok;}\par
00123         {\cf20 //   ok = stbi_info(filename, &ix, &iy, &n);}\par
00124         {\cf20 //   // returns ok=1 and sets ix, iy, n if image is a supported format,}\par
00125         {\cf20 //   // 0 otherwise.}\par
00126         {\cf19 return} ({\cf18 bool})stbi_info(strFilename.c_str(), &iWidth, &iHeight, &iComponentCount);\par
00127     \}\par
00128 \par
00129     {\cf18 void} CImage::saveAsBMP({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipOnSave){\cf17  const}\par
00130 {\cf17     }\{\par
00131         ThrowIfTrue(!_mpData, {\cf22 "CImage::saveAsBMP() failed. Image not yet created."});\par
00132         stbi_flip_vertically_on_write(bFlipOnSave); {\cf20 // flag is non-zero to flip data vertically}\par
00133         ThrowIfTrue(!stbi_write_bmp(strFilename.c_str(), _miWidth, _miHeight, _miNumChannels, _mpData), {\cf22 "CImage::saveAsBMP(\\""} + strFilename + {\cf22 "\\") failed.Image failed to be written."});\par
00134     \}\par
00135 \par
00136     {\cf18 void} CImage::saveAsJPG({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipOnSave, {\cf18 int} iQuality){\cf17  const}\par
00137 {\cf17     }\{\par
00138         ThrowIfTrue(!_mpData, {\cf22 "CImage::saveAsJPG() failed. Image not yet created."});\par
00139         stbi_flip_vertically_on_write(bFlipOnSave); {\cf20 // flag is non-zero to flip data vertically}\par
00140         ThrowIfTrue(!stbi_write_jpg(strFilename.c_str(), _miWidth, _miHeight, _miNumChannels, _mpData, iQuality), {\cf22 "CImage::saveAsJPG(\\""} + strFilename + {\cf22 "\\") failed.Image failed to be written."});\par
00141     \}\par
00142 \par
00143     {\cf18 void} CImage::saveAsPNG({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipOnSave){\cf17  const}\par
00144 {\cf17     }\{\par
00145         ThrowIfTrue(!_mpData, {\cf22 "CImage::saveAsPNG() failed. Image not yet created."});\par
00146         stbi_flip_vertically_on_write(bFlipOnSave); {\cf20 // flag is non-zero to flip data vertically}\par
00147         ThrowIfTrue(!stbi_write_png(strFilename.c_str(), _miWidth, _miHeight, _miNumChannels, _mpData, _miWidth * _miNumChannels), {\cf22 "CImage::saveAsPNG(\\""} + strFilename + {\cf22 "\\") failed.Image failed to be written."});\par
00148     \}\par
00149 \par
00150     {\cf18 void} CImage::saveAsTGA({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipOnSave){\cf17  const}\par
00151 {\cf17     }\{\par
00152         ThrowIfTrue(!_mpData, {\cf22 "CImage::saveAsTGA() failed. Image not yet created."});\par
00153         stbi_flip_vertically_on_write(bFlipOnSave); {\cf20 // flag is non-zero to flip data vertically}\par
00154         ThrowIfTrue(!stbi_write_tga(strFilename.c_str(), _miWidth, _miHeight, _miNumChannels, _mpData), {\cf22 "CImage::saveAsTGA(\\""} + strFilename + {\cf22 "\\") failed.Image failed to be written."});\par
00155     \}\par
00156 \par
00157     {\cf18 void} CImage::fill({\cf18 unsigned} {\cf18 char} ucRed, {\cf18 unsigned} {\cf18 char} ucGreen, {\cf18 unsigned} {\cf18 char} ucBlue, {\cf18 unsigned} {\cf18 char} ucAlpha)\par
00158     \{\par
00159         ThrowIfTrue(!_mpData, {\cf22 "CImage::fill() failed. Image not yet created."});\par
00160 \par
00161         {\cf18 unsigned} {\cf18 int} i = 0;\par
00162 \par
00163         {\cf20 // 3 Colour channels}\par
00164         {\cf19 if} (3 == _miNumChannels)\par
00165         \{\par
00166             {\cf19 while} (i < _muiDataSize)\par
00167             \{\par
00168                 _mpData[i] = ucRed;\par
00169                 _mpData[i + 1] = ucGreen;\par
00170                 _mpData[i + 2] = ucBlue;\par
00171                 i += _miNumChannels;\par
00172             \}\par
00173         \}\par
00174 \par
00175         {\cf20 // 4 colour channels}\par
00176         {\cf19 if} (4 == _miNumChannels)\par
00177         \{\par
00178             {\cf19 while} (i < _muiDataSize)\par
00179             \{\par
00180                 _mpData[i] = ucRed;\par
00181                 _mpData[i + 1] = ucGreen;\par
00182                 _mpData[i + 2] = ucBlue;\par
00183                 _mpData[i + 3] = ucAlpha;\par
00184                 i += _miNumChannels;\par
00185             \}\par
00186         \}\par
00187     \}\par
00188 \par
00189     {\cf18 unsigned} {\cf18 char}* CImage::getData({\cf18 void}){\cf17  const}\par
00190 {\cf17     }\{\par
00191         {\cf19 return} _mpData;\par
00192     \}\par
00193 \par
00194     {\cf18 unsigned} {\cf18 int} CImage::getDataSize({\cf18 void}){\cf17  const}\par
00195 {\cf17     }\{\par
00196         {\cf19 return} _muiDataSize;\par
00197     \}\par
00198 \par
00199     {\cf18 unsigned} {\cf18 int} CImage::getWidth({\cf18 void}){\cf17  const}\par
00200 {\cf17     }\{\par
00201         {\cf19 return} _miWidth;\par
00202     \}\par
00203 \par
00204     {\cf18 unsigned} {\cf18 int} CImage::getHeight({\cf18 void}){\cf17  const}\par
00205 {\cf17     }\{\par
00206         {\cf19 return} _miHeight;\par
00207     \}\par
00208 \par
00209     CVector2f CImage::getDimensions({\cf18 void}){\cf17  const}\par
00210 {\cf17     }\{\par
00211         CVector2f dims;\par
00212         dims.set({\cf18 float}(_miWidth), {\cf18 float}(_miHeight));\par
00213         {\cf19 return} dims;\par
00214     \}\par
00215 \par
00216     {\cf18 unsigned} {\cf18 int} CImage::getNumChannels({\cf18 void}){\cf17  const}\par
00217 {\cf17     }\{\par
00218         {\cf19 return} _miNumChannels;\par
00219     \}\par
00220 \par
00221     {\cf18 bool} CImage::getDimsArePowerOfTwo({\cf18 void}){\cf17  const}\par
00222 {\cf17     }\{\par
00223         {\cf18 int} iX = 1;\par
00224         {\cf18 int} iY = 1;\par
00225         {\cf19 while} (iX < _miWidth)\par
00226             iX *= 2;\par
00227         {\cf19 while} (iY < _miHeight)\par
00228             iY *= 2;\par
00229         {\cf19 if} (iX != _miWidth || iY != _miHeight)\par
00230             {\cf19 return} {\cf17 false};\par
00231         {\cf19 return} {\cf17 true};\par
00232     \}\par
00233 \par
00234     {\cf18 void} CImage::swapRedAndBlue({\cf18 void})\par
00235     \{\par
00236         ThrowIfTrue(!_mpData, {\cf22 "CImage::swapRedAndBlue() failed. Image not yet created."});\par
00237 \par
00238         {\cf18 unsigned} {\cf18 int} i = 0;\par
00239         {\cf18 int} i2;\par
00240         {\cf18 unsigned} {\cf18 char} chTemp;\par
00241         {\cf19 while} (i < _muiDataSize)\par
00242         \{\par
00243             i2 = i + 2;\par
00244             chTemp = _mpData[i];\par
00245             _mpData[i] = _mpData[i2];\par
00246             _mpData[i2] = chTemp;\par
00247             i += _miNumChannels;\par
00248         \}\par
00249     \}\par
00250 \par
00251     {\cf18 void} CImage::flipVertically({\cf18 void})\par
00252     \{\par
00253         ThrowIfTrue(!_mpData, {\cf22 "CImage::flipVertically() failed. Image not yet created."});\par
00254 \par
00255         {\cf20 // Size of a row}\par
00256         {\cf18 unsigned} {\cf18 int} iRowSize = _miWidth * _miNumChannels;\par
00257 \par
00258         {\cf20 // Allocate new flipped image}\par
00259         {\cf18 unsigned} {\cf18 char}* pNewImageStartAddress = {\cf17 new} {\cf18 unsigned} {\cf18 char}[_muiDataSize];\par
00260         {\cf18 unsigned} {\cf18 char}* pNewImage = pNewImageStartAddress;\par
00261         ThrowIfTrue(0 == pNewImage, {\cf22 "CImage::flipVertically() failed to allocate memory."});\par
00262 \par
00263         {\cf20 // Get pointer to current image}\par
00264         {\cf18 unsigned} {\cf18 char}* pOldImage = _mpData;\par
00265         {\cf20 // Increment old image pointer to point to last row}\par
00266         pOldImage += iRowSize * (_miHeight - 1);\par
00267 \par
00268         {\cf20 // Copy each row into new image}\par
00269         {\cf18 unsigned} {\cf18 int} iRowSizeBytes = iRowSize * {\cf17 sizeof}({\cf18 unsigned} char);\par
00270         {\cf19 for} ({\cf18 int} iRow = 0; iRow < _miHeight; ++iRow)\par
00271         \{\par
00272             memcpy(pNewImage, pOldImage, iRowSizeBytes);\par
00273             {\cf20 // Adjust pointers}\par
00274             pNewImage += iRowSizeBytes;\par
00275             pOldImage -= iRowSizeBytes;\par
00276         \}\par
00277         {\cf20 // Now pNewImage contains flipped image data}\par
00278         {\cf17 delete}[] _mpData;   {\cf20 // Delete old image data}\par
00279         _mpData = pNewImageStartAddress;    {\cf20 // Make image data point to the new data}\par
00280     \}\par
00281 \par
00282     {\cf18 void} CImage::invert({\cf18 bool} bInvertColour, {\cf18 bool} bInvertAlpha)\par
00283     \{\par
00284         ThrowIfTrue(!_mpData, {\cf22 "CImage::invert() failed. Image not yet created."});\par
00285 \par
00286         {\cf18 unsigned} {\cf18 int} i = 0;\par
00287         {\cf18 int} iIndex;\par
00288         {\cf19 if} (bInvertColour)\par
00289         \{\par
00290             {\cf19 while} (i < _muiDataSize)\par
00291             \{\par
00292                 iIndex = i;\par
00293                 _mpData[iIndex] = 255 - _mpData[iIndex]; ++iIndex;\par
00294                 _mpData[iIndex] = 255 - _mpData[iIndex]; ++iIndex;\par
00295                 _mpData[iIndex] = 255 - _mpData[iIndex];\par
00296                 i += _miNumChannels;\par
00297             \}\par
00298         \}\par
00299 \par
00300         {\cf19 if} (_miNumChannels == 4 && bInvertAlpha)\par
00301         \{\par
00302             i = 3;\par
00303             {\cf19 while} (i < _muiDataSize)\par
00304             \{\par
00305                 _mpData[i] = 255 - _mpData[i];\par
00306                 i += _miNumChannels;\par
00307             \}\par
00308         \}\par
00309     \}\par
00310 \par
00311     {\cf18 void} CImage::greyscaleSimple({\cf18 void})\par
00312     \{\par
00313         ThrowIfTrue(!_mpData, {\cf22 "CImage::greyscaleSimple() failed. Image not yet created."});\par
00314 \par
00315         {\cf18 unsigned} {\cf18 int} i = 0;\par
00316         {\cf18 float} f1Over3 = 1.0f / 3.0f;\par
00317         {\cf18 float} fTmp;\par
00318         {\cf18 unsigned} {\cf18 char} cTmp;\par
00319         {\cf19 while} (i < _muiDataSize)\par
00320         \{\par
00321             fTmp = float(_mpData[i]);\par
00322             fTmp += float(_mpData[i + 1]);\par
00323             fTmp += float(_mpData[i + 2]);\par
00324             fTmp *= f1Over3;\par
00325             cTmp = ({\cf18 unsigned} char)fTmp;\par
00326             _mpData[i] = cTmp;\par
00327             _mpData[i + 1] = cTmp;\par
00328             _mpData[i + 2] = cTmp;\par
00329             i += _miNumChannels;\par
00330         \}\par
00331     \}\par
00332 \par
00333 \par
00334     {\cf18 void} CImage::greyscale({\cf18 float} fRedSensitivity, {\cf18 float} fGreenSensitivity, {\cf18 float} fBlueSensitivity)\par
00335     \{\par
00336         ThrowIfTrue(!_mpData, {\cf22 "CImage::greyscale() failed. Image not yet created."});\par
00337 \par
00338         CVector3f vCol(fRedSensitivity, fGreenSensitivity, fBlueSensitivity);\par
00339 \par
00340         {\cf18 unsigned} {\cf18 int} i = 0;\par
00341         {\cf18 float} fTmp;\par
00342         {\cf18 unsigned} {\cf18 char} cTmp;\par
00343         {\cf19 while} (i < _muiDataSize)\par
00344         \{\par
00345             fTmp = 0.0f;\par
00346             fTmp = float(_mpData[i]) * vCol.x;\par
00347             fTmp += float(_mpData[i + 1]) * vCol.y;\par
00348             fTmp += float(_mpData[i + 2]) * vCol.z;\par
00349             cTmp = ({\cf18 unsigned} char)fTmp;\par
00350             _mpData[i] = cTmp;\par
00351             _mpData[i + 1] = cTmp;\par
00352             _mpData[i + 2] = cTmp;\par
00353             i += _miNumChannels;\par
00354         \}\par
00355     \}\par
00356 \par
00357     {\cf18 void} CImage::adjustBrightness({\cf18 int} iAmount)\par
00358     \{\par
00359         ThrowIfTrue(!_mpData, {\cf22 "CImage::adjustBrightness() failed. Image not yet created."});\par
00360 \par
00361         {\cf18 unsigned} {\cf18 int} i = 0;\par
00362         {\cf18 int} iCol;\par
00363         {\cf19 while} (i < _muiDataSize)\par
00364         \{\par
00365             iCol = (int)_mpData[i] + iAmount;\par
00366             clamp(iCol, 0, 255);\par
00367             _mpData[i] = {\cf18 unsigned} char(iCol);\par
00368 \par
00369             iCol = (int)_mpData[i + 1] + iAmount;\par
00370             clamp(iCol, 0, 255);\par
00371             _mpData[i + 1] = {\cf18 unsigned} char(iCol);\par
00372 \par
00373             iCol = (int)_mpData[i + 2] + iAmount;\par
00374             clamp(iCol, 0, 255);\par
00375             _mpData[i + 2] = {\cf18 unsigned} char(iCol);\par
00376             i += _miNumChannels;\par
00377         \}\par
00378     \}\par
00379 \par
00380     {\cf18 void} CImage::adjustContrast({\cf18 int} iAmount)\par
00381     \{\par
00382         ThrowIfTrue(!_mpData, {\cf22 "CImage::adjustContrast() failed. Image not yet created."});\par
00383 \par
00384         clamp(iAmount, -100, 100);\par
00385         {\cf18 double} dPixel;\par
00386         {\cf18 double} d1Over255 = 1.0 / 255.0;\par
00387         {\cf18 double} dContrast = (100.0 + double(iAmount)) * 0.01; {\cf20 // 0 and 2}\par
00388         dContrast *= dContrast; {\cf20 // 0 and 4}\par
00389         {\cf18 unsigned} {\cf18 int} i = 0;\par
00390         {\cf18 int} iIndex;\par
00391         {\cf19 while} (i < _muiDataSize)\par
00392         \{\par
00393             iIndex = i;\par
00394             dPixel = double(_mpData[iIndex]) * d1Over255;\par
00395             dPixel -= 0.5;\par
00396             dPixel *= dContrast;\par
00397             dPixel += 0.5;\par
00398             dPixel *= 255;\par
00399             clamp(dPixel, 0.0, 255.0);\par
00400             _mpData[iIndex] = {\cf18 unsigned} char(dPixel);\par
00401             ++iIndex;\par
00402 \par
00403             dPixel = double(_mpData[iIndex]) * d1Over255;\par
00404             dPixel -= 0.5;\par
00405             dPixel *= dContrast;\par
00406             dPixel += 0.5;\par
00407             dPixel *= 255;\par
00408             clamp(dPixel, 0.0, 255.0);\par
00409             _mpData[iIndex] = {\cf18 unsigned} char(dPixel);\par
00410             ++iIndex;\par
00411 \par
00412             dPixel = double(_mpData[iIndex]) * d1Over255;\par
00413             dPixel -= 0.5;\par
00414             dPixel *= dContrast;\par
00415             dPixel += 0.5;\par
00416             dPixel *= 255;\par
00417             clamp(dPixel, 0.0, 255.0);\par
00418             _mpData[iIndex] = {\cf18 unsigned} char(dPixel);\par
00419 \par
00420             i += _miNumChannels;\par
00421         \}\par
00422     \}\par
00423 \par
00424     {\cf18 void} CImage::copyTo(CImage& destImage){\cf17  const}\par
00425 {\cf17     }\{\par
00426         ThrowIfTrue(!_mpData, {\cf22 "CImage::copyTo() failed. Source image not yet created."});\par
00427 \par
00428         {\cf20 // If destination image is the same as this one, do nothing}\par
00429         {\cf19 if} (destImage._mpData == this->_mpData)\par
00430             {\cf19 return};\par
00431 \par
00432         destImage.free();\par
00433         destImage.createBlank(_miWidth, _miHeight, _miNumChannels);\par
00434         memcpy(destImage._mpData, _mpData, {\cf17 sizeof}({\cf18 unsigned} {\cf18 char}) * _muiDataSize);\par
00435     \}\par
00436 \par
00437     {\cf18 void} CImage::copyRectTo(CImage& destImage, {\cf18 int} iSrcPosX, {\cf18 int} iSrcPosY, {\cf18 int} iSrcWidth, {\cf18 int} iSrcHeight, {\cf18 int} iDestPosX, {\cf18 int} iDestPosY){\cf17  const}\par
00438 {\cf17     }\{\par
00439         {\cf20 // Check that both images have data}\par
00440         ThrowIfTrue(!_mpData, {\cf22 "CImage::copyRectTo() failed. Source image not yet created."});\par
00441         ThrowIfTrue(!destImage._mpData, {\cf22 "CImage::copyRectTo() failed. Destination image not yet created."});\par
00442 \par
00443         {\cf20 // Compute source rect}\par
00444         {\cf18 int} iSrcLeft = iSrcPosX;\par
00445         {\cf18 int} iSrcBot = iSrcPosY;\par
00446         {\cf18 int} iSrcRight = iSrcLeft + iSrcWidth;\par
00447         {\cf18 int} iSrcTop = iSrcBot + iSrcHeight;\par
00448         {\cf20 // Compute destination rect}\par
00449         {\cf18 int} iDstLeft = iDestPosX;\par
00450         {\cf18 int} iDstBot = iDestPosY;\par
00451         {\cf18 int} iDstRight = iDstLeft + iSrcWidth;\par
00452         {\cf18 int} iDstTop = iDstBot + iSrcHeight;\par
00453 \par
00454         {\cf20 // The above may be invalid due to different sizes, invalid positions, dims etc.}\par
00455         {\cf20 // Invalid starting positions}\par
00456         {\cf19 if} (iSrcLeft >= _miWidth)\par
00457             {\cf19 return};\par
00458         {\cf19 if} (iSrcBot >= _miHeight)\par
00459             {\cf19 return};\par
00460         {\cf19 if} (iDstLeft >= destImage._miWidth)\par
00461             {\cf19 return};\par
00462         {\cf19 if} (iDstBot >= destImage._miHeight)\par
00463             {\cf19 return};\par
00464         {\cf20 // Clamp right and top to edges of their respective images}\par
00465         clamp(iSrcRight, iSrcLeft, _miWidth);\par
00466         clamp(iSrcTop, iSrcBot, _miHeight);\par
00467         clamp(iDstRight, iDstLeft, destImage._miWidth);\par
00468         clamp(iDstTop, iDstBot, destImage._miHeight);\par
00469         {\cf20 // Compute rect dims for both images}\par
00470         {\cf18 unsigned} {\cf18 int} iSrcRectWidth = iSrcRight - iSrcLeft;\par
00471         {\cf18 unsigned} {\cf18 int} iSrcRectHeight = iSrcTop - iSrcBot;\par
00472         {\cf18 unsigned} {\cf18 int} iDstRectWidth = iDstRight - iDstLeft;\par
00473         {\cf18 unsigned} {\cf18 int} iDstRectHeight = iDstTop - iDstBot;\par
00474         {\cf20 // Compute smallest rect}\par
00475         {\cf18 unsigned} {\cf18 int} iMinWidth = iSrcRectWidth;\par
00476         {\cf19 if} (iMinWidth > iDstRectWidth)\par
00477             iMinWidth = iDstRectWidth;\par
00478         {\cf18 unsigned} {\cf18 int} iMinHeight = iSrcRectHeight;\par
00479         {\cf19 if} (iMinHeight > iDstRectHeight)\par
00480             iMinHeight = iDstRectHeight;\par
00481         {\cf20 // If minimum = zero, then do nothing}\par
00482         {\cf19 if} (iMinWidth == 0)\par
00483             {\cf19 return};\par
00484         {\cf19 if} (iMinHeight == 0)\par
00485             {\cf19 return};\par
00486 \par
00487         {\cf18 unsigned} {\cf18 char} colTmp[4];\par
00488         {\cf18 unsigned} {\cf18 int} isx, isy;\par
00489         {\cf18 unsigned} {\cf18 int} idx, idy;\par
00490         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ix = 0; ix < iMinWidth; ++ix)\par
00491         \{\par
00492             {\cf19 for} ({\cf18 unsigned} {\cf18 int} iy = 0; iy < iMinHeight; ++iy)\par
00493             \{\par
00494                 isx = iSrcLeft + ix;\par
00495                 isy = iSrcBot + iy;\par
00496                 idx = iDstLeft + ix;\par
00497                 idy = iDstBot + iy;\par
00498                 getPixel(isx, isy, colTmp[0], colTmp[1], colTmp[2], colTmp[3]);\par
00499                 destImage.setPixel(idx, idy, colTmp[0], colTmp[1], colTmp[2], colTmp[3]);\par
00500             \}\par
00501         \}\par
00502     \}\par
00503 \par
00504     {\cf18 void} CImage::copyToAddBorder(CImage& outputImage){\cf17  const}\par
00505 {\cf17     }\{\par
00506         ThrowIfTrue(!_mpData, {\cf22 "CImage::copyToAddBorder() failed. Image data doesn't exist."});\par
00507 \par
00508         {\cf20 // Compute new larger dimensions and create the larger image}\par
00509         {\cf18 int} newWidth = _miWidth + 2;\par
00510         {\cf18 int} newHeight = _miHeight + 2;\par
00511         outputImage.createBlank(newWidth, newHeight, _miNumChannels);\par
00512 \par
00513         {\cf20 // Copy this image to the centre of the larger image}\par
00514         copyRectTo(outputImage, 0, 0, _miWidth, _miHeight, 1, 1);\par
00515 \par
00516         {\cf20 // Now copy the edges of this image to the destination image}\par
00517         {\cf18 unsigned} {\cf18 char} r, g, b, a;\par
00518         {\cf18 int} heightOfOutputImageMinusOne = newHeight - 1;\par
00519         {\cf20 // Top and bottom edges}\par
00520         {\cf19 for} ({\cf18 int} iX = 0; iX < _miWidth; iX++)\par
00521         \{\par
00522             {\cf20 // Top pixel row}\par
00523             getPixel(iX, 0, r, g, b, a);\par
00524             outputImage.setPixel(iX + 1, 0, r, g, b, a);\par
00525 \par
00526             {\cf20 // Bottom pixel row}\par
00527             getPixel(iX, _miHeight - 1, r, g, b, a);\par
00528             outputImage.setPixel(iX + 1, heightOfOutputImageMinusOne, r, g, b, a);\par
00529         \}\par
00530         {\cf18 int} widthOfOutputImageMinusOne = newWidth - 1;\par
00531         {\cf20 // Left and right edges}\par
00532         {\cf19 for} ({\cf18 int} iY = 0; iY < _miHeight; iY++)\par
00533         \{\par
00534             {\cf20 // Left pixel column}\par
00535             getPixel(0, iY, r, g, b, a);\par
00536             outputImage.setPixel(0, iY + 1, r, g, b, a);\par
00537 \par
00538             {\cf20 // Right pixel column}\par
00539             getPixel(_miWidth - 1, iY, r, g, b, a);\par
00540             outputImage.setPixel(widthOfOutputImageMinusOne, iY + 1, r, g, b, a);\par
00541         \}\par
00542     \}\par
00543 \par
00544     {\cf18 void} CImage::rotateClockwise({\cf18 void})\par
00545     \{\par
00546         CImage oldImage;\par
00547         copyTo(oldImage);\par
00548 \par
00549         {\cf18 unsigned} {\cf18 char} col[4];\par
00550         {\cf18 int} idstX;\par
00551         {\cf18 int} idstY;\par
00552 \par
00553         {\cf20 // Non squared?}\par
00554         {\cf19 if} (_miWidth != _miHeight)\par
00555         \{\par
00556             createBlank(_miHeight, _miWidth, _miNumChannels);\par
00557         \}\par
00558 \par
00559         {\cf19 for} ({\cf18 int} isrcX = 0; isrcX < oldImage._miWidth; ++isrcX)\par
00560         \{\par
00561             idstY = _miHeight - isrcX - 1;\par
00562             {\cf19 for} ({\cf18 int} isrcY = 0; isrcY < oldImage._miHeight; ++isrcY)\par
00563             \{\par
00564                 idstX = isrcY;\par
00565                 oldImage.getPixel(isrcX, isrcY, col[0], col[1], col[2], col[3]);\par
00566                 setPixel(idstX, idstY, col[0], col[1], col[2], col[3]);\par
00567             \}\par
00568         \}\par
00569     \}\par
00570 \par
00571     {\cf18 void} CImage::edgeDetect(CImage& outputImage, {\cf18 unsigned} {\cf18 char} r, {\cf18 unsigned} {\cf18 char} g, {\cf18 unsigned} {\cf18 char} b)\par
00572     \{\par
00573         ThrowIfTrue(!_mpData, {\cf22 "CImage::edgeDetect() failed. Image data doesn't exist."});\par
00574         ThrowIfTrue(_miNumChannels < 3, {\cf22 "CImage::edgeDetect() failed. Some image data exists, but doesn't have enough colour channels."});\par
00575 \par
00576         outputImage.createBlank(_miWidth, _miHeight, 4);\par
00577         {\cf18 int} iX = 0;\par
00578         {\cf18 int} iY = 0;\par
00579         {\cf19 while} (iX < ({\cf18 int})_miWidth)\par
00580         \{\par
00581             {\cf19 while} (iY < ({\cf18 int})_miHeight)\par
00582             \{\par
00583                 {\cf19 if} (_isPixelEdge(iX, iY, r, g, b))\par
00584                     outputImage.setPixel(iX, iY, 255, 255, 255, 255);\par
00585                 {\cf19 else}\par
00586                     outputImage.setPixel(iX, iY, 0, 0, 0, 0);\par
00587                 ++iY;\par
00588             \}\par
00589             ++iX;\par
00590             iY = 0;\par
00591         \}\par
00592     \}\par
00593 \par
00594     {\cf18 void} CImage::removeAlphaChannel({\cf18 void})\par
00595     \{\par
00596         ThrowIfTrue(!_mpData, {\cf22 "CImage::removeAlphaChannel() failed. Image data doesn't exist."});\par
00597         ThrowIfTrue(_miNumChannels != 4, {\cf22 "CImage::removeAlphaChannel() failed. Some image data exists, but the alpha data doesn't exist (Image doesn't hold 4 channels)"});\par
00598 \par
00599         {\cf20 // Copy this image to a new tmp image}\par
00600         CImage old;\par
00601         copyTo(old);\par
00602 \par
00603         {\cf20 // Recreate this one, but with 3 channels}\par
00604         createBlank(old.getWidth(), old.getHeight(), 3);\par
00605 \par
00606         {\cf20 // Copy RGB from old to this...}\par
00607         {\cf18 unsigned} {\cf18 int} iIndex = 0;\par
00608         {\cf18 int} iIndexOld = 0;\par
00609         {\cf19 while} (iIndex < _muiDataSize)\par
00610         \{\par
00611             _mpData[iIndex] = old._mpData[iIndexOld];       {\cf20 // Red}\par
00612             _mpData[iIndex + 1] = old._mpData[iIndexOld + 1];   {\cf20 // Green}\par
00613             _mpData[iIndex + 2] = old._mpData[iIndexOld + 2];   {\cf20 // Blue}\par
00614             iIndex += 3;\par
00615             iIndexOld += 4;\par
00616         \}\par
00617     \}\par
00618 \par
00619     {\cf18 void} CImage::copyAlphaChannelToRGB({\cf18 void})\par
00620     \{\par
00621         ThrowIfTrue(!_mpData, {\cf22 "CImage::copyAlphaChannelToRGB() failed. Image data doesn't exist."});\par
00622         ThrowIfTrue(_miNumChannels != 4, {\cf22 "CImage::copyAlphaChannelToRGB() failed. Some image data exists, but the alpha data doesn't exist (Image doesn't hold 4 channels)"});\par
00623 \par
00624         {\cf18 unsigned} {\cf18 int} iIndex = 0;\par
00625         {\cf19 while} (iIndex < _muiDataSize)\par
00626         \{\par
00627             _mpData[iIndex] = _mpData[iIndex + 3];  {\cf20 // Red}\par
00628             _mpData[iIndex + 1] = _mpData[iIndex + 3];  {\cf20 // Green}\par
00629             _mpData[iIndex + 2] = _mpData[iIndex + 3];  {\cf20 // Blue}\par
00630             iIndex += 4;\par
00631         \}\par
00632     \}\par
00633 \par
00634     {\cf18 void} CImage::normalmap(CImage& outputImage, {\cf18 float} fScale){\cf17  const}\par
00635 {\cf17     }\{\par
00636         ThrowIfTrue(!_mpData, {\cf22 "CImage::normalmap() failed. Image data doesn't exist."});\par
00637 \par
00638         clamp(fScale, 0.0f, 1.0f);\par
00639 \par
00640         {\cf20 // Copy this image into a new one so this is left unaffected.}\par
00641         {\cf20 // This uses the copyToAddBorder() method which adds a border and copies the edge pixels to the new pixels in the border.}\par
00642         {\cf20 // This makes it so we don't have to mess around with edge cases.}\par
00643         CImage imageGreyscale;\par
00644         copyToAddBorder(imageGreyscale);\par
00645 \par
00646         {\cf20 // Greyscale the image}\par
00647         imageGreyscale.greyscaleSimple();\par
00648 \par
00649         {\cf20 // Create output image with the same size as this one}\par
00650         outputImage.createBlank(_miWidth, _miHeight, 3);\par
00651 \par
00652         {\cf20 // Now loop through greyscale image, computing each normal and storing in the output image.}\par
00653         {\cf18 unsigned} {\cf18 char} r[3], g[3], b[3], a;\par
00654         {\cf18 float} fX, fY, fZ;\par
00655         {\cf18 float} fLength;\par
00656         {\cf19 for} ({\cf18 int} y = 0; y < _miHeight; y++)\par
00657         \{\par
00658             {\cf19 for} ({\cf18 int} ix = 0; ix < _miWidth; ix++)\par
00659             \{\par
00660                 {\cf20 // we add +1 to imageGreyscale pixel positions as it has a border}\par
00661 \par
00662                 {\cf20 // Get height values of centre and surrounding pixels}\par
00663                 imageGreyscale.getPixel(ix + 1, y + 1, r[0], g[0], b[0], a);    {\cf20 // Current pixel}\par
00664                 imageGreyscale.getPixel(ix, y + 1, r[1], g[1], b[1], a);        {\cf20 // Left pixel}\par
00665                 imageGreyscale.getPixel(ix + 1, y + 2, r[2], g[2], b[2], a);    {\cf20 // Above pixel}\par
00666 \par
00667                 fX = float(r[1] - r[0]) / 255.0f;   {\cf20 // Convert to -1.0f to 1.0f}\par
00668                 fY = float(r[2] - r[0]) / 255.0f;   {\cf20 // ....}\par
00669                 fZ = fScale;\par
00670 \par
00671                 {\cf20 // Compute length of vector and normalize}\par
00672                 fLength = sqrt((fX * fX) + (fY * fY) + (fZ * fZ));\par
00673                 {\cf19 if} (areFloatsEqual(fLength, 0.0f))  {\cf20 // If length is nearly zero, just set as up vector}\par
00674                 \{\par
00675                     fX = 0.0f;\par
00676                     fY = 0.0f;\par
00677                     fZ = fScale;\par
00678                 \}\par
00679                 {\cf19 else}\par
00680                 \{\par
00681                     fX = fX / fLength;\par
00682                     fY = fY / fLength;\par
00683                     fZ = fZ / fLength;\par
00684                 \}\par
00685 \par
00686                 {\cf20 // Convert from -1, +1 to 0, 255}\par
00687                 fX += 1.0f; fX *= 127.0f;\par
00688                 fY += 1.0f; fY *= 127.0f;\par
00689                 fZ += 1.0f; fZ *= 127.0f;\par
00690                 r[0] = {\cf18 unsigned} char(fX);\par
00691                 g[0] = {\cf18 unsigned} char(fY);\par
00692                 b[0] = {\cf18 unsigned} char(fZ);\par
00693                 outputImage.setPixel(ix, y, r[0], g[0], b[0], a);\par
00694             \}\par
00695         \}\par
00696     \}\par
00697 \par
00698     {\cf18 void} CImage::drawColourWheel({\cf18 unsigned} {\cf18 int} iWidthAndHeightOfImage, {\cf18 unsigned} {\cf18 char} ucBrightness)\par
00699     \{\par
00700         ThrowIfTrue(iWidthAndHeightOfImage < 1, {\cf22 "CImage::drawColourWheel() failed. Parsed iWidthAndHeightOfImage must be at least 1"});\par
00701         createBlank(iWidthAndHeightOfImage, iWidthAndHeightOfImage, 4);\par
00702 \par
00703         {\cf18 float} fBrightness = float(ucBrightness) / 255.0f;\par
00704         CVector2f vCentrePixelPosition;\par
00705         vCentrePixelPosition.x = float(iWidthAndHeightOfImage) * 0.5f;\par
00706         vCentrePixelPosition.y = vCentrePixelPosition.x;\par
00707 \par
00708         CVector2f vCurrentPixelPosition;\par
00709         CVector2f vCurrentPixelOffsetFromCentre;\par
00710         CColourf colour;\par
00711         {\cf18 float} fCircleRadius = float(iWidthAndHeightOfImage) * 0.5f;\par
00712         {\cf18 float} fDistanceFromCentre;\par
00713         {\cf18 float} fSaturation;  {\cf20 // 0.0f = white, 1.0f = full colour}\par
00714         {\cf18 float} fAngleDegrees;\par
00715         {\cf18 float} fOneOver360 = 1.0f / 360.0f;\par
00716         {\cf18 unsigned} {\cf18 int} iPixelIndex = 0;\par
00717         {\cf19 for} ({\cf18 unsigned} {\cf18 int} iPosX = 0; iPosX < ({\cf18 unsigned} int)_miWidth; iPosX++)\par
00718         \{\par
00719             vCurrentPixelPosition.x = (float)iPosX;\par
00720             {\cf19 for} ({\cf18 unsigned} {\cf18 int} iPosY = 0; iPosY < ({\cf18 unsigned} int)_miHeight; iPosY++)\par
00721             \{\par
00722                 vCurrentPixelPosition.y = (float)iPosY;\par
00723                 vCurrentPixelOffsetFromCentre = vCurrentPixelPosition - vCentrePixelPosition;\par
00724                 fDistanceFromCentre = vCurrentPixelOffsetFromCentre.getMagnitude();\par
00725                 fSaturation = fCircleRadius - fDistanceFromCentre;\par
00726                 fSaturation /= fCircleRadius;   {\cf20 // 0 at edge of circle, 1 at centre. Can be < 0 which is outside circle}\par
00727                 fAngleDegrees = vCurrentPixelOffsetFromCentre.getAngleDegrees360();\par
00728                 fAngleDegrees *= fOneOver360;   {\cf20 // 0 when pixel is north, 0.25 when east etc.}\par
00729                 {\cf19 if} (fSaturation < 0.0f)\par
00730                     colour.set(0.0f, 0.0f, 0.0f, 0.0f);\par
00731                 {\cf19 else}\par
00732                 \{\par
00733                     colour.setFromHSB(fAngleDegrees, fSaturation, fBrightness);\par
00734                     colour.alpha = 1.0f;\par
00735                 \}\par
00736                 _mpData[iPixelIndex] = {\cf18 unsigned} char(colour.red * 255);\par
00737                 _mpData[iPixelIndex + 1] = {\cf18 unsigned} char(colour.green * 255);\par
00738                 _mpData[iPixelIndex + 2] = {\cf18 unsigned} char(colour.blue * 255);\par
00739                 _mpData[iPixelIndex + 3] = {\cf18 unsigned} char(colour.alpha * 255);\par
00740                 iPixelIndex += 4;\par
00741             \}\par
00742         \}\par
00743     \}\par
00744 \par
00745     CColourf CImage::getColourWheelColour({\cf18 unsigned} {\cf18 int} iPositionX, {\cf18 unsigned} {\cf18 int} iPositionY, {\cf18 unsigned} {\cf18 int} iWidthAndHeightOfImage, {\cf18 unsigned} {\cf18 char} ucBrightness)\par
00746     \{\par
00747         ThrowIfTrue(iWidthAndHeightOfImage < 1, {\cf22 "CImage::getColourWheelColour() failed. Parsed iWidthAndHeightOfImage must be at least 1"});\par
00748 \par
00749         CColourf colour;\par
00750         CVector2f vCurrentPixelPosition(({\cf18 float})iPositionX, {\cf18 float}(iPositionY));\par
00751         CVector2f vCentrePixelPosition;\par
00752         vCentrePixelPosition.x = float(iWidthAndHeightOfImage) * 0.5f;\par
00753         vCentrePixelPosition.y = vCentrePixelPosition.x;\par
00754         CVector2f vCurrentPixelOffsetFromCentre = vCurrentPixelPosition - vCentrePixelPosition;\par
00755         {\cf18 float} fDistanceFromCentre = vCurrentPixelOffsetFromCentre.getMagnitude();\par
00756         {\cf18 float} fCircleRadius = float(iWidthAndHeightOfImage) * 0.5f;\par
00757         {\cf18 float} fSaturation = fCircleRadius - fDistanceFromCentre;\par
00758         fSaturation /= fCircleRadius;   {\cf20 // 0 at edge of circle, 1 at centre. Can be < 0 which is outside circle}\par
00759         {\cf18 float} fAngleDegrees = vCurrentPixelOffsetFromCentre.getAngleDegrees360();\par
00760         fAngleDegrees /= 360.0f;    {\cf20 // 0 when pixel is north, 0.25 when east etc.}\par
00761         {\cf19 if} (fSaturation < 0.0f)\par
00762             colour.set(0.0f, 0.0f, 0.0f, 0.0f);\par
00763         {\cf19 else}\par
00764         \{\par
00765             colour.setFromHSB(fAngleDegrees, fSaturation, {\cf18 float}(ucBrightness) / 255.0f);\par
00766             colour.alpha = 1.0f;\par
00767         \}\par
00768         {\cf19 return} colour;\par
00769     \}\par
00770 \par
00771     {\cf18 void} CImage::drawGradient({\cf18 unsigned} {\cf18 int} iWidth, {\cf18 unsigned} {\cf18 int} iHeight, {\cf18 unsigned} {\cf18 int} iNumChannels, {\cf17 const} CColourf& colour0, {\cf17 const} CColourf& colour1)\par
00772     \{\par
00773         ThrowIfTrue(iWidth < 1 || iHeight < 1, {\cf22 "CImage::drawGradient() failed. Invalid dimensions given."});\par
00774         ThrowIfTrue(iNumChannels < 3 || iNumChannels > 4, {\cf22 "CImage::drawGradient() failed. Number of channels must be either 3 or 4."});\par
00775         createBlank(iWidth, iHeight, iNumChannels);\par
00776         {\cf18 bool} bHorizontal = {\cf17 true};\par
00777         {\cf19 if} (iHeight > iWidth)\par
00778             bHorizontal = {\cf17 false};\par
00779 \par
00780         CColourf colour;\par
00781         {\cf18 unsigned} {\cf18 int} iPixelIndex = 0;\par
00782         {\cf19 if} (bHorizontal)\par
00783         \{\par
00784             {\cf19 for} ({\cf18 unsigned} {\cf18 int} iPosX = 0; iPosX < iWidth; iPosX++)\par
00785             \{\par
00786                 colour = colour0.interpolate(colour1, {\cf18 float}(iPosX) / {\cf18 float}(iWidth));\par
00787                 {\cf19 for} ({\cf18 unsigned} {\cf18 int} iPosY = 0; iPosY < iHeight; iPosY++)\par
00788                 \{\par
00789                     iPixelIndex = iPosX + (iPosY * _miWidth);\par
00790                     iPixelIndex *= iNumChannels;\par
00791                     _mpData[iPixelIndex] = {\cf18 unsigned} char(colour.red * 255);\par
00792                     _mpData[iPixelIndex + 1] = {\cf18 unsigned} char(colour.green * 255);\par
00793                     _mpData[iPixelIndex + 2] = {\cf18 unsigned} char(colour.blue * 255);\par
00794                     {\cf19 if} (iNumChannels == 4)\par
00795                         _mpData[iPixelIndex + 3] = {\cf18 unsigned} char(colour.alpha * 255);\par
00796                 \}\par
00797             \}\par
00798         \}\par
00799         {\cf19 else}\par
00800         \{\par
00801             {\cf19 for} ({\cf18 unsigned} {\cf18 int} iPosY = 0; iPosY < iHeight; iPosY++)\par
00802             \{\par
00803                 colour = colour0.interpolate(colour1, {\cf18 float}(iPosY) / {\cf18 float}(iHeight));\par
00804                 {\cf19 for} ({\cf18 unsigned} {\cf18 int} iPosX = 0; iPosX < iWidth; iPosX++)\par
00805                 \{\par
00806                     iPixelIndex = iPosX + (iPosY * _miWidth);\par
00807                     iPixelIndex *= iNumChannels;\par
00808                     _mpData[iPixelIndex] = {\cf18 unsigned} char(colour.red * 255);\par
00809                     _mpData[iPixelIndex + 1] = {\cf18 unsigned} char(colour.green * 255);\par
00810                     _mpData[iPixelIndex + 2] = {\cf18 unsigned} char(colour.blue * 255);\par
00811                     {\cf19 if} (iNumChannels == 4)\par
00812                         _mpData[iPixelIndex + 3] = {\cf18 unsigned} char(colour.alpha * 255);\par
00813                 \}\par
00814             \}\par
00815         \}\par
00816     \}\par
00817 \par
00818     {\cf18 void} CImage::drawCircle({\cf18 unsigned} {\cf18 int} iWidthAndHeightOfImage, {\cf17 const} CColourf& colourInner, {\cf17 const} CColourf& colourOuter)\par
00819     \{\par
00820         ThrowIfTrue(iWidthAndHeightOfImage < 1, {\cf22 "CImage::drawCircle() failed. Parsed iWidthAndHeightOfImage must be at least 1"});\par
00821         createBlank(iWidthAndHeightOfImage, iWidthAndHeightOfImage, 4);\par
00822 \par
00823         CVector2f vCentrePixelPosition;\par
00824         vCentrePixelPosition.x = float(iWidthAndHeightOfImage) * 0.5f;\par
00825         vCentrePixelPosition.y = vCentrePixelPosition.x;\par
00826 \par
00827         CVector2f vCurrentPixelPosition;\par
00828         CVector2f vCurrentPixelOffsetFromCentre;\par
00829         CColourf colour;\par
00830         {\cf18 float} fCircleRadius = float(iWidthAndHeightOfImage) * 0.5f;\par
00831         {\cf18 float} fDistanceFromCentre;\par
00832         {\cf18 float} fOneOver360 = 1.0f / 360.0f;\par
00833         {\cf18 unsigned} {\cf18 int} iPixelIndex = 0;\par
00834         {\cf19 for} ({\cf18 unsigned} {\cf18 int} iPosX = 0; iPosX < ({\cf18 unsigned} int)_miWidth; iPosX++)\par
00835         \{\par
00836             vCurrentPixelPosition.x = (float)iPosX;\par
00837             {\cf19 for} ({\cf18 unsigned} {\cf18 int} iPosY = 0; iPosY < ({\cf18 unsigned} int)_miHeight; iPosY++)\par
00838             \{\par
00839                 vCurrentPixelPosition.y = (float)iPosY;\par
00840                 vCurrentPixelOffsetFromCentre = vCurrentPixelPosition - vCentrePixelPosition;\par
00841                 fDistanceFromCentre = fCircleRadius - vCurrentPixelOffsetFromCentre.getMagnitude();\par
00842                 fDistanceFromCentre /= fCircleRadius;   {\cf20 // 0 at edge of circle, 1 at centre. Can be < 0 which is outside circle}\par
00843                 {\cf19 if} (fDistanceFromCentre < 0.0f)\par
00844                     colour.set(0.0f, 0.0f, 0.0f, 0.0f);\par
00845                 {\cf19 else}\par
00846                     colour = colourOuter.interpolate(colourInner, fDistanceFromCentre);\par
00847                 _mpData[iPixelIndex] = {\cf18 unsigned} char(colour.red * 255);\par
00848                 _mpData[iPixelIndex + 1] = {\cf18 unsigned} char(colour.green * 255);\par
00849                 _mpData[iPixelIndex + 2] = {\cf18 unsigned} char(colour.blue * 255);\par
00850                 _mpData[iPixelIndex + 3] = {\cf18 unsigned} char(colour.alpha * 255);\par
00851                 iPixelIndex += 4;\par
00852             \}\par
00853         \}\par
00854     \}\par
00855 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/Image.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/Image.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/Image.h}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2D Image loading/saving }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../Core/Colourf.h"}\par
{\f2 #include "../Math/Vector2f.h"}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CImage}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class for creating/loading/saving/modifying 2D images. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2D Image loading/saving \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2D image loading and saving. \par
}{
Definition in file {\b Image.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Image.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/Image.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/Image.h}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef DOXYGENDOCEXAMPLE_H}\par
00007 {\cf21 #define DOXYGENDOCEXAMPLE_H}\par
00008 \par
00009 {\cf21 #include "../Core/Colourf.h"}\par
00010 {\cf21 #include "../Math/Vector2f.h"}\par
00011 \par
00012 {\cf21 #include <string>}\par
00013 \par
00014 {\cf17 namespace }DCL\par
00015 \{\par
00029     {\cf17 class }CImage\par
00030     \{\par
00031     {\cf17 public}:\par
00033         CImage();\par
00034         ~CImage();\par
00035 \par
00037         CImage& operator=({\cf17 const} CImage& other);\par
00038 \par
00040         {\cf18 void} free({\cf18 void});\par
00041 \par
00061         {\cf18 void} createBlank({\cf18 unsigned} {\cf18 int} iWidth, {\cf18 unsigned} {\cf18 int} iHeight, {\cf18 unsigned} {\cf18 short} iNumChannels);\par
00062 \par
00073         {\cf18 bool} load({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipForOpenGL = {\cf17 false});\par
00074 \par
00083         {\cf20 // Returns true if the image data was loaded, else false.}\par
00084         {\cf18 bool} loadInfo({\cf17 const} std::string& strFilename, {\cf18 int}& iWidth, {\cf18 int}& iHeight, {\cf18 int}& iComponentCount);\par
00085 \par
00091         {\cf20 // Throws exception if image contains no data or saving fails.}\par
00092         {\cf18 void} saveAsBMP({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipOnSave = {\cf17 false}) {\cf17 const};\par
00093 \par
00100         {\cf20 // Throws exception if image contains no data or saving fails.}\par
00101         {\cf18 void} saveAsJPG({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipOnSave = {\cf17 false}, {\cf18 int} iQuality = 100) {\cf17 const};\par
00102 \par
00108         {\cf20 // Throws exception if image contains no data or saving fails.}\par
00109         {\cf18 void} saveAsPNG({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipOnSave = {\cf17 false}) {\cf17 const};\par
00110 \par
00116         {\cf20 // Throws exception if image contains no data or saving fails.}\par
00117         {\cf18 void} saveAsTGA({\cf17 const} std::string& strFilename, {\cf18 bool} bFlipOnSave = {\cf17 false}) {\cf17 const};\par
00118 \par
00128         {\cf18 void} fill({\cf18 unsigned} {\cf18 char} ucRed, {\cf18 unsigned} {\cf18 char} ucGreen, {\cf18 unsigned} {\cf18 char} ucBlue, {\cf18 unsigned} {\cf18 char} ucAlpha = 255);\par
00129 \par
00136         {\cf18 unsigned} {\cf18 char}* getData({\cf18 void}) {\cf17 const};\par
00137 \par
00141         {\cf18 unsigned} {\cf18 int} getDataSize({\cf18 void}) {\cf17 const};\par
00142 \par
00146         {\cf18 unsigned} {\cf18 int} getWidth({\cf18 void}) {\cf17 const};\par
00147 \par
00151         {\cf18 unsigned} {\cf18 int} getHeight({\cf18 void}) {\cf17 const};\par
00152 \par
00156         CVector2f getDimensions({\cf18 void}) {\cf17 const};\par
00157 \par
00161         {\cf18 unsigned} {\cf18 int} getNumChannels({\cf18 void}) {\cf17 const};\par
00162 \par
00168         {\cf18 bool} getDimsArePowerOfTwo({\cf18 void}) {\cf17 const};\par
00169 \par
00187         {\cf17 inline} {\cf18 void} setPixel({\cf18 int} iX, {\cf18 int} iY, {\cf18 unsigned} {\cf18 char} r, {\cf18 unsigned} {\cf18 char} g, {\cf18 unsigned} {\cf18 char} b, {\cf18 unsigned} {\cf18 char} a);\par
00188 \par
00206         {\cf17 inline} {\cf18 void} getPixel({\cf18 int} iX, {\cf18 int} iY, {\cf18 unsigned} {\cf18 char}& r, {\cf18 unsigned} {\cf18 char}& g, {\cf18 unsigned} {\cf18 char}& b, {\cf18 unsigned} {\cf18 char}& a) {\cf17 const};\par
00207 \par
00211         {\cf18 void} swapRedAndBlue({\cf18 void});\par
00212 \par
00216         {\cf18 void} flipVertically({\cf18 void});\par
00217 \par
00224         {\cf18 void} invert({\cf18 bool} bInvertColour = {\cf17 true}, {\cf18 bool} bInvertAlpha = {\cf17 false});\par
00225 \par
00230         {\cf18 void} greyscaleSimple({\cf18 void});\par
00231 \par
00241         {\cf18 void} greyscale({\cf18 float} fRedSensitivity = 0.299f, {\cf18 float} fGreenSensitivity = 0.587f, {\cf18 float} fBlueSensitivity = 0.144f);\par
00242 \par
00249         {\cf18 void} adjustBrightness({\cf18 int} iAmount);\par
00250 \par
00257         {\cf18 void} adjustContrast({\cf18 int} iAmount);\par
00258 \par
00266         {\cf18 void} copyTo(CImage& destImage) {\cf17 const};\par
00267 \par
00288         {\cf18 void} copyRectTo(CImage& destImage, {\cf18 int} iSrcPosX, {\cf18 int} iSrcPosY, {\cf18 int} iSrcWidth, {\cf18 int} iSrcHeight, {\cf18 int} iDestPosX, {\cf18 int} iDestPosY) {\cf17 const};\par
00289 \par
00298         {\cf18 void} copyToAddBorder(CImage& outputImage) {\cf17 const};\par
00299 \par
00303         {\cf18 void} rotateClockwise({\cf18 void});\par
00304 \par
00321         {\cf18 void} edgeDetect(CImage& outputImage, {\cf18 unsigned} {\cf18 char} r, {\cf18 unsigned} {\cf18 char} g, {\cf18 unsigned} {\cf18 char} b);\par
00322 \par
00326         {\cf18 void} removeAlphaChannel({\cf18 void});\par
00327 \par
00331         {\cf18 void} copyAlphaChannelToRGB({\cf18 void});\par
00332 \par
00342         {\cf18 void} normalmap(CImage& outputImage, {\cf18 float} fScale = 1.0f) {\cf17 const};\par
00343 \par
00348         {\cf18 void} drawColourWheel({\cf18 unsigned} {\cf18 int} iWidthAndHeightOfImage, {\cf18 unsigned} {\cf18 char} ucBrightness = 255);\par
00349 \par
00359         CColourf getColourWheelColour({\cf18 unsigned} {\cf18 int} iPositionX, {\cf18 unsigned} {\cf18 int} iPositionY, {\cf18 unsigned} {\cf18 int} iWidthAndHeightOfImage, {\cf18 unsigned} {\cf18 char} ucBrightness);\par
00360 \par
00368         {\cf18 void} drawGradient({\cf18 unsigned} {\cf18 int} iWidth, {\cf18 unsigned} {\cf18 int} iHeight, {\cf18 unsigned} {\cf18 int} iNumChannels, {\cf17 const} CColourf& colour0, {\cf17 const} CColourf& colour1);\par
00369 \par
00375         {\cf18 void} drawCircle({\cf18 unsigned} {\cf18 int} iWidthAndHeightOfImage, {\cf17 const} CColourf& colourInner, {\cf17 const} CColourf& colourOuter);\par
00376     {\cf17 private}:\par
00377         {\cf18 unsigned} {\cf18 char}* _mpData;\par
00378         {\cf18 unsigned} {\cf18 int} _muiDataSize;\par
00379         {\cf18 int} _miWidth;\par
00380         {\cf18 int} _miHeight;\par
00381         {\cf18 int} _miNumChannels;\par
00382 \par
00383         {\cf20 // Used by edgeDetect()}\par
00384         {\cf17 inline} {\cf18 bool} _isPixelEdge({\cf18 int} iPosX, {\cf18 int} iPosY, {\cf18 unsigned} {\cf18 char} r, {\cf18 unsigned} {\cf18 char} g, {\cf18 unsigned} {\cf18 char} b);\par
00385 \par
00386     \};\par
00387 \par
00388 \par
00389 \par
00392     {\cf20 // Definition}\par
00395 \par
00396 \par
00397     {\cf17 inline} {\cf18 void} CImage::setPixel({\cf18 int} iX, {\cf18 int} iY, {\cf18 unsigned} {\cf18 char} r, {\cf18 unsigned} {\cf18 char} g, {\cf18 unsigned} {\cf18 char} b, {\cf18 unsigned} {\cf18 char} a)\par
00398     \{\par
00399         {\cf19 if} (iX >= _miWidth)\par
00400             {\cf19 return};\par
00401         {\cf19 if} (iY >= _miHeight)\par
00402             {\cf19 return};\par
00403 \par
00404         {\cf18 unsigned} {\cf18 int} iIndex = iX + (iY * _miWidth);\par
00405         iIndex *= _miNumChannels;\par
00406         {\cf19 switch} (_miNumChannels)\par
00407         \{\par
00408         {\cf19 case} 1:\par
00409             _mpData[iIndex] = r;\par
00410             {\cf19 break};\par
00411         {\cf19 case} 3:\par
00412             _mpData[iIndex] = r;\par
00413             _mpData[iIndex + 1] = g;\par
00414             _mpData[iIndex + 2] = b;\par
00415             {\cf19 break};\par
00416         {\cf19 case} 4:\par
00417             _mpData[iIndex] = r;\par
00418             _mpData[iIndex + 1] = g;\par
00419             _mpData[iIndex + 2] = b;\par
00420             _mpData[iIndex + 3] = a;\par
00421             {\cf19 break};\par
00422         \}\par
00423     \}\par
00424 \par
00425     {\cf17 inline} {\cf18 void} CImage::getPixel({\cf18 int} iX, {\cf18 int} iY, {\cf18 unsigned} {\cf18 char}& r, {\cf18 unsigned} {\cf18 char}& g, {\cf18 unsigned} {\cf18 char}& b, {\cf18 unsigned} {\cf18 char}& a){\cf17  const}\par
00426 {\cf17     }\{\par
00427         {\cf19 if} (iX >= _miWidth)\par
00428             {\cf19 return};\par
00429         {\cf19 if} (iY >= _miHeight)\par
00430             {\cf19 return};\par
00431 \par
00432         {\cf18 unsigned} {\cf18 int} iIndex = iX + (iY * _miWidth);\par
00433         iIndex *= _miNumChannels;\par
00434         {\cf19 switch} (_miNumChannels)\par
00435         \{\par
00436         {\cf19 case} 1:\par
00437             r = _mpData[iIndex];\par
00438             {\cf19 break};\par
00439         {\cf19 case} 3:\par
00440             r = _mpData[iIndex];\par
00441             g = _mpData[iIndex + 1];\par
00442             b = _mpData[iIndex + 2];\par
00443             {\cf19 break};\par
00444         {\cf19 case} 4:\par
00445             r = _mpData[iIndex];\par
00446             g = _mpData[iIndex + 1];\par
00447             b = _mpData[iIndex + 2];\par
00448             a = _mpData[iIndex + 3];\par
00449             {\cf19 break};\par
00450         \}\par
00451     \}\par
00452 \par
00453     {\cf17 inline} {\cf18 bool} CImage::_isPixelEdge({\cf18 int} iPosX, {\cf18 int} iPosY, {\cf18 unsigned} {\cf18 char} r, {\cf18 unsigned} {\cf18 char} g, {\cf18 unsigned} {\cf18 char} b)\par
00454     \{\par
00455         {\cf20 // Don't check edge pixels of image}\par
00456         {\cf19 if} (iPosX == 0)\par
00457             {\cf19 return} {\cf17 false};\par
00458         {\cf19 if} (iPosY == 0)\par
00459             {\cf19 return} {\cf17 false};\par
00460         {\cf19 if} (iPosX >= {\cf18 int}(_miWidth) - 1)\par
00461             {\cf19 return} {\cf17 false};\par
00462         {\cf19 if} (iPosY >= {\cf18 int}(_miHeight) - 1)\par
00463             {\cf19 return} {\cf17 false};\par
00464 \par
00465         {\cf20 // Get center pixel colour values}\par
00466         {\cf18 unsigned} {\cf18 char} col[4];\par
00467         getPixel(iPosX, iPosY, col[0], col[1], col[2], col[3]);\par
00468 \par
00469         {\cf20 // If the center pixel's colour is same as mask, it's not an edge}\par
00470         {\cf19 if} (col[0] == r)\par
00471             {\cf19 if} (col[1] == g)\par
00472                 {\cf19 if} (col[2] == b)\par
00473                     {\cf19 return} {\cf17 false};\par
00474 \par
00475         {\cf20 // If we get here, the center pixel is not the same as the mask colour}\par
00476 \par
00477         {\cf20 // Get bordering pixels of center pixel}\par
00478         {\cf20 // If they are the same as the mask, then it's an edge}\par
00479 \par
00480         {\cf20 // Left}\par
00481         getPixel(iPosX - 1, iPosY, col[0], col[1], col[2], col[3]);\par
00482         {\cf19 if} (col[0] == r)\par
00483             {\cf19 if} (col[1] == g)\par
00484                 {\cf19 if} (col[2] == b)\par
00485                     {\cf19 return} {\cf17 true};\par
00486         {\cf20 // Right}\par
00487         getPixel(iPosX + 1, iPosY, col[0], col[1], col[2], col[3]);\par
00488         {\cf19 if} (col[0] == r)\par
00489             {\cf19 if} (col[1] == g)\par
00490                 {\cf19 if} (col[2] == b)\par
00491                     {\cf19 return} {\cf17 true};\par
00492 \par
00493         {\cf20 // Top}\par
00494         getPixel(iPosX, iPosY - 1, col[0], col[1], col[2], col[3]);\par
00495         {\cf19 if} (col[0] == r)\par
00496             {\cf19 if} (col[1] == g)\par
00497                 {\cf19 if} (col[2] == b)\par
00498                     {\cf19 return} {\cf17 true};\par
00499 \par
00500         {\cf20 // Bottom}\par
00501         getPixel(iPosX, iPosY + 1, col[0], col[1], col[2], col[3]);\par
00502         {\cf19 if} (col[0] == r)\par
00503             {\cf19 if} (col[1] == g)\par
00504                 {\cf19 if} (col[2] == b)\par
00505                     {\cf19 return} {\cf17 true};\par
00506 \par
00507         {\cf20 // Top left}\par
00508         getPixel(iPosX - 1, iPosY - 1, col[0], col[1], col[2], col[3]);\par
00509         {\cf19 if} (col[0] == r)\par
00510             {\cf19 if} (col[1] == g)\par
00511                 {\cf19 if} (col[2] == b)\par
00512                     {\cf19 return} {\cf17 true};\par
00513 \par
00514         {\cf20 // Top right}\par
00515         getPixel(iPosX + 1, iPosY - 1, col[0], col[1], col[2], col[3]);\par
00516         {\cf19 if} (col[0] == r)\par
00517             {\cf19 if} (col[1] == g)\par
00518                 {\cf19 if} (col[2] == b)\par
00519                     {\cf19 return} {\cf17 true};\par
00520 \par
00521         {\cf20 // Bottom left}\par
00522         getPixel(iPosX - 1, iPosY + 1, col[0], col[1], col[2], col[3]);\par
00523         {\cf19 if} (col[0] == r)\par
00524             {\cf19 if} (col[1] == g)\par
00525                 {\cf19 if} (col[2] == b)\par
00526                     {\cf19 return} {\cf17 true};\par
00527 \par
00528         {\cf20 // Bottom right}\par
00529         getPixel(iPosX + 1, iPosY + 1, col[0], col[1], col[2], col[3]);\par
00530         {\cf19 if} (col[0] == r)\par
00531             {\cf19 if} (col[1] == g)\par
00532                 {\cf19 if} (col[2] == b)\par
00533                     {\cf19 return} {\cf17 true};\par
00534 \par
00535         {\cf19 return} {\cf17 false};   {\cf20 // Shouldn't get here, keep compiler happy}\par
00536     \}\par
00537 \par
00538 \}   {\cf20 // namespace DCL}\par
00539 \par
00540 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ImageAtlas.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/ImageAtlas.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/ImageAtlas.cpp}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ImageAtlas.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 {\cf21 #include "../Core/StringUtils.h"}\par
00004 \par
00005 {\cf17 namespace }DCL\par
00006 \{\par
00007     {\cf18 void} CImageAtlasDetails::write(std::ofstream& file)\par
00008     \{\par
00009         ThrowIfFalse(file.is_open(), {\cf22 "CImageAtlasDetails::write() failed. The given ofstream is not open."});\par
00010 \par
00011         file.write(({\cf18 char}*)&sTexCoords.vBL, {\cf17 sizeof}(CVector2f));\par
00012         file.write(({\cf18 char}*)&sTexCoords.vBR, {\cf17 sizeof}(CVector2f));\par
00013         file.write(({\cf18 char}*)&sTexCoords.vTL, {\cf17 sizeof}(CVector2f));\par
00014         file.write(({\cf18 char}*)&sTexCoords.vTR, {\cf17 sizeof}(CVector2f));\par
00015         file.write(({\cf18 char}*)&vDims, {\cf17 sizeof}(CVector2f));\par
00016         StringUtils::stringWrite(strImageFilename, file);\par
00017         file.write(({\cf18 char}*)&uiAtlasImage, {\cf17 sizeof}({\cf18 unsigned} {\cf18 int}));\par
00018         file.write(({\cf18 char}*)&bRotated, {\cf17 sizeof}({\cf18 bool}));\par
00019 \par
00020         ThrowIfFalse(file.good(), {\cf22 "CImageAtlasDetails::write() failed. The ofstream is not good."});\par
00021     \}\par
00022 \par
00023     {\cf18 void} CImageAtlasDetails::read(std::ifstream& file)\par
00024     \{\par
00025         ThrowIfFalse(file.is_open(), {\cf22 "CImageAtlasDetails::read() failed. The given ifstream is not open."});\par
00026 \par
00027         file.read(({\cf18 char}*)&sTexCoords.vBL, {\cf17 sizeof}(CVector2f));\par
00028         file.read(({\cf18 char}*)&sTexCoords.vBR, {\cf17 sizeof}(CVector2f));\par
00029         file.read(({\cf18 char}*)&sTexCoords.vTL, {\cf17 sizeof}(CVector2f));\par
00030         file.read(({\cf18 char}*)&sTexCoords.vTR, {\cf17 sizeof}(CVector2f));\par
00031         file.read(({\cf18 char}*)&vDims, {\cf17 sizeof}(CVector2f));\par
00032         StringUtils::stringRead(strImageFilename, file);\par
00033         file.read(({\cf18 char}*)&uiAtlasImage, {\cf17 sizeof}({\cf18 unsigned} {\cf18 int}));\par
00034         file.read(({\cf18 char}*)&bRotated, {\cf17 sizeof}({\cf18 bool}));\par
00035 \par
00036         ThrowIfFalse(file.good(), {\cf22 "CImageAtlasDetails::read() failed. The ifstream is not good."});\par
00037     \}\par
00038 \par
00039     CImageAtlasPacker::CImageAtlasPacker()\par
00040     \{\par
00041     \}\par
00042 \par
00043     CImageAtlasPacker::~CImageAtlasPacker()\par
00044     \{\par
00045         reset();\par
00046     \}\par
00047 \par
00048     {\cf18 void} CImageAtlasPacker::createAtlasImages({\cf17 const} std::vector<std::string>& vstrImages, {\cf18 unsigned} {\cf18 int} uiMaxAtlasImageWidth, {\cf18 unsigned} {\cf18 int} uiMaxAtlasImageHeight, {\cf18 bool} bAllowRotationOfImages, {\cf18 unsigned} {\cf18 int} uiImageSpacing)\par
00049     \{\par
00050         ThrowIfTrue(0 == vstrImages.size(), {\cf22 "CImageAtlasPacker::createAtlasImages() failed. The passed vector<string> containing individual image filenames contains no data."});\par
00051         ThrowIfTrue(0 == uiMaxAtlasImageWidth || 0 == uiMaxAtlasImageHeight, {\cf22 "CImageAtlasPacker::createAtlasImages() failed. uiMaxAtlasImageWidth or uiMaxAtlasImageHeight was set to zero."});\par
00052 \par
00053         {\cf20 // Reset, freeing atlas images if they exist}\par
00054         reset();\par
00055 \par
00056         {\cf20 // Store each image filename and as we go, create and load each individual image into memory}\par
00057         std::vector<std::string> vStrImageFilenames;\par
00058         std::vector<CImage*> vImages;\par
00059         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vstrImages.size(); ui++)\par
00060         \{\par
00061             vStrImageFilenames.push_back(vstrImages[ui]);\par
00062 \par
00063             {\cf20 // Allocate memory for individual image}\par
00064             CImage* pNewImage = {\cf17 new} CImage;\par
00065             ThrowIfFalse(pNewImage, {\cf22 "CImageAtlasPacker::createAtlasImages() failed. Unable to allocate memory for individual image."});\par
00066             vImages.push_back(pNewImage);\par
00067 \par
00068             {\cf20 // Load each individual image}\par
00069             ThrowIfFalse(vImages[ui]->load(vStrImageFilenames[ui], {\cf17 false}), {\cf22 "CImageAtlasPacker::createAtlasImages() failed. Unable to load image from file: "} + vStrImageFilenames[ui] + {\cf22 "."});\par
00070 \par
00071             {\cf20 // We check to see if the loaded image's dimensions are not the same as the first one and throw an exception}\par
00072 {\cf20 //          bool bNotSameDims = vImages[ui]->getWidth() != vImages[0]->getWidth() || vImages[ui]->getHeight() != vImages[0]->getHeight();}\par
00073 {\cf20 //          if (bNotSameDims)}\par
00074 {\cf20 //          \{}\par
00075 {\cf20 //              std::string strTxt = "CImageAtlasPacker::createAtlasImages() failed. All images added to an atlas must have the same dimensions.";}\par
00076 {\cf20 //              strTxt += "The first image dims: " + std::to_string(vImages[0]->getWidth()) + "x" + std::to_string(vImages[0]->getHeight());}\par
00077 {\cf20 //              strTxt += " The current image dims: " + std::to_string(vImages[ui]->getWidth()) + "x" + std::to_string(vImages[ui]->getHeight());}\par
00078 {\cf20 //              strTxt += ".";}\par
00079 {\cf20 //              ThrowIfTrue(1, strTxt);}\par
00080 {\cf20 //          \}}\par
00081         \}\par
00082 \par
00083         {\cf20 // Determine maximum width/height of the individual images and make sure, including image spacing, they can all fit within the specified max atlas image width/height}\par
00084         {\cf18 unsigned} {\cf18 int} uiMaxImageWidth = 0;\par
00085         {\cf18 unsigned} {\cf18 int} uiMaxImageHeight = 0;\par
00086         {\cf18 unsigned} {\cf18 int} uiImageWidth;\par
00087         {\cf18 unsigned} {\cf18 int} uiImageHeight;\par
00088         {\cf18 unsigned} {\cf18 int} uiImageSpacingTimes2 = uiImageSpacing * 2;\par
00089         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vImages.size(); ui++)\par
00090         \{\par
00091             uiImageWidth = vImages[ui]->getWidth() + uiImageSpacingTimes2;\par
00092             uiImageHeight = vImages[ui]->getHeight() + uiImageSpacingTimes2;\par
00093             {\cf19 if} (uiMaxImageWidth < uiImageWidth)\par
00094                 uiMaxImageWidth = uiImageWidth;\par
00095             {\cf19 if} (uiMaxImageHeight < uiImageHeight)\par
00096                 uiMaxImageHeight = uiImageHeight;\par
00097         \}\par
00098         ThrowIfTrue(uiMaxImageWidth > uiMaxAtlasImageWidth, {\cf22 "CImageAtlasPacker::createAtlasImages() failed. An individual image's width("} + std::to_string(uiMaxImageWidth) + {\cf22 "), including spacing of "} + std::to_string(uiImageSpacing) + {\cf22 " is greater than the specified max atlas image's width("} + std::to_string(uiMaxAtlasImageWidth) + {\cf22 "."});\par
00099         ThrowIfTrue(uiMaxImageHeight > uiMaxAtlasImageHeight, {\cf22 "CImageAtlasPacker::createAtlasImages() failed. An individual image's height("} + std::to_string(uiMaxImageHeight) + {\cf22 "), including spacing of "} + std::to_string(uiImageSpacing) + {\cf22 " is greater than the specified max atlas image's height("} + std::to_string(uiMaxAtlasImageHeight) + {\cf22 "."});\par
00100 \par
00101         {\cf20 // Create each image detail for each individual image, determining whether we should rotate the image or not}\par
00102         {\cf20 // Also, rotate the images that should be}\par
00103         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vImages.size(); ui++)\par
00104         \{\par
00105             CImageAtlasDetails imageDetail;\par
00106             imageDetail.bRotated = {\cf17 false};\par
00107             imageDetail.strImageFilename = vStrImageFilenames[ui];\par
00108             imageDetail.uiAtlasImage = 0;\par
00109             imageDetail.vDims = vImages[ui]->getDimensions();\par
00110             {\cf19 if} (bAllowRotationOfImages)\par
00111             \{\par
00112                 {\cf20 // Rotate image so that it's height is greatest}\par
00113                 {\cf19 if} (imageDetail.vDims.x > imageDetail.vDims.y)\par
00114                 \{\par
00115                     imageDetail.bRotated = {\cf17 true};\par
00116                     vImages[ui]->rotateClockwise();\par
00117                     imageDetail.vDims = vImages[ui]->getDimensions();\par
00118                 \}\par
00119             \}\par
00120             _mvImageDetails.push_back(imageDetail);\par
00121         \}\par
00122 \par
00123         {\cf20 // Bubble sort temp vectors by their image's width}\par
00124         {\cf20 // vectors which we have to sort...}\par
00125         {\cf20 // std::vector<std::string> vStrImageFilenames;     // Holds each individual image's filename }\par
00126         {\cf20 // std::vector<CImage*> vImages;                    // Holds each individual image's image data}\par
00127         {\cf20 // std::vector<CImageAtlasDetails> _mvImageDetails; // Holds each individual image's details}\par
00128         std::string strFilenameTemp;\par
00129         CImage* pImageTemp;\par
00130         CImageAtlasDetails imageAtlasDetailsTemp;\par
00131         {\cf19 for} ({\cf18 int} i = 0; i < (int)vImages.size(); ++i)\par
00132         \{\par
00133             {\cf19 for} ({\cf18 int} j = 0; j < (int)vImages.size(); ++j)\par
00134             \{\par
00135                 {\cf20 // Swap by largest first}\par
00136                 {\cf19 if} (_mvImageDetails[j].vDims.x < _mvImageDetails[i].vDims.x)\par
00137                 \{\par
00138                     {\cf20 // Temporarily store image, filename and image details}\par
00139                     {\cf20 // Assign i to temp}\par
00140                     pImageTemp = vImages[i];\par
00141                     strFilenameTemp = vStrImageFilenames[i];\par
00142                     imageAtlasDetailsTemp = _mvImageDetails[i];\par
00143                     {\cf20 // Assign j to i}\par
00144                     vImages[i] = vImages[j];\par
00145                     vStrImageFilenames[i] = vStrImageFilenames[j];\par
00146                     _mvImageDetails[i] = _mvImageDetails[j];\par
00147                     {\cf20 // Assign temp to j}\par
00148                     vImages[j] = pImageTemp;\par
00149                     vStrImageFilenames[j] = strFilenameTemp;\par
00150                     _mvImageDetails[j] = imageAtlasDetailsTemp;\par
00151                 \}\par
00152             \}\par
00153         \}\par
00154 \par
00155         {\cf20 // Bubble sort temp vectors by their image's height}\par
00156         {\cf19 for} ({\cf18 int} i = 0; i < (int)vImages.size(); ++i)\par
00157         \{\par
00158             {\cf19 for} ({\cf18 int} j = 0; j < (int)vImages.size(); ++j)\par
00159             \{\par
00160                 {\cf20 // Swap by largest first}\par
00161                 {\cf19 if} (_mvImageDetails[j].vDims.y < _mvImageDetails[i].vDims.y)\par
00162                 \{\par
00163                     {\cf20 // Temporarily store image, filename and image details}\par
00164                     {\cf20 // Assign i to temp}\par
00165                     pImageTemp = vImages[i];\par
00166                     strFilenameTemp = vStrImageFilenames[i];\par
00167                     imageAtlasDetailsTemp = _mvImageDetails[i];\par
00168                     {\cf20 // Assign j to i}\par
00169                     vImages[i] = vImages[j];\par
00170                     vStrImageFilenames[i] = vStrImageFilenames[j];\par
00171                     _mvImageDetails[i] = _mvImageDetails[j];\par
00172                     {\cf20 // Assign temp to j}\par
00173                     vImages[j] = pImageTemp;\par
00174                     vStrImageFilenames[j] = strFilenameTemp;\par
00175                     _mvImageDetails[j] = imageAtlasDetailsTemp;\par
00176                 \}\par
00177             \}\par
00178         \}\par
00179         {\cf20 // Now, vStrImageFilenames, vImages and _mvImageDetails contain the filename and images sorted by greatest width, then height first}\par
00180 \par
00181         {\cf20 // Now we have to following arrays filled...}\par
00182         {\cf20 // std::vector<std::string> vStrImageFilenames;     // Holds each individual image's filename }\par
00183         {\cf20 // std::vector<CImage*> vImages;                    // Holds each individual image's image data}\par
00184         {\cf20 // std::vector<CImageAtlasDetails> _mvImageDetails; // Holds each individual image's details}\par
00185         {\cf20 // _mvImageDetails[X].sTexCoords is not computed yet, we'll temporarily use this to hold position of each individual image inside of texture atlas}\par
00186         {\cf20 // and then convert to actual texture coordinates later further below.}\par
00187 \par
00188         {\cf20 // We now need to compute each image's position within the large atlas image and once done, we'll have the dimensions of the atlas image/s and the number required.}\par
00189         std::vector<CVector2f> vv2fAtlasDims;   {\cf20 // Will hold computed dims of each atlas image}\par
00190         vv2fAtlasDims.push_back(CVector2f(0.0f, ({\cf18 float})vImages[0]->getHeight()));\par
00191         {\cf18 int} iCurAtlasImage = 0;\par
00192         CVector2f v2fCurrentPositionInAtlas(0.0f, 0.0f);\par
00193         {\cf18 float} fSpacing = (float)uiImageSpacing;\par
00194         {\cf18 float} fSpacingTimesTwo = fSpacing * 2.0f;\par
00195 \par
00196         {\cf20 // We go from left to right for each row, adding images one at a time, then when we can no longer add any more}\par
00197         {\cf20 // images along the X axis, we move down a row and add more images starting from the left again.}\par
00198         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vImages.size(); ui++)\par
00199         \{\par
00200             {\cf20 // Compute position of current image in atlas}\par
00201             CVector2f vImageDims = vImages[ui]->getDimensions();\par
00202             _mvImageDetails[ui].sTexCoords.vTL.x = fSpacing + v2fCurrentPositionInAtlas.x;\par
00203             _mvImageDetails[ui].sTexCoords.vTL.y = fSpacing + v2fCurrentPositionInAtlas.y;\par
00204             _mvImageDetails[ui].sTexCoords.vBR.x = fSpacingTimesTwo + v2fCurrentPositionInAtlas.x + vImageDims.x;\par
00205             _mvImageDetails[ui].sTexCoords.vBR.y = fSpacingTimesTwo + v2fCurrentPositionInAtlas.y + vImageDims.y;\par
00206 \par
00207             {\cf20 // If the image position fits in current atlas row}\par
00208             {\cf19 if} (_mvImageDetails[ui].sTexCoords.vBR.x <= ({\cf18 float})uiMaxAtlasImageWidth)\par
00209             \{\par
00210                 {\cf20 // Image fits, fill in the rest of it's information}\par
00211                 _mvImageDetails[ui].sTexCoords.vTR.x = _mvImageDetails[ui].sTexCoords.vBR.x;\par
00212                 _mvImageDetails[ui].sTexCoords.vTR.y = _mvImageDetails[ui].sTexCoords.vTL.y;\par
00213                 _mvImageDetails[ui].sTexCoords.vBL.x = _mvImageDetails[ui].sTexCoords.vTL.x;\par
00214                 _mvImageDetails[ui].sTexCoords.vBL.y = _mvImageDetails[ui].sTexCoords.vBR.y;\par
00215 \par
00216                 {\cf20 // Update maximum atlas size}\par
00217                 {\cf19 if} (vv2fAtlasDims[iCurAtlasImage].x < _mvImageDetails[ui].sTexCoords.vBR.x)\par
00218                     vv2fAtlasDims[iCurAtlasImage].x = _mvImageDetails[ui].sTexCoords.vBR.x;\par
00219                 {\cf19 if} (vv2fAtlasDims[iCurAtlasImage].y < _mvImageDetails[ui].sTexCoords.vBR.y)\par
00220                     vv2fAtlasDims[iCurAtlasImage].y = _mvImageDetails[ui].sTexCoords.vBR.y;\par
00221 \par
00222                 {\cf20 // Move position in atlas right}\par
00223                 v2fCurrentPositionInAtlas.x += fSpacingTimesTwo + vImageDims.x;\par
00224 \par
00225                 {\cf20 // Set atlas image index for current image}\par
00226                 _mvImageDetails[ui].uiAtlasImage = iCurAtlasImage;\par
00227             \}\par
00228             {\cf19 else} {\cf20 // This image doesn't fit along current row, so start a new one}\par
00229             \{\par
00230                 {\cf20 // Move position in atlas down by max image height in row}\par
00231                 v2fCurrentPositionInAtlas.x = 0.0f;\par
00232                 v2fCurrentPositionInAtlas.y = vv2fAtlasDims[iCurAtlasImage].y - fSpacing;\par
00233 \par
00234                 {\cf20 // Compute position of current image in atlas}\par
00235                 _mvImageDetails[ui].sTexCoords.vTL.x = fSpacing + v2fCurrentPositionInAtlas.x;\par
00236                 _mvImageDetails[ui].sTexCoords.vTL.y = fSpacing + v2fCurrentPositionInAtlas.y;\par
00237                 _mvImageDetails[ui].sTexCoords.vBR.x = fSpacingTimesTwo + v2fCurrentPositionInAtlas.x + vImageDims.x;\par
00238                 _mvImageDetails[ui].sTexCoords.vBR.y = fSpacingTimesTwo + v2fCurrentPositionInAtlas.y + vImageDims.y;\par
00239 \par
00240                 {\cf20 // If the image position fits in current atlas}\par
00241                 {\cf19 if} (_mvImageDetails[ui].sTexCoords.vBR.y <= ({\cf18 float})uiMaxAtlasImageHeight)\par
00242                 \{\par
00243                     {\cf20 // Image fits, fill in the rest of it's information}\par
00244                     _mvImageDetails[ui].sTexCoords.vTR.x = _mvImageDetails[ui].sTexCoords.vBR.x;\par
00245                     _mvImageDetails[ui].sTexCoords.vTR.y = _mvImageDetails[ui].sTexCoords.vTL.y;\par
00246                     _mvImageDetails[ui].sTexCoords.vBL.x = _mvImageDetails[ui].sTexCoords.vTL.x;\par
00247                     _mvImageDetails[ui].sTexCoords.vBL.y = _mvImageDetails[ui].sTexCoords.vBR.y;\par
00248 \par
00249                     {\cf20 // Update maximum atlas size}\par
00250                     {\cf19 if} (vv2fAtlasDims[iCurAtlasImage].x < _mvImageDetails[ui].sTexCoords.vBR.x)\par
00251                         vv2fAtlasDims[iCurAtlasImage].x = _mvImageDetails[ui].sTexCoords.vBR.x;\par
00252                     {\cf19 if} (vv2fAtlasDims[iCurAtlasImage].y < _mvImageDetails[ui].sTexCoords.vBR.y)\par
00253                         vv2fAtlasDims[iCurAtlasImage].y = _mvImageDetails[ui].sTexCoords.vBR.y;\par
00254 \par
00255                     {\cf20 // Move position in atlas right}\par
00256                     v2fCurrentPositionInAtlas.x += fSpacingTimesTwo + vImageDims.x;\par
00257 \par
00258                     {\cf20 // Set atlas image index for current image}\par
00259                     _mvImageDetails[ui].uiAtlasImage = iCurAtlasImage;\par
00260                 \}\par
00261                 {\cf19 else} {\cf20 // This image doesn't fit in this atlas and maximum dims of the atlas have been reached}\par
00262                 \{\par
00263                     iCurAtlasImage++;\par
00264                     vv2fAtlasDims.push_back(CVector2f(0.0f, ({\cf18 float})vImages[ui]->getHeight()));\par
00265                     v2fCurrentPositionInAtlas.setZero();\par
00266 \par
00267                     {\cf20 // Add image to new atlas image}\par
00268                     _mvImageDetails[ui].sTexCoords.vTL.x = fSpacing + v2fCurrentPositionInAtlas.x;\par
00269                     _mvImageDetails[ui].sTexCoords.vTL.y = fSpacing + v2fCurrentPositionInAtlas.y;\par
00270                     _mvImageDetails[ui].sTexCoords.vBR.x = fSpacingTimesTwo + v2fCurrentPositionInAtlas.x + vImageDims.x;\par
00271                     _mvImageDetails[ui].sTexCoords.vBR.y = fSpacingTimesTwo + v2fCurrentPositionInAtlas.y + vImageDims.y;\par
00272                     _mvImageDetails[ui].sTexCoords.vTR.x = _mvImageDetails[ui].sTexCoords.vBR.x;\par
00273                     _mvImageDetails[ui].sTexCoords.vTR.y = _mvImageDetails[ui].sTexCoords.vTL.y;\par
00274                     _mvImageDetails[ui].sTexCoords.vBL.x = _mvImageDetails[ui].sTexCoords.vTL.x;\par
00275                     _mvImageDetails[ui].sTexCoords.vBL.y = _mvImageDetails[ui].sTexCoords.vBR.y;\par
00276 \par
00277                     {\cf20 // Update maximum atlas size}\par
00278                     {\cf19 if} (vv2fAtlasDims[iCurAtlasImage].x < _mvImageDetails[ui].sTexCoords.vBR.x)\par
00279                         vv2fAtlasDims[iCurAtlasImage].x = _mvImageDetails[ui].sTexCoords.vBR.x;\par
00280                     {\cf19 if} (vv2fAtlasDims[iCurAtlasImage].y < _mvImageDetails[ui].sTexCoords.vBR.y)\par
00281                         vv2fAtlasDims[iCurAtlasImage].y = _mvImageDetails[ui].sTexCoords.vBR.y;\par
00282 \par
00283                     {\cf20 // Move position in atlas right}\par
00284                     v2fCurrentPositionInAtlas.x += fSpacingTimesTwo + vImageDims.x;\par
00285 \par
00286                     {\cf20 // Set atlas image index for current image}\par
00287                     _mvImageDetails[ui].uiAtlasImage = iCurAtlasImage;\par
00288                 \}\par
00289             \}\par
00290         \}\par
00291 \par
00292         {\cf20 // Now we get here...}\par
00293         {\cf20 // iCurAtlasImage holds number of atlas images needed}\par
00294         {\cf20 // vv2fAtlasDims[X] holds each atlas image's dimensions}\par
00295         {\cf20 // _mvImageDetails[X].sTexCoords holds position in atlas of each individual image}\par
00296 \par
00297         {\cf20 // Create each atlas image}\par
00298         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < ({\cf18 unsigned} int)iCurAtlasImage + 1; ui++)\par
00299         \{\par
00300             CImage* pNewImage = {\cf17 new} CImage;\par
00301             ThrowIfFalse(pNewImage, {\cf22 "CImageAtlasPacker::createAtlasImages() failed. Unable to allocate memory for atlas image."});\par
00302             pNewImage->createBlank(({\cf18 unsigned} {\cf18 int})vv2fAtlasDims[ui].x, ({\cf18 unsigned} {\cf18 int})vv2fAtlasDims[ui].y, 4);\par
00303             _mvAtlasImages.push_back(pNewImage);\par
00304         \}\par
00305 \par
00306         {\cf20 // Now copy each image into atlas image}\par
00307         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vImages.size(); ui++)\par
00308         \{\par
00309             vImages[ui]->copyRectTo(*_mvAtlasImages[_mvImageDetails[ui].uiAtlasImage],\par
00310                 0, 0,\par
00311                 ({\cf18 int})vImages[ui]->getWidth(),\par
00312                 ({\cf18 int})vImages[ui]->getHeight(),\par
00313                 ({\cf18 int})_mvImageDetails[ui].sTexCoords.vTL.x,\par
00314                 ({\cf18 int})_mvImageDetails[ui].sTexCoords.vTL.y);\par
00315 \par
00316             {\cf20 // Now compute texture coordinates}\par
00317             CVector2f vAtlasDims = _mvAtlasImages[_mvImageDetails[ui].uiAtlasImage]->getDimensions();\par
00318             {\cf20 // Prevent divide by zero}\par
00319             ThrowIfTrue(vAtlasDims.x < 1.0f, {\cf22 "CImageAtlasPacker::createAtlasImages() failed. Atlas width less than 1."});\par
00320             ThrowIfTrue(vAtlasDims.y < 1.0f, {\cf22 "CImageAtlasPacker::createAtlasImages() failed. Atlas height less than 1."});\par
00321             CVector2f vAtlasDimsRecip(1.0f / vAtlasDims.x, 1.0f / vAtlasDims.y);\par
00322 \par
00323             {\cf20 // Compute correct image positions, not including the spacing}\par
00324             {\cf20 // From above, top left position is correct for x and y.}\par
00325             {\cf20 // All others include spacing and need to be recalculated.}\par
00326             _mvImageDetails[ui].sTexCoords.vBR.x = _mvImageDetails[ui].sTexCoords.vTL.x + _mvImageDetails[ui].vDims.x;\par
00327             _mvImageDetails[ui].sTexCoords.vBR.y = _mvImageDetails[ui].sTexCoords.vTL.y + _mvImageDetails[ui].vDims.y;\par
00328             _mvImageDetails[ui].sTexCoords.vTR.x = _mvImageDetails[ui].sTexCoords.vTL.x + _mvImageDetails[ui].vDims.x;\par
00329             _mvImageDetails[ui].sTexCoords.vTR.y = _mvImageDetails[ui].sTexCoords.vTL.y;\par
00330             _mvImageDetails[ui].sTexCoords.vBL.x = _mvImageDetails[ui].sTexCoords.vTL.x;\par
00331             _mvImageDetails[ui].sTexCoords.vBL.y = _mvImageDetails[ui].sTexCoords.vTL.y + _mvImageDetails[ui].vDims.y;\par
00332 \par
00333             {\cf20 // Now all positions are correct}\par
00334 \par
00335             {\cf20 // Now convert from pixel position in image to 0.0f - 1.0f}\par
00336             _mvImageDetails[ui].sTexCoords.vBL.x *= vAtlasDimsRecip.x;\par
00337             _mvImageDetails[ui].sTexCoords.vBL.y *= vAtlasDimsRecip.y;\par
00338             _mvImageDetails[ui].sTexCoords.vBR.x *= vAtlasDimsRecip.x;\par
00339             _mvImageDetails[ui].sTexCoords.vBR.y *= vAtlasDimsRecip.y;\par
00340             _mvImageDetails[ui].sTexCoords.vTL.x *= vAtlasDimsRecip.x;\par
00341             _mvImageDetails[ui].sTexCoords.vTL.y *= vAtlasDimsRecip.y;\par
00342             _mvImageDetails[ui].sTexCoords.vTR.x *= vAtlasDimsRecip.x;\par
00343             _mvImageDetails[ui].sTexCoords.vTR.y *= vAtlasDimsRecip.y;\par
00344 \par
00345             {\cf20 // For nearest filtering this is all we have to do.}\par
00346             {\cf20 // However, with linear filtering, we need to offset the texture coordinates}\par
00347             {\cf20 // by half a texel so that everything looks great when using linear filtering.}\par
00348             _mvImageDetails[ui].sTexCoords.vBL.x += vAtlasDimsRecip.x;\par
00349             _mvImageDetails[ui].sTexCoords.vBL.y -= vAtlasDimsRecip.y;\par
00350             _mvImageDetails[ui].sTexCoords.vBR.x -= vAtlasDimsRecip.x;\par
00351             _mvImageDetails[ui].sTexCoords.vBR.y -= vAtlasDimsRecip.y;\par
00352             _mvImageDetails[ui].sTexCoords.vTL.x += vAtlasDimsRecip.x;\par
00353             _mvImageDetails[ui].sTexCoords.vTL.y += vAtlasDimsRecip.y;\par
00354             _mvImageDetails[ui].sTexCoords.vTR.x -= vAtlasDimsRecip.x;\par
00355             _mvImageDetails[ui].sTexCoords.vTR.y += vAtlasDimsRecip.y;\par
00356 \par
00357         \}\par
00358 \par
00359         {\cf20 // Now we're done, we setup the hashmap for fast lookup of image details by individual image names}\par
00360         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < _mvImageDetails.size(); ui++)\par
00361         \{\par
00362             _mmapImageDetails[_mvImageDetails[ui].strImageFilename] = _mvImageDetails[ui];\par
00363         \}\par
00364 \par
00365         {\cf20 // Free each individual loaded image}\par
00366         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vImages.size(); ui++)\par
00367         \{\par
00368             {\cf17 delete} vImages[ui];\par
00369         \}\par
00370         vImages.clear();\par
00371     \}\par
00372 \par
00373     {\cf18 unsigned} {\cf18 int} CImageAtlasPacker::getNumAtlases({\cf18 void}){\cf17  const}\par
00374 {\cf17     }\{\par
00375         {\cf19 return} ({\cf18 unsigned} {\cf18 int})_mvAtlasImages.size();\par
00376     \}\par
00377 \par
00378     CImage* CImageAtlasPacker::getAtlasImage({\cf18 unsigned} {\cf18 int} uiIndex){\cf17  const}\par
00379 {\cf17     }\{\par
00380         ThrowIfTrue(0 == _mvAtlasImages.size(), {\cf22 "CImageAtlasPacker::getAtlasImage("} + std::to_string(uiIndex) + {\cf22 ") failed. There are no atlas images."});\par
00381         ThrowIfTrue(uiIndex >= _mvAtlasImages.size(), {\cf22 "CImageAtlasPacker::getAtlasImage("} + std::to_string(uiIndex) + {\cf22 ") failed. Invalid atlas index given."});\par
00382         {\cf19 return} _mvAtlasImages[uiIndex];\par
00383     \}\par
00384 \par
00385     std::vector<CImageAtlasDetails> CImageAtlasPacker::getAllImageDetails({\cf18 void}){\cf17  const}\par
00386 {\cf17     }\{\par
00387         ThrowIfFalse(_mvImageDetails.size(), {\cf22 "CImageAtlasPacker::getAllImageDetails() failed. No image data currently exists."});\par
00388         {\cf19 return} _mvImageDetails;\par
00389     \}\par
00390 \par
00391     std::vector<CImageAtlasDetails>* CImageAtlasPacker::getAllImageDetailsPointer({\cf18 void})\par
00392     \{\par
00393         ThrowIfFalse(_mvImageDetails.size(), {\cf22 "CImageAtlasPacker::getAllImageDetailsPointer() failed. No image data currently exists."});\par
00394         {\cf19 return} &_mvImageDetails;\par
00395     \}\par
00396 \par
00397     {\cf18 unsigned} {\cf18 int} CImageAtlasPacker::getNumIndividualImages({\cf18 void}){\cf17  const}\par
00398 {\cf17     }\{\par
00399         {\cf19 return} {\cf18 unsigned} int(_mvImageDetails.size());\par
00400     \}\par
00401 \par
00402     CImageAtlasDetails CImageAtlasPacker::getImageDetails({\cf17 const} std::string& strImageName){\cf17  const}\par
00403 {\cf17     }\{\par
00404         std::map<std::string, CImageAtlasDetails>::iterator it = _mmapImageDetails.find(strImageName);\par
00405         ThrowIfTrue(it == _mmapImageDetails.end(), {\cf22 "CImageAtlasPacker::getImageDetails("} + strImageName + {\cf22 ") failed. Named image doesn't exist."});\par
00406         {\cf19 return} it->second;\par
00407     \}\par
00408 \par
00409     CImageAtlasDetails* CImageAtlasPacker::getImageDetailsPointer({\cf17 const} std::string& strImageName){\cf17  const}\par
00410 {\cf17     }\{\par
00411         std::map<std::string, CImageAtlasDetails>::iterator it = _mmapImageDetails.find(strImageName);\par
00412         ThrowIfTrue(it == _mmapImageDetails.end(), {\cf22 "CImageAtlasPacker::getImageDetailsPointer("} + strImageName + {\cf22 ") failed. Named image doesn't exist."});\par
00413         {\cf19 return} &it->second;\par
00414     \}\par
00415 \par
00416     {\cf18 void} CImageAtlasPacker::reset({\cf18 void})\par
00417     \{\par
00418         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < _mvAtlasImages.size(); ui++)\par
00419         \{\par
00420             {\cf17 delete} _mvAtlasImages[ui];\par
00421         \}\par
00422         _mvImageDetails.clear();\par
00423         _mmapImageDetails.clear();\par
00424     \}\par
00425 \par
00426     {\cf18 bool} CImageAtlasPacker::getImageExists({\cf17 const} std::string& strImageName){\cf17  const}\par
00427 {\cf17     }\{\par
00428         std::map<std::string, CImageAtlasDetails>::iterator it = _mmapImageDetails.find(strImageName);\par
00429         {\cf19 return} (it != _mmapImageDetails.end());\par
00430     \}\par
00431 \par
00432 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/ImageAtlas.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/ImageAtlas.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/ImageAtlas.h}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Packing of images into larger images. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Image.h"}\par
{\f2 #include <map>}\par
{\f2 #include <fstream>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CImageAtlasDetails}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds information about each packed image inside an atlas image. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DCL::CImageAtlasDetails::STexCoords}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds texture coordinates for each of the four corners of an image. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CImageAtlasPacker}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Image atlas class used to pack many smaller images into as few as possible larger atlas images. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Packing of images into larger images. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b ImageAtlas.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ImageAtlas.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/ImageAtlas.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Image/ImageAtlas.h}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef IMAGEATLAS_H}\par
00007 {\cf21 #define IMAGEATLAS_H}\par
00008 \par
00009 {\cf21 #include "Image.h"}\par
00010 {\cf21 #include <map>}\par
00011 {\cf21 #include <fstream>}\par
00012 {\cf21 #include <vector>}\par
00013 \par
00014 {\cf17 namespace }DCL\par
00015 \{\par
00017     {\cf17 class }CImageAtlasDetails\par
00018     \{\par
00019     {\cf17 public}:\par
00021         {\cf17 struct }STexCoords\par
00022         \{\par
00023             CVector2f vTL;  \par
00024             CVector2f vTR;  \par
00025             CVector2f vBL;  \par
00026             CVector2f vBR;  \par
00027         \};\par
00028         {\cf20 // Stuff read/written to file}\par
00029 \par
00030         STexCoords sTexCoords;  \par
00031 \par
00036         {\cf18 unsigned} {\cf18 int} uiAtlasImage;\par
00037 \par
00038         {\cf18 bool} bRotated;                  \par
00039         CVector2f vDims;                \par
00040         std::string strImageFilename;   \par
00041 \par
00047         {\cf18 void} write(std::ofstream& file);\par
00048 \par
00054         {\cf18 void} read(std::ifstream& file);\par
00055     \};\par
00056 \par
00058     {\cf17 class }CImageAtlasPacker\par
00059     \{\par
00060     {\cf17 public}:\par
00062         CImageAtlasPacker();\par
00063 \par
00065         ~CImageAtlasPacker();\par
00066 \par
00084         {\cf18 void} createAtlasImages(\par
00085             {\cf17 const} std::vector<std::string>& vstrImages, {\cf20 // A vector of strings holding each individual image's filename which to add to the atlas image/s}\par
00086             {\cf18 unsigned} {\cf18 int} uiMaxAtlasImageWidth,          {\cf20 // The maximum allowed width of the created atlas image/s}\par
00087             {\cf18 unsigned} {\cf18 int} uiMaxAtlasImageHeight,         {\cf20 // The maximum allowed height of the created atlas image/s}\par
00088             {\cf18 bool} bAllowRotationOfImages,                {\cf20 // Whether to allow rotation of individual images to obtain greater packing efficiency or not.}\par
00089             {\cf18 unsigned} {\cf18 int} uiImageSpacing = 1             {\cf20 // Amount of spacing between individual images.}\par
00090         );\par
00091 \par
00093         {\cf18 void} reset({\cf18 void});\par
00094 \par
00100         {\cf18 unsigned} {\cf18 int} getNumAtlases({\cf18 void}) {\cf17 const};\par
00101 \par
00109         CImage* getAtlasImage({\cf18 unsigned} {\cf18 int} uiIndex) {\cf17 const};\par
00110 \par
00117         std::vector<CImageAtlasDetails> getAllImageDetails({\cf18 void}) {\cf17 const};\par
00118 \par
00139         std::vector<CImageAtlasDetails>* getAllImageDetailsPointer({\cf18 void});\par
00140 \par
00146         {\cf18 unsigned} {\cf18 int} getNumIndividualImages({\cf18 void}) {\cf17 const};\par
00147 \par
00155         CImageAtlasDetails getImageDetails({\cf17 const} std::string& strImageName) {\cf17 const};\par
00156 \par
00164         CImageAtlasDetails* getImageDetailsPointer({\cf17 const} std::string& strImageName) {\cf17 const};\par
00165 \par
00170         {\cf18 bool} getImageExists({\cf17 const} std::string& strImageName) {\cf17 const};\par
00171     {\cf17 private}:\par
00172         std::vector<CImage*> _mvAtlasImages;                \par
00173         std::vector<CImageAtlasDetails> _mvImageDetails;    \par
00174 \par
00176         {\cf17 mutable} std::map<std::string, CImageAtlasDetails> _mmapImageDetails;\par
00177     \};\par
00178 \par
00179 \}   {\cf20 // namespace DCL}\par
00180 \par
00181 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AABB.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/AABB.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/AABB.cpp}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AABB.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005     CAABB::CAABB()\par
00006     \{\par
00007         _mvMin.set(-0.5f, -0.5f, -0.5f);\par
00008         _mvMax.set(0.5f, 0.5f, 0.5f);\par
00009     \}\par
00010 \par
00011     CAABB::CAABB({\cf17 const} CVector3f& vMin, {\cf17 const} CVector3f& vMax)\par
00012     \{\par
00013         _mvMin = vMin;\par
00014         _mvMax = vMax;\par
00015     \}\par
00016 \par
00017     {\cf18 void} CAABB::setMinMax({\cf17 const} CVector3f& vMin, {\cf17 const} CVector3f& vMax)\par
00018     \{\par
00019         _mvMin = vMin;\par
00020         _mvMax = vMax;\par
00021     \}\par
00022 \par
00023     {\cf18 void} CAABB::setPosDims({\cf17 const} CVector3f& vPosition, {\cf17 const} CVector3f& vDimensions)\par
00024     \{\par
00025         CVector3f vHalfDims = vDimensions * 0.5f;\par
00026         _mvMin = vPosition - vHalfDims;\par
00027         _mvMax = vPosition + vHalfDims;\par
00028     \}\par
00029 \par
00030     {\cf18 void} CAABB::setPosition({\cf17 const} CVector3f& vNewPosition)\par
00031     \{\par
00032         CVector3f vHalfDims = _mvMax - _mvMin;\par
00033         vHalfDims *= 0.5f;\par
00034 \par
00035         _mvMin = vNewPosition - vHalfDims;\par
00036         _mvMax = vNewPosition + vHalfDims;\par
00037     \}\par
00038 \par
00039     {\cf18 void} CAABB::setDimensions({\cf17 const} CVector3f& vNewDimensions)\par
00040     \{\par
00041         CVector3f vOldHalfDims = _mvMax - _mvMin;\par
00042         vOldHalfDims *= 0.5f;\par
00043         CVector3f vPos = _mvMin + vOldHalfDims;\par
00044 \par
00045         CVector3f vHalfDims = vNewDimensions * 0.5f;\par
00046         _mvMin = vPos - vHalfDims;\par
00047         _mvMax = vPos + vHalfDims;\par
00048     \}\par
00049 \par
00050     CVector3f CAABB::getDimensions({\cf18 void}){\cf17  const}\par
00051 {\cf17     }\{\par
00052         {\cf19 return} _mvMax - _mvMin;\par
00053     \}\par
00054 \par
00055     CVector3f CAABB::getHalfDimensions({\cf18 void}){\cf17  const}\par
00056 {\cf17     }\{\par
00057         CVector3f vHalfDims = _mvMax - _mvMin;\par
00058         vHalfDims *= 0.5f;\par
00059         {\cf19 return} vHalfDims;\par
00060     \}\par
00061 \par
00062     CVector3f CAABB::getPosition({\cf18 void}){\cf17  const}\par
00063 {\cf17     }\{\par
00064         CVector3f vHalfDims = _mvMax - _mvMin;\par
00065         vHalfDims *= 0.5f;\par
00066 \par
00067         CVector3f vPos = _mvMin + vHalfDims;\par
00068         {\cf19 return} vPos;\par
00069     \}\par
00070 \par
00071     {\cf18 bool} CAABB::getPointIsInside({\cf17 const} CVector3f& vPoint){\cf17  const}\par
00072 {\cf17     }\{\par
00073         {\cf19 if} (vPoint.x < _mvMin.x)\par
00074             {\cf19 return} {\cf17 false};\par
00075         {\cf19 if} (vPoint.x > _mvMax.x)\par
00076             {\cf19 return} {\cf17 false};\par
00077         {\cf19 if} (vPoint.y < _mvMin.y)\par
00078             {\cf19 return} {\cf17 false};\par
00079         {\cf19 if} (vPoint.y > _mvMax.y)\par
00080             {\cf19 return} {\cf17 false};\par
00081         {\cf19 if} (vPoint.z < _mvMin.z)\par
00082             {\cf19 return} {\cf17 false};\par
00083         {\cf19 if} (vPoint.z > _mvMax.z)\par
00084             {\cf19 return} {\cf17 false};\par
00085         {\cf19 return} {\cf17 true};\par
00086     \}\par
00087 \par
00088     {\cf18 bool} CAABB::getAABBintersects({\cf17 const} CAABB& aabb){\cf17  const}\par
00089 {\cf17     }\{\par
00090         {\cf19 if} (_mvMin.x > aabb._mvMax.x)   {\cf20 // This is to right of other}\par
00091             {\cf19 return} {\cf17 false};\par
00092         {\cf19 if} (_mvMin.y > aabb._mvMax.y)   {\cf20 // This is above other}\par
00093             {\cf19 return} {\cf17 false};\par
00094         {\cf19 if} (_mvMin.z > aabb._mvMax.z)   {\cf20 // This is behind other}\par
00095             {\cf19 return} {\cf17 false};\par
00096         {\cf19 if} (_mvMax.x < aabb._mvMin.x)   {\cf20 // This is to left of other}\par
00097             {\cf19 return} {\cf17 false};\par
00098         {\cf19 if} (_mvMax.y < aabb._mvMin.y)   {\cf20 // This is below other}\par
00099             {\cf19 return} {\cf17 false};\par
00100         {\cf19 if} (_mvMax.z < aabb._mvMin.z)   {\cf20 // This if infront of other}\par
00101             {\cf19 return} {\cf17 false};\par
00102         {\cf19 return} {\cf17 true};\par
00103     \}\par
00104 \par
00105     {\cf18 void} CAABB::resizeArea({\cf18 float} fMultiplier)\par
00106     \{\par
00107         {\cf20 // Get current dimensions of the AABB}\par
00108         CVector3f vCurrentDims = _mvMax - _mvMin;\par
00109 \par
00110         {\cf20 // Compute new dimensions}\par
00111         CVector3f vNewDims = vCurrentDims * fMultiplier;\par
00112 \par
00113         {\cf20 // Compute amount to offset _mvMin and _mvMax by}\par
00114         CVector3f vOffset = vNewDims * 0.25f;\par
00115 \par
00116         {\cf20 // Offset _mvMin and _mvMax}\par
00117         _mvMin -= vOffset;\par
00118         _mvMax += vOffset;\par
00119     \}\par
00120 \par
00121     CVector3f CAABB::getMin({\cf18 void}){\cf17  const}\par
00122 {\cf17     }\{\par
00123         {\cf19 return} _mvMin;\par
00124     \}\par
00125 \par
00126     CVector3f CAABB::getMax({\cf18 void}){\cf17  const}\par
00127 {\cf17     }\{\par
00128         {\cf19 return} _mvMax;\par
00129     \}\par
00130 \par
00131 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/AABB.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/AABB.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/AABB.h}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Axis Aligned Bounding Box. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Vector3f.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CAABB}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Axis Aligned Bounding Box. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Axis Aligned Bounding Box. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b AABB.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AABB.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/AABB.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/AABB.h}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef AABB_H}\par
00007 {\cf21 #define AABB_H}\par
00008 \par
00009 {\cf21 #include "Vector3f.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00017     {\cf17 class }CAABB\par
00018     \{\par
00019     {\cf17 public}:\par
00021         CAABB();\par
00022 \par
00027         CAABB({\cf17 const} CVector3f& vMin, {\cf17 const} CVector3f& vMax);\par
00028 \par
00033         {\cf18 void} setMinMax({\cf17 const} CVector3f& vMin, {\cf17 const} CVector3f& vMax);\par
00034 \par
00039         {\cf18 void} setPosDims({\cf17 const} CVector3f& vPosition, {\cf17 const} CVector3f& vDimensions);\par
00040 \par
00044         {\cf18 void} setPosition({\cf17 const} CVector3f& vNewPosition);\par
00045 \par
00049         {\cf18 void} setDimensions({\cf17 const} CVector3f& vNewDimensions);\par
00050 \par
00054         CVector3f getDimensions({\cf18 void}) {\cf17 const};\par
00055 \par
00059         CVector3f getHalfDimensions({\cf18 void}) {\cf17 const};\par
00060 \par
00064         CVector3f getPosition({\cf18 void}) {\cf17 const};\par
00065 \par
00070         {\cf18 bool} getPointIsInside({\cf17 const} CVector3f& vPoint) {\cf17 const};\par
00071 \par
00077         {\cf18 bool} getAABBintersects({\cf17 const} CAABB& aabb) {\cf17 const};\par
00078 \par
00087         {\cf18 void} resizeArea({\cf18 float} fMultiplier);\par
00088 \par
00092         CVector3f getMin({\cf18 void}) {\cf17 const};\par
00093 \par
00097         CVector3f getMax({\cf18 void}) {\cf17 const};\par
00098     {\cf17 private}:\par
00099         CVector3f _mvMin;   \par
00100         CVector3f _mvMax;   \par
00101     \};\par
00102 \par
00103 \par
00104 \}   {\cf20 // namespace DCL}\par
00105 \par
00106 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Frustum.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Frustum.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Frustum.cpp}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Frustum.h"}\par
00002 \par
00003 {\cf21 #include <cmath>}\par
00004 {\cf21 #include <math.h>}\par
00005 \par
00006 {\cf17 namespace }DCL\par
00007 \{\par
00008     CFrustum::CFrustum()\par
00009     \{\par
00010 \par
00011     \}\par
00012 \par
00013     {\cf18 void} CFrustum::computeFromViewProjection({\cf17 const} CMatrix& cameraViewMatrix, {\cf17 const} CMatrix& cameraProjectionMatrix)\par
00014     \{\par
00015         {\cf20 /* Taken from Bard}\par
00016 {\cf20         // Get the view and projection matrices.}\par
00017 {\cf20         glm::mat4 viewMatrix = glm::lookAt(eye, center, up);}\par
00018 {\cf20         glm::mat4 projectionMatrix = glm::perspective(fov, aspect, near, far);}\par
00019 {\cf20 }\par
00020 {\cf20         // Compute the frustum planes.}\par
00021 {\cf20         std::vector<glm::Plane> frustumPlanes;}\par
00022 {\cf20         frustumPlanes.push_back(glm::Plane(viewMatrix * projectionMatrix * glm::vec4(1, 0, 0, 0), -1));}\par
00023 {\cf20         frustumPlanes.push_back(glm::Plane(viewMatrix * projectionMatrix * glm::vec4(-1, 0, 0, 0), 1));}\par
00024 {\cf20         frustumPlanes.push_back(glm::Plane(viewMatrix * projectionMatrix * glm::vec4(0, 1, 0, 0), -1));}\par
00025 {\cf20         frustumPlanes.push_back(glm::Plane(viewMatrix * projectionMatrix * glm::vec4(0, -1, 0, 0), 1));}\par
00026 {\cf20         frustumPlanes.push_back(glm::Plane(viewMatrix * projectionMatrix * glm::vec4(0, 0, 1, 0), -1));}\par
00027 {\cf20         frustumPlanes.push_back(glm::Plane(viewMatrix * projectionMatrix * glm::vec4(0, 0, -1, 0), 1));}\par
00028 {\cf20 }\par
00029 {\cf20         // Normalize the frustum planes.}\par
00030 {\cf20         for (int i = 0; i < 6; i++) \{}\par
00031 {\cf20           frustumPlanes[i].normalize();}\par
00032 {\cf20         \}}\par
00033 {\cf20 */}\par
00034 \par
00035 {\cf20 // Combine the view and projection matrices}\par
00036 {\cf20 // Then create vectors with offsets for the six planes}\par
00037 {\cf20 // Then multiply them by the combined matrices}\par
00038 {\cf20 // and finally set the distance to origins accordingly}\par
00039         CMatrix matrixViewProj = cameraViewMatrix * cameraProjectionMatrix;\par
00040         CVector3f v;\par
00041         {\cf18 float} fMag;\par
00042 \par
00043         v.set(1.0f, 0.0f, 0.0f);\par
00044         v = matrixViewProj.multiply(v);\par
00045         fMag = v.getMagnitude();\par
00046         v.normalise();\par
00047         mPlaneRight.set(v, -fMag);\par
00048 \par
00049         v.set(-1.0f, 0.0f, 0.0f);\par
00050         v = matrixViewProj.multiply(v);\par
00051         fMag = v.getMagnitude();\par
00052         v.normalise();\par
00053         mPlaneLeft.set(v, fMag);\par
00054 \par
00055         v.set(0.0f, 1.0f, 0.0f);\par
00056         v = matrixViewProj.multiply(v);\par
00057         fMag = v.getMagnitude();\par
00058         v.normalise();\par
00059         mPlaneTop.set(v, -fMag);\par
00060 \par
00061         v.set(0.0f, -1.0f, 0.0f);\par
00062         v = matrixViewProj.multiply(v);\par
00063         fMag = v.getMagnitude();\par
00064         v.normalise();\par
00065         mPlaneBottom.set(v, fMag);\par
00066 \par
00067         v.set(0.0f, 0.0f, 1.0f);\par
00068         v = matrixViewProj.multiply(v);\par
00069         fMag = v.getMagnitude();\par
00070         v.normalise();\par
00071         mPlaneNear.set(v, -fMag);\par
00072 \par
00073         v.set(0.0f, 0.0f, -1.0f);\par
00074         v = matrixViewProj.multiply(v);\par
00075         fMag = v.getMagnitude();\par
00076         v.normalise();\par
00077         mPlaneFar.set(v, fMag);\par
00078     \}\par
00079 \par
00080     {\cf18 bool} CFrustum::isPointInside({\cf17 const} CVector3f& vPosition){\cf17  const}\par
00081 {\cf17     }\{\par
00082         {\cf20 /* Taken from Bard}\par
00083 {\cf20         bool isPointInsideFrustum(glm::vec3 point, std::vector<glm::Plane> frustumPlanes)}\par
00084 {\cf20         \{}\par
00085 {\cf20             for (int i = 0; i < 6; i++)}\par
00086 {\cf20             \{}\par
00087 {\cf20                 if (frustumPlanes[i].dot(point) < 0)}\par
00088 {\cf20                 \{}\par
00089 {\cf20                     return false;}\par
00090 {\cf20                 \}}\par
00091 {\cf20             \}}\par
00092 {\cf20             return true;}\par
00093 {\cf20         \}}\par
00094 {\cf20         This code takes a point and a vector of frustum planes as input.}\par
00095 {\cf20         It then iterates through the frustum planes and checks if the point is on the "wrong" side of any of the planes.}\par
00096 {\cf20         If the point is on the wrong side of any of the planes, then it is not inside the frustum. Otherwise, the point is inside the frustum.}\par
00097 {\cf20 }\par
00098 {\cf20         The dot() function is used to calculate the dot product of the point and the plane normal.}\par
00099 {\cf20         The dot product is a measure of the angle between two vectors.}\par
00100 {\cf20         If the dot product is negative, then the point is on the "wrong" side of the plane.}\par
00101 {\cf20         */}\par
00102 \par
00103         {\cf20 // Compute dot product between position and each plane's normal...}\par
00104         {\cf20 // If returned dot product is...}\par
00105         {\cf20 // > 0      vectors are pointing roughly in same direction (upto 90 degrees apart)}\par
00106         {\cf20 // = 0      vectors are perpendicular to one another (90 degrees)}\par
00107         {\cf20 // < 0      vectors are pointing in opposite directions (+90 degrees to 180 degrees)}\par
00108 \par
00109         CVector3f v;\par
00110         v = mPlaneNear.getNormal() * abs(mPlaneNear.getDistanceToOrigin());\par
00111         {\cf19 if} (v.getDot(vPosition) < 0)\par
00112             {\cf19 return} {\cf17 false};\par
00113         v = mPlaneFar.getNormal() * abs(mPlaneFar.getDistanceToOrigin());\par
00114         {\cf19 if} (v.getDot(vPosition) < 0)\par
00115             {\cf19 return} {\cf17 false};\par
00116         v = mPlaneLeft.getNormal() * abs(mPlaneLeft.getDistanceToOrigin());\par
00117         {\cf19 if} (v.getDot(vPosition) < 0)\par
00118             {\cf19 return} {\cf17 false};\par
00119         v = mPlaneRight.getNormal() * abs(mPlaneRight.getDistanceToOrigin());\par
00120         {\cf19 if} (v.getDot(vPosition) < 0)\par
00121             {\cf19 return} {\cf17 false};\par
00122         v = mPlaneTop.getNormal() * abs(mPlaneTop.getDistanceToOrigin());\par
00123         {\cf19 if} (v.getDot(vPosition) < 0)\par
00124             {\cf19 return} {\cf17 false};\par
00125         v = mPlaneBottom.getNormal() * abs(mPlaneBottom.getDistanceToOrigin());\par
00126         {\cf19 if} (v.getDot(vPosition) < 0)\par
00127             {\cf19 return} {\cf17 false};\par
00128         {\cf19 return} {\cf17 true};\par
00129     \}\par
00130 \par
00131     {\cf18 bool} CFrustum::isAABBIntersecting({\cf17 const} CAABB& aabb){\cf17  const}\par
00132 {\cf17     }\{\par
00133         {\cf20 /* Taken from Bard}\par
00134 {\cf20         bool isAABBIntersectingFrustum(glm::vec3 min, glm::vec3 max, std::vector<glm::Plane> frustumPlanes)}\par
00135 {\cf20         \{}\par
00136 {\cf20             for (int i = 0; i < 6; i++)}\par
00137 {\cf20             \{}\par
00138 {\cf20                 // Check if any of the AABB's vertices are on the wrong side of the plane.}\par
00139 {\cf20                 if (frustumPlanes[i].dot(min) < 0 || frustumPlanes[i].dot(max) > 0)}\par
00140 {\cf20                 \{}\par
00141 {\cf20                     return false;}\par
00142 {\cf20                 \}}\par
00143 {\cf20             \}}\par
00144 {\cf20             return true;}\par
00145 {\cf20         \}}\par
00146 {\cf20         This code takes an AABB and a vector of frustum planes as input.}\par
00147 {\cf20         It then iterates through the frustum planes and checks if any of the AABB's vertices are on the "wrong" side of any of the planes.}\par
00148 {\cf20         If any of the AABB's vertices are on the wrong side of any of the planes, then the AABB is not intersecting the frustum.}\par
00149 {\cf20         Otherwise, the AABB is intersecting the frustum.}\par
00150 {\cf20 }\par
00151 {\cf20         The dot() function is used to calculate the dot product of the AABB's vertices and the plane normals.}\par
00152 {\cf20         The dot product is a measure of the angle between two vectors. If the dot product is negative, then the vertex is on the "wrong" side of the plane.}\par
00153 {\cf20         */}\par
00154 \par
00155         CVector3f v;\par
00156         CVector3f vMin = aabb.getMin();\par
00157         CVector3f vMax = aabb.getMax();\par
00158 \par
00159         v = mPlaneNear.getNormal() * abs(mPlaneNear.getDistanceToOrigin());\par
00160         {\cf19 if} (v.getDot(vMin) < 0 || v.getDot(vMax) > 0)\par
00161             {\cf19 return} {\cf17 false};\par
00162         v = mPlaneFar.getNormal() * abs(mPlaneFar.getDistanceToOrigin());\par
00163         {\cf19 if} (v.getDot(vMin) < 0 || v.getDot(vMax) > 0)\par
00164             {\cf19 return} {\cf17 false};\par
00165         v = mPlaneLeft.getNormal() * abs(mPlaneLeft.getDistanceToOrigin());\par
00166         {\cf19 if} (v.getDot(vMin) < 0 || v.getDot(vMax) > 0)\par
00167             {\cf19 return} {\cf17 false};\par
00168         v = mPlaneRight.getNormal() * abs(mPlaneRight.getDistanceToOrigin());\par
00169         {\cf19 if} (v.getDot(vMin) < 0 || v.getDot(vMax) > 0)\par
00170             {\cf19 return} {\cf17 false};\par
00171         v = mPlaneTop.getNormal() * abs(mPlaneTop.getDistanceToOrigin());\par
00172         {\cf19 if} (v.getDot(vMin) < 0 || v.getDot(vMax) > 0)\par
00173             {\cf19 return} {\cf17 false};\par
00174         v = mPlaneBottom.getNormal() * abs(mPlaneBottom.getDistanceToOrigin());\par
00175         {\cf19 if} (v.getDot(vMin) < 0 || v.getDot(vMax) > 0)\par
00176             {\cf19 return} {\cf17 false};\par
00177         {\cf19 return} {\cf17 true};\par
00178     \}\par
00179 \par
00180 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Frustum.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Frustum.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Frustum.h}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frustum. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AABB.h"}\par
{\f2 #include "Matrix.h"}\par
{\f2 #include "Plane.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CFrustum}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A frustum which is defined by six planes. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frustum. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b Frustum.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Frustum.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Frustum.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Frustum.h}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef FRUSTUM_H}\par
00007 {\cf21 #define FRUSTUM_H}\par
00008 \par
00009 {\cf21 #include "AABB.h"}\par
00010 {\cf21 #include "Matrix.h"}\par
00011 {\cf21 #include "Plane.h"}\par
00012 \par
00013 {\cf17 namespace }DCL\par
00014 \{\par
00018     {\cf17 class }CFrustum\par
00019     \{\par
00020     {\cf17 public}:\par
00022         CFrustum();\par
00023 \par
00029         {\cf18 void} computeFromViewProjection({\cf17 const} CMatrix& cameraViewMatrix, {\cf17 const} CMatrix& cameraProjectionMatrix);\par
00030 \par
00036         {\cf18 bool} isPointInside({\cf17 const} CVector3f& vPosition) {\cf17 const};\par
00037 \par
00043         {\cf18 bool} isAABBIntersecting({\cf17 const} CAABB& aabb) {\cf17 const};\par
00044 \par
00045         CPlane mPlaneNear;      \par
00046         CPlane mPlaneFar;       \par
00047         CPlane mPlaneLeft;      \par
00048         CPlane mPlaneRight;     \par
00049         CPlane mPlaneTop;       \par
00050         CPlane mPlaneBottom;    \par
00051     \};\par
00052 \par
00053 \}   {\cf20 // namespace DCL}\par
00054 \par
00055 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Matrix.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Matrix.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Matrix.cpp}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Matrix.h"}\par
00002 \par
00003 {\cf21 #include "../Core/Exceptions.h"}\par
00004 {\cf21 #include "../Core/Utilities.h"}\par
00005 {\cf21 #include "Vector4f.h"}\par
00006 \par
00007 {\cf21 #include <memory>}\par
00008 \par
00009 {\cf17 namespace }DCL\par
00010 \{\par
00011 \par
00012     CMatrix::CMatrix()\par
00013     \{\par
00014         setIdentity();\par
00015     \}\par
00016 \par
00017     {\cf17 const} {\cf18 void} CMatrix::operator =({\cf17 const} CMatrix& matrix)\par
00018     \{\par
00019         memcpy(m, matrix.m, {\cf17 sizeof}({\cf18 float}[16]));\par
00020     \}\par
00021 \par
00022     {\cf17 const} CMatrix CMatrix::operator *({\cf17 const} CMatrix& n){\cf17  const}\par
00023 {\cf17     }\{\par
00024         CMatrix r;\par
00025         r.m[0] = m[0] * n.m[0] + m[4] * n.m[1] + m[8] * n.m[2] + m[12] * n.m[3];\par
00026         r.m[1] = m[1] * n.m[0] + m[5] * n.m[1] + m[9] * n.m[2] + m[13] * n.m[3];\par
00027         r.m[2] = m[2] * n.m[0] + m[6] * n.m[1] + m[10] * n.m[2] + m[14] * n.m[3];\par
00028         r.m[3] = m[3] * n.m[0] + m[7] * n.m[1] + m[11] * n.m[2] + m[15] * n.m[3];\par
00029 \par
00030         r.m[4] = m[0] * n.m[4] + m[4] * n.m[5] + m[8] * n.m[6] + m[12] * n.m[7];\par
00031         r.m[5] = m[1] * n.m[4] + m[5] * n.m[5] + m[9] * n.m[6] + m[13] * n.m[7];\par
00032         r.m[6] = m[2] * n.m[4] + m[6] * n.m[5] + m[10] * n.m[6] + m[14] * n.m[7];\par
00033         r.m[7] = m[3] * n.m[4] + m[7] * n.m[5] + m[11] * n.m[6] + m[15] * n.m[7];\par
00034 \par
00035         r.m[8] = m[0] * n.m[8] + m[4] * n.m[9] + m[8] * n.m[10] + m[12] * n.m[11];\par
00036         r.m[9] = m[1] * n.m[8] + m[5] * n.m[9] + m[9] * n.m[10] + m[13] * n.m[11];\par
00037         r.m[10] = m[2] * n.m[8] + m[6] * n.m[9] + m[10] * n.m[10] + m[14] * n.m[11];\par
00038         r.m[11] = m[3] * n.m[8] + m[7] * n.m[9] + m[11] * n.m[10] + m[15] * n.m[11];\par
00039 \par
00040         r.m[12] = m[0] * n.m[12] + m[4] * n.m[13] + m[8] * n.m[14] + m[12] * n.m[15];\par
00041         r.m[13] = m[1] * n.m[12] + m[5] * n.m[13] + m[9] * n.m[14] + m[13] * n.m[15];\par
00042         r.m[14] = m[2] * n.m[12] + m[6] * n.m[13] + m[10] * n.m[14] + m[14] * n.m[15];\par
00043         r.m[15] = m[3] * n.m[12] + m[7] * n.m[13] + m[11] * n.m[14] + m[15] * n.m[15];\par
00044         {\cf19 return} r;\par
00045     \}\par
00046 \par
00047     {\cf17 const} {\cf18 void} CMatrix::operator *= ({\cf17 const} CMatrix& n)\par
00048     \{\par
00049         *{\cf17 this} = *{\cf17 this} * n;\par
00050     \}\par
00051 \par
00052     {\cf18 bool} CMatrix::operator==({\cf17 const} CMatrix& n){\cf17  const}\par
00053 {\cf17     }\{\par
00054         {\cf19 return}  (m[0] == n.m[0]) && (m[1] == n.m[1]) && (m[2] == n.m[2]) && (m[3] == n.m[3]) &&\par
00055             (m[4] == n.m[4]) && (m[5] == n.m[5]) && (m[6] == n.m[6]) && (m[7] == n.m[7]) &&\par
00056             (m[8] == n.m[8]) && (m[9] == n.m[9]) && (m[10] == n.m[10]) && (m[11] == n.m[11]) &&\par
00057             (m[12] == n.m[12]) && (m[13] == n.m[13]) && (m[14] == n.m[14]) && (m[15] == n.m[15]);\par
00058     \}\par
00059 \par
00060     {\cf18 bool} CMatrix::operator!=({\cf17 const} CMatrix& n){\cf17  const}\par
00061 {\cf17     }\{\par
00062         {\cf19 return}  (m[0] != n.m[0]) || (m[1] != n.m[1]) || (m[2] != n.m[2]) || (m[3] != n.m[3]) ||\par
00063             (m[4] != n.m[4]) || (m[5] != n.m[5]) || (m[6] != n.m[6]) || (m[7] != n.m[7]) ||\par
00064             (m[8] != n.m[8]) || (m[9] != n.m[9]) || (m[10] != n.m[10]) || (m[11] != n.m[11]) ||\par
00065             (m[12] != n.m[12]) || (m[13] != n.m[13]) || (m[14] != n.m[14]) || (m[15] != n.m[15]);\par
00066     \}\par
00067 \par
00068     {\cf18 void} CMatrix::setIdentity({\cf18 void})\par
00069     \{\par
00070         m[0] = m[5] = m[10] = m[15] = 1.0f;\par
00071         m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0.0f;\par
00072     \}\par
00073 \par
00074     {\cf18 void} CMatrix::setZero({\cf18 void})\par
00075     \{\par
00076         m[0] = m[1] = m[2] = m[3] = m[4] = m[5] = m[6] = m[7] = m[8] = m[9] = m[10] = m[11] = m[12] = m[13] = m[14] = m[15] = 0.0f;\par
00077     \}\par
00078 \par
00079     {\cf18 void} CMatrix::set({\cf17 const} {\cf18 float} src[16])\par
00080     \{\par
00081         m[0] = src[0];  m[1] = src[1];  m[2] = src[2];  m[3] = src[3];\par
00082         m[4] = src[4];  m[5] = src[5];  m[6] = src[6];  m[7] = src[7];\par
00083         m[8] = src[8];  m[9] = src[9];  m[10] = src[10]; m[11] = src[11];\par
00084         m[12] = src[12]; m[13] = src[13]; m[14] = src[14]; m[15] = src[15];\par
00085     \}\par
00086 \par
00087     {\cf18 void} CMatrix::set({\cf17 const} CMatrix& src)\par
00088     \{\par
00089         m[0] = src.m[0];    m[1] = src.m[1];    m[2] = src.m[2];    m[3] = src.m[3];\par
00090         m[4] = src.m[4];    m[5] = src.m[5];    m[6] = src.m[6];    m[7] = src.m[7];\par
00091         m[8] = src.m[8];    m[9] = src.m[9];    m[10] = src.m[10];  m[11] = src.m[11];\par
00092         m[12] = src.m[12];  m[13] = src.m[13];  m[14] = src.m[14];  m[15] = src.m[15];\par
00093     \}\par
00094 \par
00095     {\cf20 /*}\par
00096 {\cf20     void CMatrix::set(const glm::mat4& matrix)}\par
00097 {\cf20     \{}\par
00098 {\cf20         m[0] = matrix[0][0];}\par
00099 {\cf20         m[1] = matrix[0][1];}\par
00100 {\cf20         m[2] = matrix[0][2];}\par
00101 {\cf20         m[3] = matrix[0][3];}\par
00102 {\cf20         m[4] = matrix[1][0];}\par
00103 {\cf20         m[5] = matrix[1][1];}\par
00104 {\cf20         m[6] = matrix[1][2];}\par
00105 {\cf20         m[7] = matrix[1][3];}\par
00106 {\cf20         m[8] = matrix[2][0];}\par
00107 {\cf20         m[9] = matrix[2][1];}\par
00108 {\cf20         m[10] = matrix[2][2];}\par
00109 {\cf20         m[11] = matrix[2][3];}\par
00110 {\cf20         m[12] = matrix[3][0];}\par
00111 {\cf20         m[13] = matrix[3][1];}\par
00112 {\cf20         m[14] = matrix[3][2];}\par
00113 {\cf20         m[15] = matrix[3][3];}\par
00114 {\cf20     \}}\par
00115 {\cf20     */}\par
00116 \par
00117     CMatrix CMatrix::get({\cf18 void}){\cf17  const}\par
00118 {\cf17     }\{\par
00119         CMatrix mt;\par
00120         mt.m[0] = m[0];     mt.m[1] = m[1];     mt.m[2] = m[2];     mt.m[3] = m[3];\par
00121         mt.m[4] = m[4];     mt.m[5] = m[5];     mt.m[6] = m[6];     mt.m[7] = m[7];\par
00122         mt.m[8] = m[8];     mt.m[9] = m[9];     mt.m[10] = m[10];   mt.m[11] = m[11];\par
00123         mt.m[12] = m[12];   mt.m[13] = m[13];   mt.m[14] = m[14];   mt.m[15] = m[15];\par
00124         {\cf19 return} mt;\par
00125     \}\par
00126 \par
00127     {\cf20 /*}\par
00128 {\cf20     glm::mat4 CMatrix::getGLM(void) const}\par
00129 {\cf20     \{}\par
00130 {\cf20         glm::mat4 glm;}\par
00131 {\cf20         glm[0][0] = m[0];}\par
00132 {\cf20         glm[0][1] = m[1];}\par
00133 {\cf20         glm[0][2] = m[2];}\par
00134 {\cf20         glm[0][3] = m[3];}\par
00135 {\cf20         glm[1][0] = m[4];}\par
00136 {\cf20         glm[1][1] = m[5];}\par
00137 {\cf20         glm[1][2] = m[6];}\par
00138 {\cf20         glm[1][3] = m[7];}\par
00139 {\cf20         glm[2][0] = m[8];}\par
00140 {\cf20         glm[2][1] = m[9];}\par
00141 {\cf20         glm[2][2] = m[10];}\par
00142 {\cf20         glm[2][3] = m[11];}\par
00143 {\cf20         glm[3][0] = m[12];}\par
00144 {\cf20         glm[3][1] = m[13];}\par
00145 {\cf20         glm[3][2] = m[14];}\par
00146 {\cf20         glm[3][3] = m[15];}\par
00147 {\cf20         return glm;}\par
00148 {\cf20     \}}\par
00149 {\cf20     */}\par
00150 \par
00151     {\cf18 void} CMatrix::setTranslation({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ)\par
00152     \{\par
00153         m[12] = fX;\par
00154         m[13] = fY;\par
00155         m[14] = fZ;\par
00156     \}\par
00157 \par
00158     {\cf18 void} CMatrix::setTranslation({\cf17 const} CVector3f& vVec)\par
00159     \{\par
00160         m[12] = vVec.x;\par
00161         m[13] = vVec.y;\par
00162         m[14] = vVec.z;\par
00163     \}\par
00164 \par
00165     {\cf18 void} CMatrix::setScale({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ)\par
00166     \{\par
00167         m[0] = fX;\par
00168         m[5] = fY;\par
00169         m[10] = fZ;\par
00170     \}\par
00171 \par
00172     {\cf18 void} CMatrix::setScale({\cf17 const} CVector3f& vVec)\par
00173     \{\par
00174         m[0] = vVec.x;\par
00175         m[5] = vVec.y;\par
00176         m[10] = vVec.z;\par
00177     \}\par
00178 \par
00179     {\cf18 void} CMatrix::setFromAxisAngleDegrees({\cf17 const} CVector3f& vAxis, {\cf18 float} fAngleDegrees)\par
00180     \{\par
00181         {\cf18 float} fAngleRadians = deg2rad(fAngleDegrees);\par
00182         {\cf18 float} fCos = cosf(fAngleRadians);\par
00183         {\cf18 float} fSin = sinf(fAngleRadians);\par
00184         {\cf18 float} fOMC = 1.0f - fCos;\par
00185 \par
00186         m[0] = fCos + (vAxis.x * vAxis.x) * fOMC;\par
00187         m[5] = fCos + (vAxis.y * vAxis.y) * fOMC;\par
00188         m[10] = fCos + (vAxis.z * vAxis.z) * fOMC;\par
00189         m[15] = 1.0f;\par
00190         m[4] = vAxis.x * vAxis.y * fOMC + vAxis.z * fSin;\par
00191         m[1] = vAxis.x * vAxis.y * fOMC - vAxis.z * fSin;\par
00192         m[8] = vAxis.x * vAxis.z * fOMC + vAxis.y * fSin;\par
00193         m[2] = vAxis.x * vAxis.z * fOMC - vAxis.y * fSin;\par
00194         m[9] = vAxis.y * vAxis.z * fOMC + vAxis.x * fSin;\par
00195         m[6] = vAxis.y * vAxis.z * fOMC - vAxis.x * fSin;\par
00196     \}\par
00197 \par
00198     {\cf18 void} CMatrix::setFromAxisAngleRadians({\cf17 const} CVector3f& vAxis, {\cf18 float} fAngleRadians)\par
00199     \{\par
00200         {\cf18 float} fCos = cosf(fAngleRadians);\par
00201         {\cf18 float} fSin = sinf(fAngleRadians);\par
00202         {\cf18 float} fOMC = 1.0f - fCos;\par
00203 \par
00204         m[0] = fCos + (vAxis.x * vAxis.x) * fOMC;\par
00205         m[5] = fCos + (vAxis.y * vAxis.y) * fOMC;\par
00206         m[10] = fCos + (vAxis.z * vAxis.z) * fOMC;\par
00207         m[15] = 1.0f;\par
00208         m[4] = vAxis.x * vAxis.y * fOMC + vAxis.z * fSin;\par
00209         m[1] = vAxis.x * vAxis.y * fOMC - vAxis.z * fSin;\par
00210         m[8] = vAxis.x * vAxis.z * fOMC + vAxis.y * fSin;\par
00211         m[2] = vAxis.x * vAxis.z * fOMC - vAxis.y * fSin;\par
00212         m[9] = vAxis.y * vAxis.z * fOMC + vAxis.x * fSin;\par
00213         m[6] = vAxis.y * vAxis.z * fOMC - vAxis.x * fSin;\par
00214     \}\par
00215 \par
00216     {\cf18 void} CMatrix::setFromQuaternion({\cf17 const} CQuaternion& q)\par
00217     \{\par
00218         m[0] = 1.0f - 2.0f * (q.q[1] * q.q[1] + q.q[2] * q.q[2]);\par
00219         m[1] = 2.0f * (q.q[0] * q.q[1] - q.q[2] * q.q[3]);\par
00220         m[2] = 2.0f * (q.q[0] * q.q[2] + q.q[1] * q.q[3]);\par
00221 \par
00222         m[4] = 2.0f * (q.q[0] * q.q[1] + q.q[2] * q.q[3]);\par
00223         m[5] = 1.0f - 2.0f * (q.q[0] * q.q[0] + q.q[2] * q.q[2]);\par
00224         m[6] = 2.0f * (q.q[1] * q.q[2] - q.q[0] * q.q[3]);\par
00225 \par
00226         m[8] = 2.0f * (q.q[0] * q.q[2] - q.q[1] * q.q[3]);\par
00227         m[9] = 2.0f * (q.q[1] * q.q[2] + q.q[0] * q.q[3]);\par
00228         m[10] = 1.0f - 2.0f * (q.q[0] * q.q[0] + q.q[1] * q.q[1]);\par
00229 \par
00230         m[15] = 1.0f;\par
00231     \}\par
00232 \par
00233     {\cf18 void} CMatrix::getRightVector(CVector3f& vVec){\cf17  const}\par
00234 {\cf17     }\{\par
00235         vVec.x = m[0];\par
00236         vVec.y = m[1];\par
00237         vVec.z = m[2];\par
00238     \}\par
00239 \par
00240     {\cf18 void} CMatrix::getUpVector(CVector3f& vVec){\cf17  const}\par
00241 {\cf17     }\{\par
00242         vVec.x = m[4];\par
00243         vVec.y = m[5];\par
00244         vVec.z = m[6];\par
00245     \}\par
00246 \par
00247     {\cf18 void} CMatrix::getForwardVector(CVector3f& vVec){\cf17  const}\par
00248 {\cf17     }\{\par
00249         vVec.x = m[8];\par
00250         vVec.y = m[9];\par
00251         vVec.z = m[10];\par
00252     \}\par
00253 \par
00254     CMatrix CMatrix::transpose({\cf18 void})\par
00255     \{\par
00256         CMatrix mt;\par
00257         mt.m[0] = m[0];     mt.m[1] = m[4];     mt.m[2] = m[8];     mt.m[3] = m[12];\par
00258         mt.m[4] = m[1];     mt.m[5] = m[5];     mt.m[6] = m[9];     mt.m[7] = m[13];\par
00259         mt.m[8] = m[2];     mt.m[9] = m[6];     mt.m[10] = m[10];   mt.m[11] = m[14];\par
00260         mt.m[12] = m[3];    mt.m[13] = m[7];    mt.m[14] = m[11];   mt.m[15] = m[15];\par
00261         {\cf19 return} mt;\par
00262     \}\par
00263 \par
00264     CMatrix CMatrix::multiply({\cf17 const} CMatrix& n)\par
00265     \{\par
00266         CMatrix r;\par
00267         r.m[0] = m[0] * n.m[0] + m[4] * n.m[1] + m[8] * n.m[2] + m[12] * n.m[3];\par
00268         r.m[1] = m[1] * n.m[0] + m[5] * n.m[1] + m[9] * n.m[2] + m[13] * n.m[3];\par
00269         r.m[2] = m[2] * n.m[0] + m[6] * n.m[1] + m[10] * n.m[2] + m[14] * n.m[3];\par
00270         r.m[3] = m[3] * n.m[0] + m[7] * n.m[1] + m[11] * n.m[2] + m[15] * n.m[3];\par
00271 \par
00272         r.m[4] = m[0] * n.m[4] + m[4] * n.m[5] + m[8] * n.m[6] + m[12] * n.m[7];\par
00273         r.m[5] = m[1] * n.m[4] + m[5] * n.m[5] + m[9] * n.m[6] + m[13] * n.m[7];\par
00274         r.m[6] = m[2] * n.m[4] + m[6] * n.m[5] + m[10] * n.m[6] + m[14] * n.m[7];\par
00275         r.m[7] = m[3] * n.m[4] + m[7] * n.m[5] + m[11] * n.m[6] + m[15] * n.m[7];\par
00276 \par
00277         r.m[8] = m[0] * n.m[8] + m[4] * n.m[9] + m[8] * n.m[10] + m[12] * n.m[11];\par
00278         r.m[9] = m[1] * n.m[8] + m[5] * n.m[9] + m[9] * n.m[10] + m[13] * n.m[11];\par
00279         r.m[10] = m[2] * n.m[8] + m[6] * n.m[9] + m[10] * n.m[10] + m[14] * n.m[11];\par
00280         r.m[11] = m[3] * n.m[8] + m[7] * n.m[9] + m[11] * n.m[10] + m[15] * n.m[11];\par
00281 \par
00282         r.m[12] = m[0] * n.m[12] + m[4] * n.m[13] + m[8] * n.m[14] + m[12] * n.m[15];\par
00283         r.m[13] = m[1] * n.m[12] + m[5] * n.m[13] + m[9] * n.m[14] + m[13] * n.m[15];\par
00284         r.m[14] = m[2] * n.m[12] + m[6] * n.m[13] + m[10] * n.m[14] + m[14] * n.m[15];\par
00285         r.m[15] = m[3] * n.m[12] + m[7] * n.m[13] + m[11] * n.m[14] + m[15] * n.m[15];\par
00286         {\cf19 return} r;\par
00287     \}\par
00288 \par
00289     CVector3f CMatrix::multiply({\cf17 const} CVector3f& v)\par
00290     \{\par
00291         CVector3f r;\par
00292         r.x = m[0] * v.x + m[4] * v.y + m[8] * v.z + m[12];\par
00293         r.y = m[1] * v.x + m[5] * v.y + m[9] * v.z + m[13];\par
00294         r.z = m[2] * v.x + m[6] * v.y + m[10] * v.z + m[14];\par
00295         {\cf19 return} r;\par
00296     \}\par
00297 \par
00298     CMatrix CMatrix::multiply({\cf17 const} {\cf18 float} fScalar)\par
00299     \{\par
00300         CMatrix r = *{\cf17 this};\par
00301         r.m[0] *= fScalar;  r.m[1] *= fScalar;  r.m[2] *= fScalar;  r.m[3] *= fScalar;\par
00302         r.m[4] *= fScalar;  r.m[5] *= fScalar;  r.m[6] *= fScalar;  r.m[7] *= fScalar;\par
00303         r.m[8] *= fScalar;  r.m[9] *= fScalar;  r.m[10] *= fScalar; r.m[11] *= fScalar;\par
00304         r.m[12] *= fScalar; r.m[13] *= fScalar; r.m[14] *= fScalar; r.m[15] *= fScalar;\par
00305         {\cf19 return} r;\par
00306     \}\par
00307 \par
00308     {\cf18 void} CMatrix::setProjectionPerspective(\par
00309         {\cf18 float} fWidth,\par
00310         {\cf18 float} fHeight,\par
00311         {\cf18 float} fFieldOfViewInDegrees,\par
00312         {\cf18 float} fNearClippingPlaneDistance,\par
00313         {\cf18 float} fFarClippingPlaneDistance,\par
00314         {\cf18 float} fAspectRatio)\par
00315     \{\par
00316         {\cf18 float} fFOVRadians = deg2rad(fFieldOfViewInDegrees);\par
00317         {\cf18 float} fTanHalfFOV = tan(fFOVRadians * 0.5f);\par
00318         {\cf18 float} fNearMinusFar = fNearClippingPlaneDistance - fFarClippingPlaneDistance;\par
00319         ThrowIfTrue(fNearMinusFar == 0.0f, {\cf22 "CMatrix::setProjectionPerspective() failed. Given near and far clipping plane distances invalid."});\par
00320 \par
00321         {\cf20 // Compute fAspectRatio if given a value <= 0.0f from the back buffer's framebuffer's resource dimensions}\par
00322         {\cf19 if} (fAspectRatio <= 0.0f)\par
00323         \{\par
00324             fAspectRatio = fWidth / fHeight;\par
00325         \}\par
00326 \par
00327         {\cf20 // First column}\par
00328         m[0] = 1.0f / (fAspectRatio * fTanHalfFOV);\par
00329         m[1] = 0.0f;\par
00330         m[2] = 0.0f;\par
00331         m[3] = 0.0f;\par
00332 \par
00333         {\cf20 // Second column}\par
00334         m[4] = 0.0f;\par
00335         m[5] = 1.0f / fTanHalfFOV;\par
00336         m[6] = 0.0f;\par
00337         m[7] = 0.0f;\par
00338 \par
00339         {\cf20 // Third column}\par
00340         m[8] = 0.0f;\par
00341         m[9] = 0.0f;\par
00342         m[10] = fFarClippingPlaneDistance / (fNearMinusFar);\par
00343         m[11] = -1.0f;\par
00344 \par
00345         {\cf20 // Fourth column}\par
00346         m[12] = 0.0f;\par
00347         m[13] = 0.0f;\par
00348         m[14] = -(fFarClippingPlaneDistance * fNearClippingPlaneDistance) / (fFarClippingPlaneDistance - fNearClippingPlaneDistance);\par
00349         m[15] = 1.0f;   {\cf20 // 0.0f?}\par
00350     \}\par
00351 \par
00352     {\cf18 void} CMatrix::setProjectionOrthographic(\par
00353         {\cf18 float} fWidth,\par
00354         {\cf18 float} fHeight,\par
00355         {\cf18 float} fLeft,\par
00356         {\cf18 float} fRight,\par
00357         {\cf18 float} fTop,\par
00358         {\cf18 float} fBottom,\par
00359         {\cf18 float} fNear,\par
00360         {\cf18 float} fFar)\par
00361     \{\par
00362         {\cf20 // Compute fRight and fBottom if given a value <= 0.0f}\par
00363         {\cf19 if} (fRight <= 0.0f || fBottom <= 0.0f)\par
00364         \{\par
00365             fRight = fWidth;\par
00366             fBottom = fHeight;\par
00367         \}\par
00368 \par
00369         {\cf20 // First column}\par
00370         m[0] = 2.0f / (fRight - fLeft);\par
00371         m[1] = 0.0f;\par
00372         m[2] = 0.0f;\par
00373         m[3] = 0.0f;\par
00374 \par
00375         {\cf20 // Second column}\par
00376         m[4] = 0.0f;\par
00377         m[5] = 2.0f / (fTop - fBottom);\par
00378         m[6] = 0.0f;\par
00379         m[7] = 0.0f;\par
00380 \par
00381         {\cf20 // Third column}\par
00382         m[8] = 0.0f;\par
00383         m[9] = 0.0f;\par
00384         m[10] = -1.0f / (fFar - fNear);\par
00385         m[11] = 0.0f;\par
00386 \par
00387         {\cf20 // Fourth column}\par
00388         m[12] = -(fRight + fLeft) / (fRight - fLeft);\par
00389         m[13] = -(fTop + fBottom) / (fTop - fBottom);\par
00390         m[14] = -fNear / (fFar - fNear);\par
00391         m[15] = 1.0f;\par
00392     \}\par
00393 \par
00394     {\cf18 void} CMatrix::setViewLookat({\cf17 const} CVector3f& vEyePos, {\cf17 const} CVector3f& vTarget, {\cf17 const} CVector3f& vUp)\par
00395     \{\par
00396         CVector3f vf = vTarget - vEyePos;       vf.normalise();\par
00397         CVector3f vs = vf.getCross(vUp);        vs.normalise();\par
00398         CVector3f vu = vs.getCross(vf);         vu.normalise(); {\cf20 // No need to normalise as other two vectors already are.}\par
00399 \par
00400         {\cf20 // First column}\par
00401         m[0] = vs.x;\par
00402         m[1] = vu.x;\par
00403         m[2] = -vf.x;\par
00404         m[3] = 0.0f;\par
00405 \par
00406         {\cf20 // Second column}\par
00407         m[4] = vs.y;\par
00408         m[5] = vu.y;\par
00409         m[6] = -vf.y;\par
00410         m[7] = 0.0f;\par
00411 \par
00412         {\cf20 // Third column}\par
00413         m[8] = vs.z;\par
00414         m[9] = vu.z;\par
00415         m[10] = -vf.z;\par
00416         m[11] = 0.0f;\par
00417 \par
00418         {\cf20 // Fourth column}\par
00419         m[12] = -vs.getDot(vEyePos);\par
00420         m[13] = -vu.getDot(vEyePos);\par
00421         m[14] = vf.getDot(vEyePos);\par
00422         m[15] = 1.0f;\par
00423     \}\par
00424 \par
00425     {\cf17 const} {\cf18 float}* CMatrix::getFloat({\cf18 void}){\cf17  const}\par
00426 {\cf17     }\{\par
00427         {\cf19 return} &m[0];\par
00428     \}\par
00429 \par
00430     CMatrix CMatrix::inverse({\cf18 void})\par
00431     \{\par
00432         {\cf18 float} coef00 = m[10] * m[15] - m[14] * m[11];\par
00433         {\cf18 float} coef02 = m[6] * m[15] - m[14] * m[7];\par
00434         {\cf18 float} coef03 = m[6] * m[11] - m[10] * m[7];\par
00435         {\cf18 float} coef04 = m[9] * m[15] - m[13] * m[11];\par
00436         {\cf18 float} coef06 = m[5] * m[15] - m[13] * m[7];\par
00437         {\cf18 float} coef07 = m[5] * m[11] - m[9] * m[7];\par
00438         {\cf18 float} coef08 = m[9] * m[14] - m[13] * m[10];\par
00439         {\cf18 float} coef10 = m[5] * m[14] - m[13] * m[6];\par
00440         {\cf18 float} coef11 = m[5] * m[10] - m[9] * m[6];\par
00441         {\cf18 float} coef12 = m[8] * m[15] - m[12] * m[11];\par
00442         {\cf18 float} coef14 = m[4] * m[15] - m[12] * m[7];\par
00443         {\cf18 float} coef15 = m[4] * m[11] - m[8] * m[7];\par
00444         {\cf18 float} coef16 = m[8] * m[14] - m[12] * m[10];\par
00445         {\cf18 float} coef18 = m[4] * m[14] - m[12] * m[6];\par
00446         {\cf18 float} coef19 = m[4] * m[10] - m[8] * m[6];\par
00447         {\cf18 float} coef20 = m[8] * m[13] - m[12] * m[9];\par
00448         {\cf18 float} coef22 = m[4] * m[13] - m[12] * m[5];\par
00449         {\cf18 float} coef23 = m[4] * m[9] - m[8] * m[5];\par
00450 \par
00451         CVector4f fac0(coef00, coef00, coef02, coef03);\par
00452         CVector4f fac1(coef04, coef04, coef06, coef07);\par
00453         CVector4f fac2(coef08, coef08, coef10, coef11);\par
00454         CVector4f fac3(coef12, coef12, coef14, coef15);\par
00455         CVector4f fac4(coef16, coef16, coef18, coef19);\par
00456         CVector4f fac5(coef20, coef20, coef22, coef23);\par
00457 \par
00458         CVector4f vec0(m[4], m[0], m[0], m[0]);\par
00459         CVector4f vec1(m[5], m[1], m[1], m[1]);\par
00460         CVector4f vec2(m[6], m[2], m[2], m[2]);\par
00461         CVector4f vec3(m[7], m[3], m[3], m[3]);\par
00462 \par
00463         CVector4f inv0 = vec1 * fac0 - vec2 * fac1 + vec3 * fac2;\par
00464         CVector4f inv1 = vec0 * fac0 - vec2 * fac3 + vec3 * fac4;\par
00465         CVector4f inv2 = vec0 * fac1 - vec1 * fac3 + vec3 * fac5;\par
00466         CVector4f inv3 = vec0 * fac2 - vec1 * fac4 + vec2 * fac5;\par
00467 \par
00468         CVector4f signA(+1, -1, +1, -1);\par
00469         CVector4f signB(-1, +1, -1, +1);\par
00470 \par
00471         CMatrix matinv;\par
00472         CVector4f vResult0 = inv0 * signA;\par
00473         CVector4f vResult1 = inv1 * signB;\par
00474         CVector4f vResult2 = inv2 * signA;\par
00475         CVector4f vResult3 = inv3 * signB;\par
00476         matinv.m[0] = vResult0.x;   matinv.m[1] = vResult0.y;   matinv.m[2] = vResult0.z;   matinv.m[3] = vResult0.w;\par
00477         matinv.m[4] = vResult1.x;   matinv.m[5] = vResult1.y;   matinv.m[6] = vResult1.z;   matinv.m[7] = vResult1.w;\par
00478         matinv.m[8] = vResult2.x;   matinv.m[9] = vResult2.y;   matinv.m[10] = vResult2.z;  matinv.m[11] = vResult2.w;\par
00479         matinv.m[12] = vResult3.x;  matinv.m[13] = vResult3.y;  matinv.m[14] = vResult3.z;  matinv.m[15] = vResult3.w;\par
00480 \par
00481         CVector4f row0(matinv.m[0], matinv.m[4], matinv.m[8], matinv.m[12]);\par
00482         CVector4f dot0 = row0 * m[0];\par
00483         {\cf18 float} fDot1 = (dot0.x + dot0.y) + (dot0.z + dot0.w);\par
00484         {\cf18 float} fOneOverDeterminant = 1.0f / fDot1;\par
00485         {\cf19 return} matinv.multiply(fOneOverDeterminant);\par
00486     \}\par
00487 \par
00488     CVector3f CMatrix::getTranslation({\cf18 void}){\cf17  const}\par
00489 {\cf17     }\{\par
00490         {\cf19 return} CVector3f(m[12], m[13], m[14]);\par
00491     \}\par
00492 \par
00493 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Matrix.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Matrix.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Matrix.h}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D Matrix class }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Quaternion.h"}\par
{\f2 #include "Vector3f.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CMatrix}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Matrix class. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D Matrix class \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b Matrix.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Matrix.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Matrix.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Matrix.h}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef MATRIX_H}\par
00007 {\cf21 #define MATRIX_H}\par
00008 \par
00009 {\cf21 #include "Quaternion.h"}\par
00010 {\cf21 #include "Vector3f.h"}\par
00011 \par
00012 {\cf17 namespace }DCL\par
00013 \{\par
00073     {\cf17 class }CMatrix\par
00074     \{\par
00075     {\cf17 public}:\par
00076         {\cf17 friend} {\cf17 class }CQuaternion;\par
00077 \par
00079         CMatrix();\par
00080 \par
00082         {\cf17 const} {\cf18 void} operator = ({\cf17 const} CMatrix& matrix);\par
00083 \par
00085         {\cf17 const} CMatrix operator * ({\cf17 const} CMatrix& matrix) {\cf17 const};\par
00086 \par
00088         {\cf17 const} {\cf18 void} operator *= ({\cf17 const} CMatrix& matrix);\par
00089 \par
00093         {\cf18 bool} operator==({\cf17 const} CMatrix& matrix) {\cf17 const};\par
00094 \par
00098         {\cf18 bool} operator!=({\cf17 const} CMatrix& matrix) {\cf17 const};\par
00099 \par
00101         {\cf18 void} setIdentity({\cf18 void});\par
00102 \par
00104         {\cf18 void} setZero({\cf18 void});\par
00105 \par
00109         {\cf18 void} set({\cf17 const} {\cf18 float} src[16]);\par
00110 \par
00114         {\cf18 void} set({\cf17 const} CMatrix& src);\par
00115 \par
00117 {\cf20 //      void set(const glm::mat4& matrix);}\par
00118 \par
00122         CMatrix get({\cf18 void}) {\cf17 const};\par
00123 \par
00125 {\cf20 //      glm::mat4 getGLM(void) const;}\par
00126 \par
00132         {\cf18 void} setTranslation({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ);\par
00133 \par
00137         {\cf18 void} setTranslation({\cf17 const} CVector3f& vTrans);\par
00138 \par
00144         {\cf18 void} setScale({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ);\par
00145 \par
00149         {\cf18 void} setScale({\cf17 const} CVector3f& vTrans);\par
00150 \par
00158         {\cf18 void} setFromAxisAngleDegrees({\cf17 const} CVector3f& vAxis, {\cf18 float} fAngleDegrees);\par
00159 \par
00167         {\cf18 void} setFromAxisAngleRadians({\cf17 const} CVector3f& vAxis, {\cf18 float} fAngleRadians);\par
00168 \par
00172         {\cf18 void} setFromQuaternion({\cf17 const} CQuaternion& quaternion);\par
00173 \par
00179         {\cf18 void} getRightVector(CVector3f& vVec) {\cf17 const};\par
00180 \par
00186         {\cf18 void} getUpVector(CVector3f& vVec) {\cf17 const};\par
00187 \par
00193         {\cf18 void} getForwardVector(CVector3f& vVec) {\cf17 const};\par
00194 \par
00204         CMatrix transpose({\cf18 void});\par
00205 \par
00211         CMatrix inverse({\cf18 void});\par
00212 \par
00217         CMatrix multiply({\cf17 const} CMatrix& matrix);\par
00218 \par
00223         CVector3f multiply({\cf17 const} CVector3f& vector);\par
00224 \par
00229         CMatrix multiply({\cf17 const} {\cf18 float} fScalar);\par
00230 \par
00241         {\cf18 void} setProjectionPerspective(\par
00242             {\cf18 float} fWidth = 320.0f,\par
00243             {\cf18 float} fHeight = 240.0f,\par
00244             {\cf18 float} fFieldOfViewInDegrees = 55.0f,\par
00245             {\cf18 float} fNearClippingPlaneDistance = 1.0f,\par
00246             {\cf18 float} fFarClippingPlaneDistance = 1000.0f,\par
00247             {\cf18 float} fAspectRatio = -1.0f);\par
00248 \par
00261         {\cf18 void} setProjectionOrthographic(\par
00262             {\cf18 float} fWidth = 320.0f,\par
00263             {\cf18 float} fHeight = 240.0f,\par
00264             {\cf18 float} fLeft = 0.0f,\par
00265             {\cf18 float} fRight = -1.0f,\par
00266             {\cf18 float} fTop = 0.0f,\par
00267             {\cf18 float} fBottom = -1.0f,\par
00268             {\cf18 float} fNear = -1.0f,\par
00269             {\cf18 float} fFar = 1.0f);\par
00270 \par
00278         {\cf18 void} setViewLookat({\cf17 const} CVector3f& vEyePos, {\cf17 const} CVector3f& vTarget, {\cf17 const} CVector3f& vUp = CVector3f(0.0f, 1.0f, 0.0f));\par
00279 \par
00283         {\cf17 const} {\cf18 float}* getFloat({\cf18 void}) {\cf17 const};\par
00284 \par
00288         CVector3f getTranslation({\cf18 void}) {\cf17 const};\par
00289     {\cf17 private}:\par
00290         {\cf18 float} m[16];    \par
00291     \};\par
00292 \par
00293 \}   {\cf20 // namespace DCL}\par
00294 \par
00295 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Plane.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Plane.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Plane.cpp}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Plane.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005     CPlane::CPlane()\par
00006     \{\par
00007         _mvNormal.set(0.0f, 1.0f, 0.0f);\par
00008         _mfDistanceToOrigin = 0.0f;\par
00009     \}\par
00010 \par
00011     CPlane::CPlane({\cf17 const} CVector3f& vNormal, {\cf18 float} fDistanceToOrigin)\par
00012     \{\par
00013         _mvNormal = vNormal;\par
00014         _mfDistanceToOrigin = fDistanceToOrigin;\par
00015     \}\par
00016 \par
00017     {\cf18 void} CPlane::set({\cf17 const} CVector3f& vNormal, {\cf18 float} fDistanceToOrigin)\par
00018     \{\par
00019         _mvNormal = vNormal;\par
00020         _mfDistanceToOrigin = fDistanceToOrigin;\par
00021     \}\par
00022 \par
00023     CVector3f CPlane::getNormal({\cf18 void}){\cf17  const}\par
00024 {\cf17     }\{\par
00025         {\cf19 return} _mvNormal;\par
00026     \}\par
00027 \par
00028     {\cf18 float} CPlane::getDistanceToOrigin({\cf18 void}){\cf17  const}\par
00029 {\cf17     }\{\par
00030         {\cf19 return} _mfDistanceToOrigin;\par
00031     \}\par
00032 \par
00033     {\cf18 float} CPlane::getDistanceFromPlane({\cf17 const} CVector3f& vPoint){\cf17  const}\par
00034 {\cf17     }\{\par
00035         {\cf20 // If returned dot product is...}\par
00036         {\cf20 // > 0      vectors are pointing roughly in same direction (upto 90 degrees apart)}\par
00037         {\cf20 // = 0      vectors are perpendicular to one another (90 degrees)}\par
00038         {\cf20 // < 0      vectors are pointing in opposite directions (+90 degrees to 180 degrees)}\par
00039         {\cf19 return} _mvNormal.getDot(vPoint) - _mfDistanceToOrigin;\par
00040     \}\par
00041 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Plane.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Plane.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Plane.h}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Plane. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Vector3f.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CPlane}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A representation of a plane in 3D space. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Plane. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b Plane.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Plane.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Plane.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Plane.h}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef PLANE_H}\par
00007 {\cf21 #define PLANE_H}\par
00008 \par
00009 {\cf21 #include "Vector3f.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00018     {\cf17 class }CPlane\par
00019     \{\par
00020     {\cf17 public}:\par
00022         CPlane();\par
00023 \par
00025         CPlane({\cf17 const} CVector3f& vNormal, {\cf18 float} fDistanceToOrigin);\par
00026 \par
00031         {\cf18 void} set({\cf17 const} CVector3f& vNormal, {\cf18 float} fDistanceToOrigin);\par
00032 \par
00036         CVector3f getNormal({\cf18 void}) {\cf17 const};\par
00037 \par
00041         {\cf18 float} getDistanceToOrigin({\cf18 void}) {\cf17 const};\par
00042 \par
00050         {\cf18 float} getDistanceFromPlane({\cf17 const} CVector3f& vPoint) {\cf17 const};\par
00051 \par
00052     {\cf17 private}:\par
00053         CVector3f _mvNormal;\par
00054         {\cf18 float} _mfDistanceToOrigin;\par
00055     \};\par
00056 \par
00057 \}   {\cf20 // namespace DCL}\par
00058 \par
00059 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Quaternion.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Quaternion.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Quaternion.cpp}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Quaternion.h"}\par
00002 \par
00003 {\cf21 #include "Matrix.h"}\par
00004 {\cf21 #include <memory>}\par
00005 \par
00006 {\cf17 namespace }DCL\par
00007 \{\par
00008     CQuaternion::CQuaternion()\par
00009     \{\par
00010         setIdentity();\par
00011     \}\par
00012 \par
00013     CQuaternion::CQuaternion({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ, {\cf18 float} fW)\par
00014     \{\par
00015         q[0] = fX;\par
00016         q[1] = fY;\par
00017         q[2] = fZ;\par
00018         q[3] = fW;\par
00019     \}\par
00020 \par
00021     CQuaternion::CQuaternion({\cf17 const} CQuaternion& quaternion)\par
00022     \{\par
00023         *{\cf17 this} = quaternion;\par
00024     \}\par
00025 \par
00026     {\cf18 float}& CQuaternion::operator []({\cf17 const} {\cf18 int} iIndex)\par
00027     \{\par
00028         {\cf19 return} q[iIndex];\par
00029     \}\par
00030 \par
00031     {\cf17 const} CQuaternion CQuaternion::operator *({\cf17 const} CQuaternion& quat){\cf17  const}\par
00032 {\cf17     }\{\par
00033         {\cf20 /* Does the same as below? But too many sqrtf}\par
00034 {\cf20         CVector3 v1(mfQuat[0], mfQuat[1], mfQuat[2]);}\par
00035 {\cf20         CVector3 v2(quat.mfQuat[0], quat.mfQuat[1], quat.mfQuat[2]);}\par
00036 {\cf20         CVector3 vFinal = v1 * quat.mfQuat[3] + v2 * mfQuat[3] + v1.getCross(v2);}\par
00037 {\cf20         float fScalar = mfQuat[3] * quat.mfQuat[3] - v1.getDot(v2);}\par
00038 {\cf20         return CQuaternion(vFinal.x, vFinal.y, vFinal.z, fScalar);}\par
00039 {\cf20         */}\par
00040         {\cf19 return} CQuaternion(q[3] * quat.q[0] + q[0] * quat.q[3] +\par
00041             q[1] * quat.q[2] - q[2] * quat.q[1],\par
00042 \par
00043             q[3] * quat.q[1] + q[1] * quat.q[3] +\par
00044             q[2] * quat.q[0] - q[0] * quat.q[2],\par
00045 \par
00046             q[3] * quat.q[2] + q[2] * quat.q[3] +\par
00047             q[0] * quat.q[1] - q[1] * quat.q[0],\par
00048 \par
00049             q[3] * quat.q[3] - q[0] * quat.q[0] -\par
00050             q[1] * quat.q[1] - q[2] * quat.q[2]);\par
00051     \}\par
00052 \par
00053     {\cf17 const} {\cf18 void} CQuaternion::operator *=({\cf17 const} CQuaternion& quat)\par
00054     \{\par
00055         CQuaternion tmp(q[3] * quat.q[0] + q[0] * quat.q[3] +\par
00056             q[1] * quat.q[2] - q[2] * quat.q[1],\par
00057 \par
00058             q[3] * quat.q[1] + q[1] * quat.q[3] +\par
00059             q[2] * quat.q[0] - q[0] * quat.q[2],\par
00060 \par
00061             q[3] * quat.q[2] + q[2] * quat.q[3] +\par
00062             q[0] * quat.q[1] - q[1] * quat.q[0],\par
00063 \par
00064             q[3] * quat.q[3] - q[0] * quat.q[0] -\par
00065             q[1] * quat.q[1] - q[2] * quat.q[2]);\par
00066         *{\cf17 this} = tmp;\par
00067     \}\par
00068 \par
00069     {\cf17 const} CQuaternion CQuaternion::operator +({\cf17 const} CQuaternion& quat){\cf17  const}\par
00070 {\cf17     }\{\par
00071         {\cf19 return} CQuaternion(\par
00072             q[0] + quat.q[0],\par
00073             q[1] + quat.q[1],\par
00074             q[2] + quat.q[2],\par
00075             q[3] + quat.q[3]);\par
00076     \}\par
00077 \par
00078     {\cf17 const} CQuaternion CQuaternion::operator -({\cf17 const} CQuaternion& quat){\cf17  const}\par
00079 {\cf17     }\{\par
00080         {\cf19 return} CQuaternion(\par
00081             q[0] - quat.q[0],\par
00082             q[1] - quat.q[1],\par
00083             q[2] - quat.q[2],\par
00084             q[3] - quat.q[3]);\par
00085     \}\par
00086 \par
00087     {\cf17 const} CQuaternion CQuaternion::operator *({\cf17 const} {\cf18 float} fScalar){\cf17  const}\par
00088 {\cf17     }\{\par
00089         {\cf19 return} CQuaternion(\par
00090             q[0] * fScalar,\par
00091             q[1] * fScalar,\par
00092             q[2] * fScalar,\par
00093             q[3] * fScalar);\par
00094     \}\par
00095 \par
00096     {\cf17 const} CQuaternion CQuaternion::operator /({\cf17 const} {\cf18 float} fScalar){\cf17  const}\par
00097 {\cf17     }\{\par
00098         {\cf18 float} fInvScl = 1 / fScalar;\par
00099         {\cf19 return} CQuaternion(\par
00100             q[0] * fInvScl,\par
00101             q[1] * fInvScl,\par
00102             q[2] * fInvScl,\par
00103             q[3] * fInvScl);\par
00104     \}\par
00105 \par
00106     CVector3f CQuaternion::operator *({\cf17 const} CVector3f& vec){\cf17  const}\par
00107 {\cf17     }\{\par
00108         {\cf20 // nVidia SDK implementation (Taken from OGRE)}\par
00109         CVector3f v2, v3;\par
00110         CVector3f vQ(q[0], q[1], q[2]);\par
00111         v2 = vQ.getCross(vec);\par
00112         v3 = vQ.getCross(v2);\par
00113         v2 *= (2.0f * q[3]);\par
00114         v3 *= 2.0f;\par
00115         {\cf19 return} vec + v2 + v3;\par
00116     \}\par
00117 \par
00118     {\cf17 const} {\cf18 void} CQuaternion::operator =({\cf17 const} CQuaternion& quat)\par
00119     \{\par
00120         memcpy(q, quat.q, {\cf17 sizeof}({\cf18 float}[4]));\par
00121     \}\par
00122 \par
00123     {\cf17 const} {\cf18 bool} CQuaternion::operator ==({\cf17 const} CQuaternion& quat){\cf17  const}\par
00124 {\cf17     }\{\par
00125         {\cf19 return} (q[0] == quat.q[0] && q[1] == quat.q[1] && q[2] == quat.q[2] && q[3] == quat.q[3]);\par
00126     \}\par
00127 \par
00128     {\cf17 const} {\cf18 bool} CQuaternion::operator != ({\cf17 const} CQuaternion& quat){\cf17  const}\par
00129 {\cf17     }\{\par
00130         {\cf19 return} !(*{\cf17 this} == quat);\par
00131     \}\par
00132 \par
00133     {\cf18 void} CQuaternion::setIdentity({\cf18 void})\par
00134     \{\par
00135         q[0] = q[1] = q[2] = 0;\par
00136         q[3] = 1;\par
00137     \}\par
00138 \par
00139     {\cf18 float} CQuaternion::getMagnitude({\cf18 void}){\cf17  const}\par
00140 {\cf17     }\{\par
00141         {\cf19 return} sqrtf((q[0] * q[0]) +\par
00142             (q[1] * q[1]) +\par
00143             (q[2] * q[2]) +\par
00144             (q[3] * q[3]));\par
00145     \}\par
00146 \par
00147     {\cf18 void} CQuaternion::normalise({\cf18 void})\par
00148     \{\par
00149         {\cf18 float} fInvMag = 1.0f / getMagnitude();\par
00150         {\cf19 if} (fInvMag != 1.0f)\par
00151         \{\par
00152             q[0] *= fInvMag;\par
00153             q[1] *= fInvMag;\par
00154             q[2] *= fInvMag;\par
00155             q[3] *= fInvMag;\par
00156         \}\par
00157     \}\par
00158 \par
00159     CQuaternion CQuaternion::getConjugate({\cf18 void}){\cf17  const}\par
00160 {\cf17     }\{\par
00161         {\cf19 return} CQuaternion(-q[0], -q[1], -q[2], q[3]);\par
00162     \}\par
00163 \par
00164     CQuaternion CQuaternion::getNegative({\cf18 void}){\cf17  const}\par
00165 {\cf17     }\{\par
00166         {\cf19 return} CQuaternion(-q[0], -q[1], -q[2], -q[3]);\par
00167     \}\par
00168 \par
00169     {\cf18 void} CQuaternion::setFromAxisAngle({\cf17 const} CVector3f& vAxis, {\cf18 float} fAngleRadians)\par
00170     \{\par
00171         {\cf18 float} sa = sinf(fAngleRadians * 0.5f);\par
00172         {\cf18 float} ca = cosf(fAngleRadians * 0.5f);\par
00173         q[0] = vAxis.x * sa;\par
00174         q[1] = vAxis.y * sa;\par
00175         q[2] = vAxis.z * sa;\par
00176         q[3] = ca;\par
00177     \}\par
00178 \par
00179     CVector3f CQuaternion::getAxis({\cf18 void}){\cf17  const}\par
00180 {\cf17     }\{\par
00181         {\cf18 float} sa = 1 / sqrtf(1 - (q[4] * q[4]));\par
00182         {\cf19 return} CVector3f(q[0] * sa, q[1] * sa, q[2] * sa);\par
00183     \}\par
00184 \par
00185     {\cf18 float} CQuaternion::getAngle({\cf18 void}){\cf17  const}\par
00186 {\cf17     }\{\par
00187         {\cf19 return} ({\cf18 float})2 * acosf(q[3]);\par
00188     \}\par
00189 \par
00190     {\cf18 void} CQuaternion::setFromEuler({\cf18 float} fAngleRadiansX, {\cf18 float} fAngleRadiansY, {\cf18 float} fAngleRadiansZ)\par
00191     \{\par
00192         {\cf18 double} dSY = sin(fAngleRadiansZ * 0.5f);\par
00193         {\cf18 double} dSP = sin(fAngleRadiansY * 0.5f);\par
00194         {\cf18 double} dSR = sin(fAngleRadiansX * 0.5f);\par
00195         {\cf18 double} dCY = cos(fAngleRadiansZ * 0.5f);\par
00196         {\cf18 double} dCP = cos(fAngleRadiansY * 0.5f);\par
00197         {\cf18 double} dCR = cos(fAngleRadiansX * 0.5f);\par
00198 \par
00199         q[0] = float(dSR * dCP * dCY - dCR * dSP * dSY);\par
00200         q[1] = float(dCR * dSP * dCY + dSR * dCP * dSY);\par
00201         q[2] = float(dCR * dCP * dSY - dSR * dSP * dCY);\par
00202         q[3] = float(dCR * dCP * dCY + dSR * dSP * dSY);\par
00203         normalise();\par
00204     \}\par
00205 \par
00206     CVector3f CQuaternion::getEuler({\cf18 void}){\cf17  const}\par
00207 {\cf17     }\{\par
00208         {\cf18 float} fSq[4];\par
00209         fSq[0] = q[0] * q[0];\par
00210         fSq[1] = q[1] * q[1];\par
00211         fSq[2] = q[2] * q[2];\par
00212         fSq[3] = q[3] * q[3];\par
00213 \par
00214         {\cf18 double} m11 = fSq[3] + fSq[0] - fSq[1] - fSq[2];\par
00215         {\cf18 double} m21 = 2 * (q[0] * q[1] + q[2] * q[3]);\par
00216         {\cf18 double} m31 = 2 * (q[2] * q[0] - q[1] * q[3]);\par
00217         {\cf18 double} m32 = 2 * (q[2] * q[1] + q[0] * q[3]);\par
00218         {\cf18 double} m33 = fSq[3] - fSq[0] - fSq[1] + fSq[2];\par
00219         {\cf19 return} CVector3f({\cf18 float}(atan2(m32, m33)), asinf({\cf18 float}(-m31)), {\cf18 float}(atan2(m21, m11)));\par
00220     \}\par
00221 \par
00222     {\cf18 void} CQuaternion::setFromMatrix({\cf17 const} CMatrix& m)\par
00223     \{\par
00224         {\cf18 float} fTr = m.m[0] + m.m[5] + m.m[9] + 1.0f;\par
00225         {\cf20 // If the trace of the matrix is greater than 0, perform an instant calculation}\par
00226         {\cf19 if} (fTr > 0)\par
00227         \{\par
00228             {\cf18 float} fS = 0.5f / sqrtf(fTr);\par
00229 \par
00230             q[3] = 0.25f / fS;\par
00231             q[0] = (m.m[9] - m.m[6]) * fS;\par
00232             q[1] = (m.m[2] - m.m[8]) * fS;\par
00233             q[2] = (m.m[4] - m.m[1]) * fS;\par
00234         \}\par
00235         {\cf20 // if the first diagonal element is the largest}\par
00236         {\cf19 else} {\cf19 if} (m.m[0] > m.m[5] && m.m[0] > m.m[10])\par
00237         \{\par
00238             {\cf18 float} fS = float(1 / (sqrt(m.m[0] - m.m[5] - m.m[10] + 1.0f) * 2));\par
00239             q[0] = 0.5f * fS;\par
00240             q[1] = (m.m[1] + m.m[4]) * fS;\par
00241             q[2] = (m.m[2] + m.m[8]) * fS;\par
00242             q[3] = (m.m[6] + m.m[9]) * fS;\par
00243         \}\par
00244         {\cf20 // if the second.....}\par
00245         {\cf19 else} {\cf19 if} (m.m[5] > m.m[10])\par
00246         \{\par
00247             {\cf18 float} fS = float(1 / (sqrt(m.m[5] - m.m[0] - m.m[10] + 1.0f) * 2));\par
00248             q[0] = (m.m[1] + m.m[4]) * fS;\par
00249             q[1] = 0.5f * fS;\par
00250             q[2] = (m.m[6] + m.m[9]) * fS;\par
00251             q[3] = (m.m[2] + m.m[8]) * fS;\par
00252         \}\par
00253         {\cf20 // if the last element is the largest}\par
00254         {\cf19 else}\par
00255         \{\par
00256             {\cf18 float} fS = float(1 / (sqrt(m.m[10] - m.m[0] - m.m[5] + 1.0f) * 2));\par
00257             q[0] = (m.m[2] + m.m[8]) * fS;\par
00258             q[1] = (m.m[6] + m.m[9]) * fS;\par
00259             q[2] = 0.5f * fS;\par
00260             q[3] = (m.m[1] + m.m[4]) * fS;\par
00261         \}\par
00262     \}\par
00263 \par
00264     {\cf18 void} CQuaternion::rotate({\cf17 const} CQuaternion& quat)\par
00265     \{\par
00266         CQuaternion tmp(quat * (*{\cf17 this}) * quat.getConjugate());\par
00267         *{\cf17 this} = tmp;\par
00268     \}\par
00269 \par
00270     CQuaternion CQuaternion::getSLERP({\cf17 const} CQuaternion& quat, {\cf18 float} fInterval){\cf17  const}\par
00271 {\cf17     }\{\par
00272         CQuaternion q(quat);\par
00273 \par
00274         {\cf18 float} fDot = q[0] * q.q[0] + q[1] * q.q[1] + q[2] * q.q[2] + q[3] * q.q[3];\par
00275         {\cf19 if} (fDot < 0.0f)\par
00276         \{\par
00277             q = q.getNegative();\par
00278             fDot = -fDot;\par
00279         \}\par
00280 \par
00281         {\cf20 // Inaccurate, use lerp instead}\par
00282         {\cf19 if} (fDot < 1.00001f && fDot > 0.99999f)\par
00283         \{\par
00284             {\cf19 return} getLERP(q, fInterval);\par
00285         \}\par
00286 \par
00287         {\cf20 // Calculate the angle between the quaternions }\par
00288         {\cf18 float} fTheta = acosf(fDot);\par
00289 \par
00290         {\cf19 return} ((*{\cf17 this} * sinf(fTheta * (1 - fInterval)) + q * sinf(fTheta * fInterval)) / sinf(fTheta));\par
00291     \}\par
00292 \par
00293     CQuaternion CQuaternion::getLERP({\cf17 const} CQuaternion& quat, {\cf18 float} fInterval){\cf17  const}\par
00294 {\cf17     }\{\par
00295         CQuaternion ret(((quat - *{\cf17 this}) * fInterval) + *{\cf17 this});\par
00296         ret.normalise();\par
00297         {\cf19 return} ret;\par
00298     \}\par
00299 \par
00300 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Quaternion.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Quaternion.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Quaternion.h}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Quaternions. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Vector3f.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CQuaternion}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Quaternion class to represent rotations. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Quaternions. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b Quaternion.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Quaternion.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Quaternion.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Quaternion.h}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef QUATERNION_H}\par
00007 {\cf21 #define QUATERNION_H}\par
00008 \par
00009 {\cf21 #include "Vector3f.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00013     {\cf17 class }CMatrix;  {\cf20 // Declare CMatrix class here so we don't have to include the Matrix.h header}\par
00014 \par
00016     {\cf17 class }CQuaternion\par
00017     \{\par
00018     {\cf17 public}:\par
00020         CQuaternion();\par
00021 \par
00028         CQuaternion({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ, {\cf18 float} fW);\par
00029 \par
00033         CQuaternion({\cf17 const} CQuaternion& quaternion);\par
00034 \par
00036         {\cf18 float}& operator[] ({\cf17 const} {\cf18 int} iIndex);\par
00037 \par
00039         {\cf17 const} CQuaternion operator * ({\cf17 const} CQuaternion& quaternion) {\cf17 const};\par
00040 \par
00042         {\cf17 const} {\cf18 void} operator *= ({\cf17 const} CQuaternion& quaternion);\par
00043 \par
00045         {\cf17 const} CQuaternion operator+({\cf17 const} CQuaternion& quat) {\cf17 const};\par
00046 \par
00048         {\cf17 const} CQuaternion operator-({\cf17 const} CQuaternion& quat) {\cf17 const};\par
00049 \par
00051         {\cf17 const} CQuaternion operator*({\cf17 const} {\cf18 float} fScalar) {\cf17 const};\par
00052 \par
00054         {\cf17 const} CQuaternion operator/({\cf17 const} {\cf18 float} fScalar) {\cf17 const};\par
00055 \par
00057         CVector3f operator *({\cf17 const} CVector3f& vec) {\cf17 const};\par
00058 \par
00060         {\cf17 const} {\cf18 void} operator = ({\cf17 const} CQuaternion& quat);\par
00061 \par
00063         {\cf17 const} {\cf18 bool} operator == ({\cf17 const} CQuaternion& quat) {\cf17 const};\par
00064 \par
00066         {\cf17 const} {\cf18 bool} operator != ({\cf17 const} CQuaternion& quat) {\cf17 const};\par
00067 \par
00069         {\cf18 void} setIdentity({\cf18 void});\par
00070 \par
00074         {\cf18 float} getMagnitude({\cf18 void}) {\cf17 const};\par
00075 \par
00077         {\cf18 void} normalise({\cf18 void});\par
00078 \par
00082         CQuaternion getConjugate({\cf18 void}) {\cf17 const};\par
00083 \par
00087         CQuaternion getNegative({\cf18 void}) {\cf17 const};\par
00088 \par
00095         {\cf18 void} setFromAxisAngle({\cf17 const} CVector3f& vAxis, {\cf18 float} fAngleRadians);\par
00096 \par
00100         CVector3f getAxis({\cf18 void}) {\cf17 const};\par
00101 \par
00105         {\cf18 float} getAngle({\cf18 void}) {\cf17 const};\par
00106 \par
00112         {\cf18 void} setFromEuler({\cf18 float} fAngleRadiansX, {\cf18 float} fAngleRadiansY, {\cf18 float} fAngleRadiansZ);\par
00113 \par
00117         CVector3f getEuler({\cf18 void}) {\cf17 const};\par
00118 \par
00122         {\cf18 void} setFromMatrix({\cf17 const} CMatrix& matrix);\par
00123 \par
00127         {\cf18 void} rotate({\cf17 const} CQuaternion& quat);\par
00128 \par
00134         CQuaternion getSLERP({\cf17 const} CQuaternion& quaternion, {\cf18 float} fInterval) {\cf17 const};\par
00135 \par
00140         CQuaternion getLERP({\cf17 const} CQuaternion& quaternion, {\cf18 float} fInterval) {\cf17 const};\par
00141 \par
00142         {\cf18 float} q[4]; \par
00143     \};\par
00144 \par
00145 \}   {\cf20 // namespace DCL}\par
00146 \par
00147 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Rect.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Rect.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Rect.cpp}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Rect.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005     CRect::CRect()\par
00006     \{\par
00007     \}\par
00008 \par
00009     CRect::CRect({\cf18 int} iMinX, {\cf18 int} iMinY, {\cf18 int} iMaxX, {\cf18 int} iMaxY)\par
00010     \{\par
00011         miMinX = iMinX;\par
00012         miMinY = iMinY;\par
00013         miMaxX = iMaxX;\par
00014         miMaxY = iMaxY;\par
00015     \}\par
00016 \par
00017     {\cf18 void} CRect::set({\cf18 int} iMinX, {\cf18 int} iMinY, {\cf18 int} iMaxX, {\cf18 int} iMaxY)\par
00018     \{\par
00019         miMinX = iMinX;\par
00020         miMinY = iMinY;\par
00021         miMaxX = iMaxX;\par
00022         miMaxY = iMaxY;\par
00023     \}\par
00024 \par
00025     {\cf18 bool} CRect::intersects({\cf17 const} CRect& other){\cf17  const}\par
00026 {\cf17     }\{\par
00027         {\cf19 if} (miMaxX < other.miMinX)\par
00028             {\cf19 return} {\cf17 false};\par
00029         {\cf19 if} (miMinX > other.miMaxX)\par
00030             {\cf19 return} {\cf17 false};\par
00031         {\cf19 if} (miMaxY < other.miMinY)\par
00032             {\cf19 return} {\cf17 false};\par
00033         {\cf19 if} (miMinY > other.miMaxY)\par
00034             {\cf19 return} {\cf17 false};\par
00035 \par
00036         {\cf19 return} {\cf17 true};\par
00037     \}\par
00038 \par
00039     {\cf18 void} CRect::resizeArea({\cf18 int} iMultiplier)\par
00040     \{\par
00041         {\cf20 // Get current width and height of the rect}\par
00042         {\cf18 int} iCurrentWidth = miMaxX - miMinX;\par
00043         {\cf18 int} iCurrentHeight = miMaxY - miMinY;\par
00044 \par
00045         {\cf20 // Compute new dimensions}\par
00046         {\cf18 int} iNewWidth = iCurrentWidth * iMultiplier;\par
00047         {\cf18 int} iNewHeight = iCurrentHeight * iMultiplier;\par
00048 \par
00049         {\cf20 // Quarter the new dims, to get the amount to offset mvMin and mvMax by}\par
00050         {\cf18 int} iOffsetX = iNewWidth / 4;\par
00051         {\cf18 int} iOffsetY = iNewHeight / 4;\par
00052 \par
00053         {\cf20 // Offset mvMin and mvMax}\par
00054         miMinX -= iOffsetX;\par
00055         miMaxX += iOffsetX;\par
00056         miMinY -= iOffsetY;\par
00057         miMaxY += iOffsetY;\par
00058     \}\par
00059 \par
00060     {\cf18 bool} CRect::doesPositionFitWithin({\cf18 int} iPosX, {\cf18 int} iPosY)\par
00061     \{\par
00062         {\cf19 if} (iPosX < miMinX)\par
00063             {\cf19 return} {\cf17 false};\par
00064         {\cf19 if} (iPosX > miMaxX)\par
00065             {\cf19 return} {\cf17 false};\par
00066         {\cf19 if} (iPosY < miMinY)\par
00067             {\cf19 return} {\cf17 false};\par
00068         {\cf19 if} (iPosY > miMaxY)\par
00069             {\cf19 return} {\cf17 false};\par
00070         {\cf19 return} {\cf17 true};\par
00071     \}\par
00072 \par
00073     {\cf18 bool} CRect::doesPositionFitWithin({\cf17 const} CVector2f& vPos)\par
00074     \{\par
00075         {\cf19 return} doesPositionFitWithin({\cf18 int}(vPos.x), {\cf18 int}(vPos.y));\par
00076     \}\par
00077 \par
00078     {\cf18 void} CRect::getCentre({\cf18 int}& iCentreX, {\cf18 int}& iCentreY)\par
00079     \{\par
00080         {\cf20 // Compute dims}\par
00081         iCentreX = miMaxX - miMinX;\par
00082         iCentreY = miMaxY - miMinY;\par
00083 \par
00084         {\cf20 // Compute centre}\par
00085         iCentreX /= 2;\par
00086         iCentreY /= 2;\par
00087     \}\par
00088 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Rect.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Rect.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Rect.h}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Vector2f.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CRect}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a non-uniform cube aka a rectangle. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b Rect.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Rect.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Rect.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Rect.h}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef RECT_H}\par
00007 {\cf21 #define RECT_H}\par
00008 \par
00009 {\cf21 #include "Vector2f.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00016     {\cf17 class }CRect\par
00017     \{\par
00018     {\cf17 public}:\par
00020         CRect();\par
00021 \par
00028         CRect({\cf18 int} iMinX, {\cf18 int} iMinY, {\cf18 int} iMaxX, {\cf18 int} iMaxY);\par
00029 \par
00036         {\cf18 void} set({\cf18 int} iMinX, {\cf18 int} iMinY, {\cf18 int} iMaxX, {\cf18 int} iMaxY);\par
00037 \par
00042         {\cf18 bool} intersects({\cf17 const} CRect& other) {\cf17 const};\par
00043 \par
00051         {\cf18 void} resizeArea({\cf18 int} iMultiplier);\par
00052 \par
00058         {\cf18 bool} doesPositionFitWithin({\cf18 int} iPosX, {\cf18 int} iPosY);\par
00059 \par
00064         {\cf18 bool} doesPositionFitWithin({\cf17 const} CVector2f& vPos);\par
00065 \par
00070         {\cf18 void} getCentre({\cf18 int}& iCentreX, {\cf18 int}& iCentreY);\par
00071 \par
00072         {\cf18 int} miMinX;     \par
00073         {\cf18 int} miMinY;     \par
00074         {\cf18 int} miMaxX;     \par
00075         {\cf18 int} miMaxY;     \par
00076     \};\par
00077 \par
00078 \}   {\cf20 // namespace DCL}\par
00079 \par
00080 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Vector2f.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector2f.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector2f.cpp}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Vector2f.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     CVector2f::CVector2f()\par
00007     \{\par
00008         x = y = 0.0f;\par
00009     \}\par
00010 \par
00011     CVector2f::CVector2f({\cf18 float} fX, {\cf18 float} fY)\par
00012     \{\par
00013         x = fX;\par
00014         y = fY;\par
00015     \}\par
00016 \par
00017     CVector2f CVector2f::operator +({\cf17 const} CVector2f& vec){\cf17  const}\par
00018 {\cf17     }\{\par
00019         {\cf19 return} CVector2f(x + vec.x, y + vec.y);\par
00020     \}\par
00021 \par
00022     CVector2f& CVector2f::operator +=({\cf17 const} CVector2f& vec)\par
00023     \{\par
00024         x += vec.x;\par
00025         y += vec.y;\par
00026         {\cf19 return} *{\cf17 this};\par
00027     \}\par
00028 \par
00029     CVector2f CVector2f::operator -({\cf17 const} CVector2f& vec){\cf17  const}\par
00030 {\cf17     }\{\par
00031         {\cf19 return} CVector2f(x - vec.x, y - vec.y);\par
00032     \}\par
00033 \par
00034     CVector2f& CVector2f::operator -=({\cf17 const} CVector2f& vec)\par
00035     \{\par
00036         x -= vec.x;\par
00037         y -= vec.y;\par
00038         {\cf19 return} *{\cf17 this};\par
00039     \}\par
00040 \par
00041     {\cf17 const} CVector2f CVector2f::operator*({\cf17 const} {\cf18 float} f){\cf17  const}\par
00042 {\cf17     }\{\par
00043         {\cf19 return} CVector2f(x * f, y * f);\par
00044     \}\par
00045 \par
00046     {\cf18 void} CVector2f::operator*=({\cf17 const} {\cf18 float} f)\par
00047     \{\par
00048         x = x * f;\par
00049         y = y * f;\par
00050     \}\par
00051 \par
00052     {\cf18 bool} CVector2f::operator ==({\cf17 const} CVector2f& vec){\cf17  const}\par
00053 {\cf17     }\{\par
00054         {\cf19 return} x == vec.x && y == vec.y;\par
00055     \}\par
00056 \par
00057     {\cf18 bool} CVector2f::operator !=({\cf17 const} CVector2f& vec){\cf17  const}\par
00058 {\cf17     }\{\par
00059         {\cf19 return} x != vec.x || y != vec.y;\par
00060     \}\par
00061 \par
00062     {\cf18 void} CVector2f::divide({\cf18 float} fScaler)\par
00063     \{\par
00064         ThrowIfTrue(fScaler < 0.0000001f, {\cf22 "CVector2f::divide() given scalar of zero which creates a divide by zero."});\par
00065         {\cf18 float} f1Over = 1.0f / fScaler;\par
00066         x *= f1Over;\par
00067         y *= f1Over;\par
00068     \}\par
00069 \par
00070     {\cf18 void} CVector2f::multiply({\cf18 float} fScaler)\par
00071     \{\par
00072         x *= fScaler;\par
00073         y *= fScaler;\par
00074     \}\par
00075 \par
00076     {\cf18 void} CVector2f::set({\cf18 float} fX, {\cf18 float} fY)\par
00077     \{\par
00078         x = fX;\par
00079         y = fY;\par
00080     \}\par
00081 \par
00082     {\cf18 void} CVector2f::setZero({\cf18 void})\par
00083     \{\par
00084         x = y = 0.0f;\par
00085     \}\par
00086 \par
00087     {\cf18 bool} CVector2f::isZero({\cf18 void}){\cf17  const}\par
00088 {\cf17     }\{\par
00089         {\cf19 return} x == 0 && y == 0;\par
00090     \}\par
00091 \par
00092     {\cf18 void} CVector2f::negate({\cf18 void})\par
00093     \{\par
00094         x = -x;\par
00095         y = -y;\par
00096     \}\par
00097 \par
00098     {\cf18 float} CVector2f::getMagnitude({\cf18 void}){\cf17  const}\par
00099 {\cf17     }\{\par
00100         {\cf18 float} fMagnitude = x * x;\par
00101         fMagnitude += y * y;\par
00102         fMagnitude = sqrtf(fMagnitude);\par
00103         {\cf19 return} fMagnitude;\par
00104     \}\par
00105 \par
00106     {\cf18 void} CVector2f::normalise({\cf18 void})\par
00107     \{\par
00108         {\cf20 // Compute magnitude aka length}\par
00109         {\cf18 float} fMagnitude = x * x;\par
00110         fMagnitude += y * y;\par
00111         fMagnitude = sqrtf(fMagnitude);\par
00112         {\cf19 if} (fMagnitude == 0.0f) {\cf20 // Prevent divide by zero}\par
00113             {\cf19 return};\par
00114         {\cf18 float} fReciprocal = float(1.0f / fMagnitude);\par
00115         x *= fReciprocal;\par
00116         y *= fReciprocal;\par
00117     \}\par
00118 \par
00119     {\cf18 float} CVector2f::getDistance({\cf17 const} CVector2f& vec){\cf17  const}\par
00120 {\cf17     }\{\par
00121         {\cf18 float} fx = x - vec.x;\par
00122         {\cf18 float} fy = y - vec.y;\par
00123         {\cf19 return} sqrtf(fx * fx + fy * fy);\par
00124     \}\par
00125 \par
00126     {\cf18 float} CVector2f::getDistanceSquared({\cf17 const} CVector2f& vec){\cf17  const}\par
00127 {\cf17     }\{\par
00128         {\cf18 float} fx = x - vec.x;\par
00129         {\cf18 float} fy = y - vec.y;\par
00130         {\cf19 return} fx * fx + fy * fy;\par
00131     \}\par
00132 \par
00133     {\cf18 float} CVector2f::getSign({\cf17 const} CVector2f& vOther){\cf17  const}\par
00134 {\cf17     }\{\par
00135         {\cf19 if} (y * vOther.x > x * vOther.y)\par
00136         \{\par
00137             {\cf19 return} 1.0f;\par
00138         \}\par
00139         {\cf19 else}\par
00140         \{\par
00141             {\cf19 return} -1.0f;\par
00142         \}\par
00143     \}\par
00144 \par
00145     {\cf18 float} CVector2f::getDot({\cf17 const} CVector2f& vec){\cf17  const}\par
00146 {\cf17     }\{\par
00147         {\cf19 return} x * vec.x + y * vec.y;\par
00148     \}\par
00149 \par
00150     {\cf18 float} CVector2f::getAngleRadiansUnsigned({\cf17 const} CVector2f& vOther){\cf17  const}\par
00151 {\cf17     }\{\par
00152         {\cf18 float} fDot = getDot(vOther);\par
00153         {\cf19 if} (fDot < -1.0f)\par
00154             fDot = 1.0f;\par
00155         {\cf19 else} {\cf19 if} (fDot > 1.0f)\par
00156             fDot = 1.0f;\par
00157         {\cf19 return} acosf(fDot);\par
00158     \}\par
00159 \par
00160     {\cf18 float} CVector2f::getAngleRadiansSigned({\cf17 const} CVector2f& vOther){\cf17  const}\par
00161 {\cf17     }\{\par
00162         CVector2f vOtherNorm = vOther;\par
00163         vOtherNorm.normalise();\par
00164 \par
00165         {\cf18 float} fDot = getDot(vOtherNorm);\par
00166         {\cf20 // Make sure fDot is valid}\par
00167         {\cf19 if} (fDot < -1.0f)\par
00168             fDot = -1.0f;\par
00169         {\cf19 else} {\cf19 if} (fDot > 1.0f)\par
00170             fDot = 1.0f;\par
00171         {\cf18 float} fAngleRadians = acosf(fDot);\par
00172         fAngleRadians *= getSign(vOtherNorm);\par
00173         {\cf19 return} fAngleRadians;\par
00174     \}\par
00175 \par
00176     {\cf18 float} CVector2f::getAngleDegreesSigned({\cf17 const} CVector2f& vOther){\cf17  const}\par
00177 {\cf17     }\{\par
00178         {\cf20 // Normalise this vector}\par
00179         CVector2f vThisNorm(x, y);\par
00180         vThisNorm.normalise();\par
00181 \par
00182         {\cf20 // Normalise other vector}\par
00183         CVector2f vOtherNorm(vOther.x, vOther.y);\par
00184         vOtherNorm.normalise();\par
00185 \par
00186         {\cf20 // Compute dot}\par
00187         {\cf18 float} fTmp = vThisNorm.x * vOtherNorm.x + vThisNorm.y * vOtherNorm.y;\par
00188 \par
00189         {\cf20 // Convert to unsigned radians}\par
00190         {\cf20 // make sure fTmp is valid}\par
00191         {\cf19 if} (fTmp < -1.0f)\par
00192             fTmp = -1.0f;\par
00193         {\cf19 else} {\cf19 if} (fTmp > 1.0f)\par
00194             fTmp = 1.0f;\par
00195         fTmp = (float)acosf(fTmp);\par
00196 \par
00197         {\cf20 // Convert to signed radians}\par
00198         {\cf19 if} (vThisNorm.y * vOtherNorm.x < vThisNorm.x * vOtherNorm.y)\par
00199             fTmp *= -1.0f;\par
00200 \par
00201         {\cf20 // Convert to degrees}\par
00202         {\cf20 // NOTE: 180.0f / Pi is used to convert radians to degrees}\par
00203         {\cf20 // and it is a value of : 57.2957795}\par
00204         {\cf19 return} fTmp * 57.2957795f;\par
00205     \}\par
00206 \par
00207     {\cf18 float} CVector2f::getAngleDegrees360({\cf18 void}){\cf17  const}\par
00208 {\cf17     }\{\par
00209         {\cf20 // Normalise this vector}\par
00210         CVector2f vThisNorm(x, y);\par
00211         vThisNorm.normalise();\par
00212 \par
00213         CVector2f vNorth(0.0f, 1.0f);\par
00214 \par
00215         {\cf20 // Compute dot}\par
00216         {\cf18 float} fTmp = vThisNorm.x * vNorth.x + vThisNorm.y * vNorth.y;\par
00217 \par
00218         {\cf20 // Convert to unsigned radians}\par
00219         {\cf20 // First, make sure fTmp is valid}\par
00220         {\cf19 if} (fTmp < -1.0f)\par
00221             fTmp = -1.0f;\par
00222         {\cf19 else} {\cf19 if} (fTmp > 1.0f)\par
00223             fTmp = 1.0f;\par
00224         fTmp = (float)acosf(fTmp);\par
00225 \par
00226         {\cf20 // Convert to degrees}\par
00227         {\cf20 // NOTE: 180.0f / Pi is used to convert radians to degrees}\par
00228         {\cf20 // and it is a value of : 57.2957795}\par
00229         fTmp *= 57.2957795f;\par
00230 \par
00231         {\cf19 if} (vThisNorm.y * vNorth.x < vThisNorm.x * vNorth.y)\par
00232         \{\par
00233             {\cf19 return} fTmp;\par
00234         \}\par
00235         {\cf19 return} 180.0f + (180.0f - fTmp);\par
00236     \}\par
00237 \par
00238     {\cf18 void} CVector2f::rotate({\cf18 float} fDegrees)\par
00239     \{\par
00240         {\cf18 float} fRad = fDegrees * -0.01745329251994329576923690768489f;\par
00241         {\cf18 float} fOldX = x;\par
00242         {\cf18 float} fOldY = y;\par
00243         {\cf18 float} fSin, fCos;\par
00244         fSin = sinf(fRad);\par
00245         fCos = cosf(fRad);\par
00246         x = fOldX * fCos - fOldY * fSin;\par
00247         y = fOldX * fSin + fOldY * fCos;\par
00248     \}\par
00249 \par
00250     {\cf18 void} CVector2f::limitLength({\cf18 float} fMaxLength)\par
00251     \{\par
00252         {\cf18 float} fLen = getMagnitude();\par
00253         {\cf19 if} (fLen <= fMaxLength)\par
00254             {\cf19 return};\par
00255         divide(fLen);   {\cf20 // Normalise}\par
00256         multiply(fMaxLength);\par
00257     \}\par
00258 \par
00259     CVector2f CVector2f::getPerpendicular({\cf18 void}){\cf17  const}\par
00260 {\cf17     }\{\par
00261         {\cf20 //CVector2f vPerpendicular(y, -x);}\par
00262         CVector2f vPerpendicular(-y, x);\par
00263         {\cf19 return} vPerpendicular;\par
00264     \}\par
00265 \par
00266     CVector2f CVector2f::interpolate({\cf17 const} CVector2f& v1, {\cf17 const} CVector2f& v2, {\cf18 float} f){\cf17  const}\par
00267 {\cf17     }\{\par
00268         {\cf19 if} (f < 0.0f)\par
00269             {\cf19 return} v2;\par
00270         {\cf19 else} {\cf19 if} (f > 1.0f)\par
00271             {\cf19 return} v1;\par
00272         CVector2f vA = v1;\par
00273         vA.multiply(f);\par
00274         CVector2f vB = v2;\par
00275         vB.multiply(1.0f - f);\par
00276         {\cf19 return} vA + vB;\par
00277     \}\par
00278 \par
00279     {\cf18 void} CVector2f::getAsArray({\cf18 float}* pArray){\cf17  const}\par
00280 {\cf17     }\{\par
00281         pArray[0] = x;\par
00282         pArray[1] = y;\par
00283     \}\par
00284 \par
00285 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector2f.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector2f.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector2f.h}
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2D Vector }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CVector2f}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 2 floats. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2D Vector \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b Vector2f.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Vector2f.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector2f.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector2f.h}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef VECTOR2F_H}\par
00007 {\cf21 #define VECTOR2F_H}\par
00008 \par
00009 {\cf17 namespace }DCL\par
00010 \{\par
00012     {\cf17 class }CVector2f\par
00013     \{\par
00014     {\cf17 public}:\par
00016         CVector2f();\par
00017 \par
00022         CVector2f({\cf18 float} fX, {\cf18 float} fY);\par
00023 \par
00037         CVector2f operator +({\cf17 const} CVector2f& vec) {\cf17 const};\par
00038 \par
00052         CVector2f& operator +=({\cf17 const} CVector2f& vec);\par
00053 \par
00064         CVector2f operator -({\cf17 const} CVector2f& vec) {\cf17 const};\par
00065 \par
00076         CVector2f& operator -=({\cf17 const} CVector2f& vec);\par
00077 \par
00087         {\cf17 const} CVector2f operator *({\cf17 const} {\cf18 float} f) {\cf17 const};\par
00088 \par
00097         {\cf18 void} operator *=({\cf17 const} {\cf18 float} f);\par
00098 \par
00103         {\cf18 bool} operator ==({\cf17 const} CVector2f& vec) {\cf17 const};\par
00104 \par
00109         {\cf18 bool} operator !=({\cf17 const} CVector2f& vec) {\cf17 const};\par
00110 \par
00116         {\cf18 void} divide({\cf18 float} fScaler);\par
00117 \par
00123         {\cf18 void} multiply({\cf18 float} fScaler);\par
00124 \par
00129         {\cf18 void} set({\cf18 float} fX, {\cf18 float} fY);\par
00130 \par
00134         {\cf18 void} setZero({\cf18 void});\par
00135 \par
00139         {\cf18 bool} isZero({\cf18 void}) {\cf17 const};\par
00140 \par
00144         {\cf18 void} negate({\cf18 void});\par
00145 \par
00152         {\cf18 float} getMagnitude({\cf18 void}) {\cf17 const};\par
00153 \par
00158         {\cf18 void} normalise({\cf18 void});\par
00159 \par
00164         {\cf18 float} getDistance({\cf17 const} CVector2f& vec) {\cf17 const};\par
00165 \par
00174         {\cf18 float} getDistanceSquared({\cf17 const} CVector2f& vec) {\cf17 const};\par
00175 \par
00180         {\cf18 float} getSign({\cf17 const} CVector2f& vOther) {\cf17 const};\par
00181 \par
00192         {\cf18 float} getDot({\cf17 const} CVector2f& vec) {\cf17 const};\par
00193 \par
00198         {\cf18 float} getAngleRadiansUnsigned({\cf17 const} CVector2f& vOther) {\cf17 const};\par
00199 \par
00206         {\cf18 float} getAngleRadiansSigned({\cf17 const} CVector2f& vOther) {\cf17 const};\par
00207 \par
00214         {\cf18 float} getAngleDegreesSigned({\cf17 const} CVector2f& vOther) {\cf17 const};\par
00215 \par
00219         {\cf18 float} getAngleDegrees360({\cf18 void}) {\cf17 const};\par
00220 \par
00224         {\cf18 void} rotate({\cf18 float} fDegrees);\par
00225 \par
00231         {\cf18 void} limitLength({\cf18 float} fMaxLength);\par
00232 \par
00236         CVector2f getPerpendicular({\cf18 void}) {\cf17 const};\par
00237 \par
00249         CVector2f interpolate({\cf17 const} CVector2f& v1, {\cf17 const} CVector2f& v2, {\cf18 float} f) {\cf17 const};\par
00250 \par
00260         {\cf18 void} getAsArray({\cf18 float}* pArray) {\cf17 const};\par
00261 \par
00262         {\cf18 float} x;    \par
00263         {\cf18 float} y;    \par
00264     \};\par
00265 \par
00266 \}   {\cf20 // namespace DCL}\par
00267 \par
00268 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Vector3f.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector3f.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector3f.cpp}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Vector3f.h"}\par
00002 {\cf21 #include <math.h>}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     CVector3f::CVector3f()\par
00007     \{\par
00008         x = y = z = 0.0f;\par
00009     \}\par
00010 \par
00011     CVector3f::CVector3f({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ)\par
00012     \{\par
00013         x = fX;\par
00014         y = fY;\par
00015         z = fZ;\par
00016     \}\par
00017 \par
00018     CVector3f::CVector3f({\cf17 const} CVector3f& vector)\par
00019     \{\par
00020         x = vector.x;\par
00021         y = vector.y;\par
00022         z = vector.z;\par
00023     \}\par
00024 \par
00025     CVector3f CVector3f::operator +({\cf17 const} CVector3f& vec){\cf17  const}\par
00026 {\cf17     }\{\par
00027         {\cf19 return} CVector3f(x + vec.x, y + vec.y, z + vec.z);\par
00028     \}\par
00029 \par
00030     CVector3f& CVector3f::operator +=({\cf17 const} CVector3f& vec)\par
00031     \{\par
00032         x += vec.x;\par
00033         y += vec.y;\par
00034         z += vec.z;\par
00035         {\cf19 return} *{\cf17 this};\par
00036     \}\par
00037 \par
00038     CVector3f CVector3f::operator -({\cf17 const} CVector3f& vec){\cf17  const}\par
00039 {\cf17     }\{\par
00040         {\cf19 return} CVector3f(x - vec.x, y - vec.y, z - vec.z);\par
00041     \}\par
00042 \par
00043     CVector3f& CVector3f::operator -=({\cf17 const} CVector3f& vec)\par
00044     \{\par
00045         x -= vec.x;\par
00046         y -= vec.y;\par
00047         z -= vec.z;\par
00048         {\cf19 return} *{\cf17 this};\par
00049     \}\par
00050 \par
00051     {\cf17 const} CVector3f CVector3f::operator*({\cf17 const} {\cf18 float} f){\cf17  const}\par
00052 {\cf17     }\{\par
00053         {\cf19 return} CVector3f(x * f, y * f, z * f);\par
00054     \}\par
00055 \par
00056     CVector3f& CVector3f::operator*=({\cf17 const} {\cf18 float} f)\par
00057     \{\par
00058         x *= f;\par
00059         y *= f;\par
00060         z *= f;\par
00061         {\cf19 return} *{\cf17 this};\par
00062     \}\par
00063 \par
00064     {\cf18 bool} CVector3f::operator ==({\cf17 const} CVector3f& vec){\cf17  const}\par
00065 {\cf17     }\{\par
00066         {\cf19 return} x == vec.x && y == vec.y && z == vec.z;\par
00067     \}\par
00068 \par
00069     {\cf18 bool} CVector3f::operator !=({\cf17 const} CVector3f& vec){\cf17  const}\par
00070 {\cf17     }\{\par
00071         {\cf19 return} x != vec.x || y != vec.y || z != vec.z;\par
00072     \}\par
00073 \par
00074     {\cf18 void} CVector3f::set({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ)\par
00075     \{\par
00076         x = fX;\par
00077         y = fY;\par
00078         z = fZ;\par
00079     \}\par
00080 \par
00081     {\cf18 void} CVector3f::setZero({\cf18 void})\par
00082     \{\par
00083         x = y = z = 0.0f;\par
00084     \}\par
00085 \par
00086     {\cf18 bool} CVector3f::isZero({\cf18 void}){\cf17  const}\par
00087 {\cf17     }\{\par
00088         {\cf19 return} x == 0 && y == 0 && z == 0;\par
00089     \}\par
00090 \par
00091     {\cf18 void} CVector3f::negate({\cf18 void})\par
00092     \{\par
00093         x = -x;\par
00094         y = -y;\par
00095         z = -z;\par
00096     \}\par
00097 \par
00098     {\cf18 float} CVector3f::getMagnitude({\cf18 void}){\cf17  const}\par
00099 {\cf17     }\{\par
00100         {\cf18 float} fMagnitude = x * x;\par
00101         fMagnitude += y * y;\par
00102         fMagnitude += z * z;\par
00103         fMagnitude = sqrtf(fMagnitude);\par
00104         {\cf19 return} fMagnitude;\par
00105     \}\par
00106 \par
00107     {\cf18 void} CVector3f::normalise({\cf18 void})\par
00108     \{\par
00109         {\cf20 // Compute magnitude aka length}\par
00110         {\cf18 float} fMagnitude = x * x;\par
00111         fMagnitude += y * y;\par
00112         fMagnitude += z * z;\par
00113         fMagnitude = sqrtf(fMagnitude);\par
00114         {\cf19 if} (fMagnitude == 0.0f) {\cf20 // Prevent divide by zero}\par
00115             {\cf19 return};\par
00116         {\cf18 float} fReciprocal = 1.0f / fMagnitude;\par
00117         x *= fReciprocal;\par
00118         y *= fReciprocal;\par
00119         z *= fReciprocal;\par
00120     \}\par
00121 \par
00122     {\cf18 float} CVector3f::getDot({\cf17 const} CVector3f& vec){\cf17  const}\par
00123 {\cf17     }\{\par
00124         {\cf19 return} x * vec.x + y * vec.y + z * vec.z;\par
00125     \}\par
00126 \par
00127     CVector3f CVector3f::getCross({\cf17 const} CVector3f& vec){\cf17  const}\par
00128 {\cf17     }\{\par
00129         CVector3f vCross;\par
00130         vCross.x = y * vec.z - z * vec.y;\par
00131         vCross.y = z * vec.x - x * vec.z;\par
00132         vCross.z = x * vec.y - y * vec.x;\par
00133         {\cf19 return} vCross;\par
00134     \}\par
00135 \par
00136     {\cf18 float} CVector3f::getAngle({\cf17 const} CVector3f& vec){\cf17  const}\par
00137 {\cf17     }\{\par
00138         {\cf19 return} acosf(getDot(vec));\par
00139     \}\par
00140 \par
00141     {\cf18 float} CVector3f::getDistance({\cf17 const} CVector3f& vec){\cf17  const}\par
00142 {\cf17     }\{\par
00143         {\cf18 float} fx = x - vec.x;\par
00144         {\cf18 float} fy = y - vec.y;\par
00145         {\cf18 float} fz = z - vec.z;\par
00146         {\cf19 return} sqrtf(fx * fx + fy * fy + fz * fz);\par
00147     \}\par
00148 \par
00149     {\cf18 float} CVector3f::getDistanceSquared({\cf17 const} CVector3f& vec){\cf17  const}\par
00150 {\cf17     }\{\par
00151         {\cf18 float} fx = x - vec.x;\par
00152         {\cf18 float} fy = y - vec.y;\par
00153         {\cf18 float} fz = z - vec.z;\par
00154         {\cf19 return} fx * fx + fy * fy + fz * fz;\par
00155     \}\par
00156 \par
00157     {\cf18 void} CVector3f::getAsArray({\cf18 float}* pArray){\cf17  const}\par
00158 {\cf17     }\{\par
00159         pArray[0] = x;\par
00160         pArray[1] = y;\par
00161         pArray[2] = z;\par
00162     \}\par
00163 \par
00164     {\cf18 void} CVector3f::multiply({\cf18 float} f)\par
00165     \{\par
00166         x *= f;\par
00167         y *= f;\par
00168         z *= f;\par
00169     \}\par
00170 \par
00171     {\cf18 void} CVector3f::project({\cf17 const} CVector3f& vOriginPosition, {\cf17 const} CVector3f& vDirection, {\cf18 float} fProjectionAmount)\par
00172     \{\par
00173         *{\cf17 this} = vOriginPosition + (vDirection * fProjectionAmount);\par
00174     \}\par
00175 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector3f.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector3f.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector3f.h}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A three component floating point vector. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CVector3f}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 3 floats. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A three component floating point vector. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b Vector3f.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Vector3f.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector3f.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector3f.h}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef VECTOR3F_H}\par
00007 {\cf21 #define VECTOR3F_H}\par
00008 \par
00009 {\cf17 namespace }DCL\par
00010 \{\par
00011 \par
00013     {\cf17 class }CVector3f\par
00014     \{\par
00015     {\cf17 public}:\par
00017         CVector3f();\par
00018 \par
00024         CVector3f({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ);\par
00025 \par
00029         CVector3f({\cf17 const} CVector3f& vector);\par
00030 \par
00044         CVector3f operator +({\cf17 const} CVector3f& vec) {\cf17 const};\par
00045 \par
00059         CVector3f& operator +=({\cf17 const} CVector3f& vec);\par
00060 \par
00071         CVector3f operator -({\cf17 const} CVector3f& vec) {\cf17 const};\par
00072 \par
00083         CVector3f& operator -=({\cf17 const} CVector3f& vec);\par
00084 \par
00094         {\cf17 const} CVector3f operator *({\cf17 const} {\cf18 float} f) {\cf17 const};\par
00095 \par
00104         CVector3f& operator *=({\cf17 const} {\cf18 float} f);\par
00105 \par
00110         {\cf18 bool} operator ==({\cf17 const} CVector3f& vec) {\cf17 const};\par
00111 \par
00116         {\cf18 bool} operator !=({\cf17 const} CVector3f& vec) {\cf17 const};\par
00117 \par
00123         {\cf18 void} set({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ);\par
00124 \par
00128         {\cf18 void} setZero({\cf18 void});\par
00129 \par
00133         {\cf18 bool} isZero({\cf18 void}) {\cf17 const};\par
00134 \par
00138         {\cf18 void} negate({\cf18 void});\par
00139 \par
00146         {\cf18 float} getMagnitude({\cf18 void}) {\cf17 const};\par
00147 \par
00152         {\cf18 void} normalise({\cf18 void});\par
00153 \par
00164         {\cf18 float} getDot({\cf17 const} CVector3f& vec) {\cf17 const};\par
00165 \par
00172         CVector3f getCross({\cf17 const} CVector3f& vec) {\cf17 const};\par
00173 \par
00180         {\cf18 float} getAngle({\cf17 const} CVector3f& vec) {\cf17 const};\par
00181 \par
00186         {\cf18 float} getDistance({\cf17 const} CVector3f& vec) {\cf17 const};\par
00187 \par
00196         {\cf18 float} getDistanceSquared({\cf17 const} CVector3f& vec) {\cf17 const};\par
00197 \par
00207         {\cf18 void} getAsArray({\cf18 float}* pArray) {\cf17 const};\par
00208 \par
00214         {\cf18 void} multiply({\cf18 float} f);\par
00215 \par
00231         {\cf18 void} project({\cf17 const} CVector3f& vOriginPosition, {\cf17 const} CVector3f& vDirection, {\cf18 float} fProjectionAmount);\par
00232         \par
00233         {\cf18 float} x;    \par
00234         {\cf18 float} y;    \par
00235         {\cf18 float} z;    \par
00236     \};\par
00237 \par
00238 \}   {\cf20 // namespace DCL}\par
00239 \par
00240 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Vector4f.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector4f.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector4f.cpp}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Vector4f.h"}\par
00002 {\cf21 #include <math.h>}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     CVector4f::CVector4f()\par
00007     \{\par
00008         x = y = z = w = 0.0f;\par
00009     \}\par
00010 \par
00011     CVector4f::CVector4f({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ, {\cf18 float} fW)\par
00012     \{\par
00013         x = fX;\par
00014         y = fY;\par
00015         z = fZ;\par
00016         w = fW;\par
00017     \}\par
00018 \par
00019     CVector4f CVector4f::operator +({\cf17 const} CVector4f& vec){\cf17  const}\par
00020 {\cf17     }\{\par
00021         {\cf19 return} CVector4f(x + vec.x, y + vec.y, z + vec.z, w + vec.w);\par
00022     \}\par
00023 \par
00024     CVector4f& CVector4f::operator +=({\cf17 const} CVector4f& vec)\par
00025     \{\par
00026         x += vec.x;\par
00027         y += vec.y;\par
00028         z += vec.z;\par
00029         w += vec.w;\par
00030         {\cf19 return} *{\cf17 this};\par
00031     \}\par
00032 \par
00033     CVector4f CVector4f::operator -({\cf17 const} CVector4f& vec){\cf17  const}\par
00034 {\cf17     }\{\par
00035         {\cf19 return} CVector4f(x - vec.x, y - vec.y, z - vec.z, w - vec.w);\par
00036     \}\par
00037 \par
00038     CVector4f& CVector4f::operator -=({\cf17 const} CVector4f& vec)\par
00039     \{\par
00040         x -= vec.x;\par
00041         y -= vec.y;\par
00042         z -= vec.z;\par
00043         w -= vec.w;\par
00044         {\cf19 return} *{\cf17 this};\par
00045     \}\par
00046 \par
00047     {\cf17 const} CVector4f CVector4f::operator*({\cf17 const} {\cf18 float} f){\cf17  const}\par
00048 {\cf17     }\{\par
00049         {\cf19 return} CVector4f(x * f, y * f, z * f, w * f);\par
00050     \}\par
00051 \par
00052     {\cf18 void} CVector4f::operator*=({\cf17 const} {\cf18 float} f)\par
00053     \{\par
00054         x = x * f;\par
00055         y = y * f;\par
00056         z = z * f;\par
00057         w = w * f;\par
00058     \}\par
00059 \par
00060     {\cf17 const} CVector4f CVector4f::operator *({\cf17 const} CVector4f& v){\cf17  const}\par
00061 {\cf17     }\{\par
00062         CVector4f result;\par
00063         result.x = x * v.x;\par
00064         result.y = y * v.y;\par
00065         result.z = z * v.z;\par
00066         result.w = w * v.w;\par
00067         {\cf19 return} result;\par
00068     \}\par
00069 \par
00070     {\cf18 bool} CVector4f::operator ==({\cf17 const} CVector4f& vec){\cf17  const}\par
00071 {\cf17     }\{\par
00072         {\cf19 return} x == vec.x && y == vec.y && z == vec.z && w == vec.w;\par
00073     \}\par
00074 \par
00075     {\cf18 bool} CVector4f::operator !=({\cf17 const} CVector4f& vec){\cf17  const}\par
00076 {\cf17     }\{\par
00077         {\cf19 return} x != vec.x || y != vec.y || z != vec.z || w != vec.w;\par
00078     \}\par
00079 \par
00080     {\cf18 void} CVector4f::set({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ, {\cf18 float} fW)\par
00081     \{\par
00082         x = fX;\par
00083         y = fY;\par
00084         z = fZ;\par
00085         w = fW;\par
00086     \}\par
00087 \par
00088     {\cf18 void} CVector4f::setZero({\cf18 void})\par
00089     \{\par
00090         x = y = z = w = 0.0f;\par
00091     \}\par
00092 \par
00093     {\cf18 bool} CVector4f::isZero({\cf18 void}){\cf17  const}\par
00094 {\cf17     }\{\par
00095         {\cf19 return} x == 0 && y == 0 && z == 0 && w == 0;\par
00096     \}\par
00097 \par
00098     {\cf18 void} CVector4f::negate({\cf18 void})\par
00099     \{\par
00100         x = -x;\par
00101         y = -y;\par
00102         z = -z;\par
00103         w = -w;\par
00104     \}\par
00105 \par
00106     {\cf18 float} CVector4f::getMagnitude({\cf18 void}){\cf17  const}\par
00107 {\cf17     }\{\par
00108         {\cf18 float} fMagnitude = x * x;\par
00109         fMagnitude += y * y;\par
00110         fMagnitude += z * z;\par
00111         fMagnitude += w * w;\par
00112         fMagnitude = sqrtf(fMagnitude);\par
00113         {\cf19 return} fMagnitude;\par
00114     \}\par
00115 \par
00116     {\cf18 void} CVector4f::normalise({\cf18 void})\par
00117     \{\par
00118         {\cf20 // Compute magnitude aka length}\par
00119         {\cf18 float} fMagnitude = x * x;\par
00120         fMagnitude += y * y;\par
00121         fMagnitude += z * z;\par
00122         fMagnitude += w * w;\par
00123         fMagnitude = sqrtf(fMagnitude);\par
00124         {\cf19 if} (fMagnitude == 0.0f) {\cf20 // Prevent divide by zero}\par
00125             {\cf19 return};\par
00126         {\cf18 float} fReciprocal = 1.0f / fMagnitude;\par
00127         x *= fReciprocal;\par
00128         y *= fReciprocal;\par
00129         z *= fReciprocal;\par
00130         w *= fReciprocal;\par
00131     \}\par
00132 \par
00133     {\cf18 void} CVector4f::getAsArray({\cf18 float}* pArray){\cf17  const}\par
00134 {\cf17     }\{\par
00135         pArray[0] = x;\par
00136         pArray[1] = y;\par
00137         pArray[2] = z;\par
00138         pArray[3] = w;\par
00139     \}\par
00140 \par
00141     {\cf18 void} CVector4f::multiply({\cf18 float} f)\par
00142     \{\par
00143         x *= f;\par
00144         y *= f;\par
00145         z *= f;\par
00146         w *= f;\par
00147     \}\par
00148 \par
00149 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector4f.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector4f.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector4f.h}
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A four component floating point vector. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CVector4f}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector class, using 4 floats. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A four component floating point vector. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b Vector4f.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Vector4f.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector4f.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Math/Vector4f.h}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef VECTOR4F_H}\par
00007 {\cf21 #define VECTOR4F_H}\par
00008 \par
00009 {\cf17 namespace }DCL\par
00010 \{\par
00012     {\cf17 class }CVector4f\par
00013     \{\par
00014     {\cf17 public}:\par
00016         CVector4f();\par
00017 \par
00024         CVector4f({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ, {\cf18 float} fW);\par
00025 \par
00039         CVector4f operator +({\cf17 const} CVector4f& vec) {\cf17 const};\par
00040 \par
00054         CVector4f& operator +=({\cf17 const} CVector4f& vec);\par
00055 \par
00066         CVector4f operator -({\cf17 const} CVector4f& vec) {\cf17 const};\par
00067 \par
00078         CVector4f& operator -=({\cf17 const} CVector4f& vec);\par
00079 \par
00089         {\cf17 const} CVector4f operator *({\cf17 const} {\cf18 float} f) {\cf17 const};\par
00090 \par
00099         {\cf18 void} operator *=({\cf17 const} {\cf18 float} f);\par
00100 \par
00110         {\cf17 const} CVector4f operator *({\cf17 const} CVector4f& v) {\cf17 const};\par
00111 \par
00116         {\cf18 bool} operator ==({\cf17 const} CVector4f& vec) {\cf17 const};\par
00117 \par
00122         {\cf18 bool} operator !=({\cf17 const} CVector4f& vec) {\cf17 const};\par
00123 \par
00130         {\cf18 void} set({\cf18 float} fX, {\cf18 float} fY, {\cf18 float} fZ, {\cf18 float} fW);\par
00131 \par
00135         {\cf18 void} setZero({\cf18 void});\par
00136 \par
00140         {\cf18 bool} isZero({\cf18 void}) {\cf17 const};\par
00141 \par
00145         {\cf18 void} negate({\cf18 void});\par
00146 \par
00153         {\cf18 float} getMagnitude({\cf18 void}) {\cf17 const};\par
00154 \par
00159         {\cf18 void} normalise({\cf18 void});\par
00160 \par
00170         {\cf18 void} getAsArray({\cf18 float}* pArray) {\cf17 const};\par
00171 \par
00177         {\cf18 void} multiply({\cf18 float} f);\par
00178 \par
00179         {\cf18 float} x;    \par
00180         {\cf18 float} y;    \par
00181         {\cf18 float} z;    \par
00182         {\cf18 float} w;    \par
00183     \};\par
00184 \par
00185 \}   {\cf20 // namespace DCL}\par
00186 \par
00187 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NewFileTemplate.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/NewFileTemplate.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/NewFileTemplate.cpp}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "NewFileTemplate.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005 \par
00006 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/NewFileTemplate.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/NewFileTemplate.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/NewFileTemplate.h}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CNewClassTemplate}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description text goes here. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. This file does nothing other than to demonstate how to document the code for the awesome app, Doxygen. It's also quite useful as a header file template which we can copy and paste into a newly created header file to save us some time. \par
}{
Definition in file {\b NewFileTemplate.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NewFileTemplate.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/NewFileTemplate.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/NewFileTemplate.h}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 \par
00008 {\cf21 #ifndef NEWFILE_TEMPLATE_H}\par
00009 {\cf21 #define NEWFILE_TEMPLATE_H}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00019     {\cf17 class }CNewClassTemplate\par
00020     \{\par
00021     {\cf17 public}:\par
00029         {\cf18 int} someMethod({\cf18 int} paramName, {\cf18 int}& paramINOUT)\par
00030         \{\par
00031             {\cf19 return} 0;\par
00032         \}\par
00033 \par
00034         {\cf18 float} fSomeMember;      \par
00035 \par
00036     {\cf17 private}:\par
00037         {\cf18 float} _mfSomePrivateMember; \par
00038 \par
00040         {\cf18 void} _privateMethod({\cf18 void});\par
00041     \};\par
00042 \par
00043 \}   {\cf20 // namespace DCL}\par
00044 \par
00045 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ray.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/Ray.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/Ray.cpp}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Ray.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005     CRay::CRay()\par
00006     \{\par
00007 \par
00008     \}\par
00009 \par
00010     CVector3f CRay::at({\cf18 float} t){\cf17  const}\par
00011 {\cf17     }\{\par
00012         {\cf19 return} vOrigin + (vDirection * t);\par
00013     \}\par
00014 \par
00015 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/Ray.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/Ray.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/Ray.h}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds a ray class for ray tracing. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../Math/Vector3f.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CRay}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A ray class used to represent a ray. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds a ray class for ray tracing. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b Ray.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ray.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/Ray.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/RayTracer/Ray.h}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef RAY_H}\par
00007 {\cf21 #define RAY_H}\par
00008 \par
00009 {\cf21 #include "../Math/Vector3f.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00026     {\cf17 class }CRay\par
00027     \{\par
00028     {\cf17 public}:\par
00032         CRay();\par
00033 \par
00053         CVector3f at({\cf18 float} t) {\cf17 const};\par
00054 \par
00055         CVector3f vOrigin;          \par
00056         CVector3f vDirection;       \par
00057     \};\par
00058 \par
00059 \}   {\cf20 // namespace DCL}\par
00060 \par
00061 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RendererBase.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererBase.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererBase.cpp}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "RendererBase.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005 \par
00006 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererBase.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererBase.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererBase.h}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CRendererBase}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for the various renderers. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b RendererBase.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RendererBase.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererBase.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererBase.h}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef RENDERER_H}\par
00007 {\cf21 #define RENDERER_H}\par
00008 \par
00009 {\cf21 #include <string>}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00030     {\cf17 class }CRendererBase\par
00031     \{\par
00032     {\cf17 public}:\par
00034         {\cf17 virtual} {\cf18 void} initialise({\cf18 unsigned} {\cf18 int} iWindowWidth, {\cf18 unsigned} {\cf18 int} iWindowHeight, {\cf17 const} std::string& strWindowTitle, {\cf18 bool} bFullscreen) = 0;\par
00035 \par
00037         {\cf17 virtual} {\cf18 void} shutdown({\cf18 void}) = 0;\par
00038     \par
00040         {\cf20 //virtual void beginFrame() = 0;}\par
00041         {\cf20 //virtual void endFrame() = 0;}\par
00042         {\cf20 //virtual void clear(const float r, const float g, const float b, const float a) = 0;}\par
00043 \par
00044         {\cf20 // Primitive drawing}\par
00045         {\cf20 //virtual void drawTriangles(const void* vertexData, size_t vertexCount, const void* indexData, size_t indexCount) = 0;}\par
00046         {\cf20 //virtual void drawLines(const void* vertexData, size_t vertexCount) = 0;}\par
00047         {\cf20 //virtual void drawPoints(const void* vertexData, size_t vertexCount) = 0;}\par
00048 \par
00049         {\cf20 // Texture management}\par
00050         {\cf20 //virtual Texture* createTexture(const void* data, int width, int height, TextureFormat format) = 0;}\par
00051         {\cf20 //virtual void destroyTexture(Texture* texture) = 0;}\par
00052         {\cf20 // Generate mipmaps : Generate mipmap levels for textures.}\par
00053         {\cf20 // Set texture parameters : Set texture wrapping, filtering, and anisotropy.}\par
00054         {\cf20 // Bind texture : Bind textures to texture units.}\par
00055 \par
00056         {\cf20 // Shader management}\par
00057         {\cf20 //virtual Shader* createShader(const char* vertexShaderSource, const char* fragmentShaderSource) = 0;}\par
00058         {\cf20 //virtual void destroyShader(Shader* shader) = 0;}\par
00059 \par
00060         {\cf20 // Material management (optional)}\par
00061         {\cf20 //virtual Material* createMaterial(Shader* shader) = 0;}\par
00062         {\cf20 //virtual void setMaterial(Material* material) = 0;}\par
00063         {\cf20 //virtual void destroyMaterial(Material* material) = 0;}\par
00064 \par
00065         {\cf20 // Other potential methods:}\par
00066     {\cf20 // - Set viewport dimensions and position}\par
00067 \par
00068 \par
00069 \par
00070 \par
00072         {\cf17 virtual} {\cf18 void} blendDisable({\cf18 void}) = 0;\par
00073 \par
00075         {\cf17 virtual} {\cf18 void} blendEnable({\cf18 void}) = 0;\par
00076 \par
00078         {\cf17 virtual} {\cf18 void} blendFunction_SrcAlpha_One({\cf18 void}) = 0;\par
00079 \par
00081         {\cf17 virtual} {\cf18 void} blendFunction_SrcAlpha_OneMinusSrcAlpha({\cf18 void}) = 0;\par
00082 \par
00084         {\cf17 virtual} {\cf18 void} cullFaceAntiClockwise({\cf18 void}) = 0;\par
00085 \par
00087         {\cf17 virtual} {\cf18 void} cullFaceClockwise({\cf18 void}) = 0;\par
00088 \par
00090         {\cf17 virtual} {\cf18 void} cullFaceDisable({\cf18 void}) = 0;\par
00091 \par
00093         {\cf17 virtual} {\cf18 void} cullFaceEnable({\cf18 void}) = 0;\par
00094 \par
00096         {\cf17 virtual} {\cf18 void} depthTestDisable({\cf18 void}) = 0;\par
00097 \par
00099         {\cf17 virtual} {\cf18 void} depthTestEnable({\cf18 void}) = 0;\par
00100 \par
00102         {\cf17 virtual} {\cf18 void} pixelsRead({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels) = 0;\par
00103 \par
00105         {\cf17 virtual} {\cf18 void} pixelsWrite({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels) = 0;\par
00106 \par
00108         {\cf17 virtual} {\cf18 void} scissorTest({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight) = 0;\par
00109 \par
00111         {\cf17 virtual} {\cf18 void} scissorTestDisable({\cf18 void}) = 0;\par
00112 \par
00114         {\cf17 virtual} {\cf18 void} scissorTestEnable({\cf18 void}) = 0;\par
00115 \par
00116 \par
00117     \};\par
00118 \par
00119 \}   {\cf20 // namespace DCL}\par
00120 \par
00121 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RendererManager.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererManager.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererManager.cpp}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "RendererManager.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     CRendererManager::CRendererManager()\par
00007     \{\par
00008         _mpRenderer = 0;\par
00009     \}\par
00010 \par
00011     CRendererManager::~CRendererManager()\par
00012     \{\par
00013 \par
00014     \}\par
00015 \par
00016     CRendererBase* CRendererManager::initOpenGL({\cf18 void})\par
00017     \{\par
00018         ThrowIfTrue(_mpRenderer, {\cf22 "CRendererManager::initOpenGL() failed. Renderer already initialised."});\par
00019         _mpRenderer = {\cf17 new} CRendererOpenGL;\par
00020         ThrowIfMemoryNotAllocated(_mpRenderer);\par
00021         {\cf19 return} _mpRenderer;\par
00022     \}\par
00023 \par
00024     CRendererBase* CRendererManager::initVulkan({\cf18 void})\par
00025     \{\par
00026         ThrowIfTrue(_mpRenderer, {\cf22 "CRendererManager::initVulkan() failed. Renderer already initialised."});\par
00027         _mpRenderer = {\cf17 new} CRendererVulkan;\par
00028         ThrowIfMemoryNotAllocated(_mpRenderer);\par
00029         {\cf19 return} _mpRenderer;\par
00030     \}\par
00031     CRendererBase* CRendererManager::get({\cf18 void})\par
00032     \{\par
00033         ThrowIfFalse(_mpRenderer, {\cf22 "CRendererManager::get() failed. Renderer is not initialised."});\par
00034         {\cf19 return} _mpRenderer;\par
00035     \}\par
00036 \par
00037 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererManager.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererManager.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererManager.h}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "rendererOpenGL.h"}\par
{\f2 #include "rendererVulkan.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CRendererManager}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renderer manager class for creating and holding a renderer. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b RendererManager.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RendererManager.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererManager.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererManager.h}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef RENDERERMANAGER_H}\par
00007 {\cf21 #define RENDERERMANAGER_H}\par
00008 \par
00009 {\cf21 #include "rendererOpenGL.h"}\par
00010 {\cf21 #include "rendererVulkan.h"}\par
00011 \par
00012 {\cf17 namespace }DCL\par
00013 \{\par
00015     {\cf17 class }CRendererManager\par
00016     \{\par
00017     {\cf17 public}:\par
00018         CRendererManager();\par
00019         ~CRendererManager();\par
00020 \par
00024         CRendererBase* initOpenGL({\cf18 void});\par
00025 \par
00029         CRendererBase* initVulkan({\cf18 void});\par
00030 \par
00035         CRendererBase* get({\cf18 void});\par
00036     {\cf17 private}:\par
00037         CRendererBase* _mpRenderer; \par
00038     \};\par
00039 \par
00040 \}   {\cf20 // namespace DCL}\par
00041 \par
00042 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RendererOpenGL.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererOpenGL.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererOpenGL.cpp}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "RendererOpenGL.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005     CRendererOpenGL::CRendererOpenGL()\par
00006     \{\par
00007     \}\par
00008 \par
00009     CRendererOpenGL::~CRendererOpenGL()\par
00010     \{\par
00011 \par
00012     \}\par
00013 \par
00014     {\cf18 void} CRendererOpenGL::initialise({\cf18 unsigned} {\cf18 int} iWindowWidth, {\cf18 unsigned} {\cf18 int} iWindowHeight, {\cf17 const} std::string& strWindowTitle, {\cf18 bool} bFullscreen)\par
00015     \{\par
00016 \par
00017     \}\par
00018 \par
00019     {\cf18 void} CRendererOpenGL::shutdown({\cf18 void})\par
00020     \{\par
00021 \par
00022     \}\par
00023 \par
00024     {\cf18 void} CRendererOpenGL::blendDisable({\cf18 void})\par
00025     \{\par
00026         glDisable(GL_BLEND);\par
00027     \}\par
00028 \par
00029     {\cf18 void} CRendererOpenGL::blendEnable({\cf18 void})\par
00030     \{\par
00031         glEnable(GL_BLEND);\par
00032     \}\par
00033 \par
00034     {\cf18 void} CRendererOpenGL::blendFunction_SrcAlpha_One({\cf18 void})\par
00035     \{\par
00036         glBlendFunc(GL_SRC_ALPHA, GL_ONE);\par
00037     \}\par
00038 \par
00039     {\cf18 void} CRendererOpenGL::blendFunction_SrcAlpha_OneMinusSrcAlpha({\cf18 void})\par
00040     \{\par
00041         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\par
00042     \}\par
00043 \par
00044     {\cf18 void} CRendererOpenGL::cullFaceAntiClockwise({\cf18 void})\par
00045     \{\par
00046 \par
00047     \}\par
00048 \par
00049     {\cf18 void} CRendererOpenGL::cullFaceClockwise({\cf18 void})\par
00050     \{\par
00051 \par
00052     \}\par
00053 \par
00054     {\cf18 void} CRendererOpenGL::cullFaceDisable({\cf18 void})\par
00055     \{\par
00056 \par
00057     \}\par
00058 \par
00059     {\cf18 void} CRendererOpenGL::cullFaceEnable({\cf18 void})\par
00060     \{\par
00061 \par
00062     \}\par
00063 \par
00064     {\cf18 void} CRendererOpenGL::depthTestDisable({\cf18 void})\par
00065     \{\par
00066         glDisable(GL_DEPTH_TEST);\par
00067     \}\par
00068 \par
00069     {\cf18 void} CRendererOpenGL::depthTestEnable({\cf18 void})\par
00070     \{\par
00071         glEnable(GL_DEPTH_TEST);\par
00072     \}\par
00073 \par
00074     {\cf18 void} CRendererOpenGL::pixelsRead({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels)\par
00075     \{\par
00076 \par
00077     \}\par
00078 \par
00079     {\cf18 void} CRendererOpenGL::pixelsWrite({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels)\par
00080     \{\par
00081 \par
00082     \}\par
00083 \par
00084     {\cf18 void} CRendererOpenGL::scissorTest({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight)\par
00085     \{\par
00086         glScissor(iPositionX, iPositionY, iWidth, iHeight);\par
00087     \}\par
00088 \par
00089     {\cf18 void} CRendererOpenGL::scissorTestEnable({\cf18 void})\par
00090     \{\par
00091         glEnable(GL_SCISSOR_TEST);\par
00092     \}\par
00093 \par
00094     {\cf18 void} CRendererOpenGL::scissorTestDisable({\cf18 void})\par
00095     \{\par
00096         glDisable(GL_SCISSOR_TEST);\par
00097     \}\par
00098 \par
00099 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererOpenGL.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererOpenGL.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererOpenGL.h}
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "RendererBase.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CRendererOpenGL}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b RendererOpenGL.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RendererOpenGL.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererOpenGL.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererOpenGL.h}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef RENDEREROPENGL_H}\par
00007 {\cf21 #define RENDEREROPENGL_H}\par
00008 \par
00009 {\cf21 #include "RendererBase.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00013     {\cf17 class }CRendererOpenGL : {\cf17 public} CRendererBase\par
00014     \{\par
00015     {\cf17 public}:\par
00016         CRendererOpenGL();\par
00017         ~CRendererOpenGL();\par
00018 \par
00019         {\cf18 void} initialise({\cf18 unsigned} {\cf18 int} iWindowWidth, {\cf18 unsigned} {\cf18 int} iWindowHeight, {\cf17 const} std::string& strWindowTitle, {\cf18 bool} bFullscreen);\par
00020         {\cf18 void} shutdown({\cf18 void});\par
00021 \par
00022         {\cf18 void} blendDisable({\cf18 void});\par
00023         {\cf18 void} blendEnable({\cf18 void});\par
00024         {\cf18 void} blendFunction_SrcAlpha_One({\cf18 void});\par
00025         {\cf18 void} blendFunction_SrcAlpha_OneMinusSrcAlpha({\cf18 void});\par
00026 \par
00027         {\cf18 void} cullFaceAntiClockwise({\cf18 void});\par
00028         {\cf18 void} cullFaceClockwise({\cf18 void});\par
00029         {\cf18 void} cullFaceDisable({\cf18 void});\par
00030         {\cf18 void} cullFaceEnable({\cf18 void});\par
00031 \par
00032         {\cf18 void} depthTestDisable({\cf18 void});\par
00033         {\cf18 void} depthTestEnable({\cf18 void});\par
00034 \par
00035         {\cf18 void} pixelsRead({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels);\par
00036         {\cf18 void} pixelsWrite({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels);\par
00037 \par
00038         {\cf18 void} scissorTest({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight);\par
00039         {\cf18 void} scissorTestDisable({\cf18 void});\par
00040         {\cf18 void} scissorTestEnable({\cf18 void});\par
00041 \par
00042     {\cf17 private}:\par
00043 \par
00044     \};\par
00045 \par
00046 \}   {\cf20 // namespace DCL}\par
00047 \par
00048 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RendererVulkan.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererVulkan.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererVulkan.cpp}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "RendererVulkan.h"}\par
00002 \par
00003 {\cf17 namespace }DCL\par
00004 \{\par
00005     CRendererVulkan::CRendererVulkan()\par
00006     \{\par
00007     \}\par
00008 \par
00009     CRendererVulkan::~CRendererVulkan()\par
00010     \{\par
00011 \par
00012     \}\par
00013 \par
00014     {\cf18 void} CRendererVulkan::initialise({\cf18 unsigned} {\cf18 int} iWindowWidth, {\cf18 unsigned} {\cf18 int} iWindowHeight, {\cf17 const} std::string& strWindowTitle, {\cf18 bool} bFullscreen)\par
00015     \{\par
00016 \par
00017     \}\par
00018 \par
00019     {\cf18 void} CRendererVulkan::shutdown({\cf18 void})\par
00020     \{\par
00021 \par
00022     \}\par
00023 \par
00024     {\cf18 void} CRendererVulkan::blendDisable({\cf18 void})\par
00025     \{\par
00026 \par
00027     \}\par
00028 \par
00029     {\cf18 void} CRendererVulkan::blendEnable({\cf18 void})\par
00030     \{\par
00031 \par
00032     \}\par
00033 \par
00034     {\cf18 void} CRendererVulkan::blendFunction_SrcAlpha_One({\cf18 void})\par
00035     \{\par
00036 \par
00037     \}\par
00038 \par
00039     {\cf18 void} CRendererVulkan::blendFunction_SrcAlpha_OneMinusSrcAlpha({\cf18 void})\par
00040     \{\par
00041 \par
00042     \}\par
00043 \par
00044     {\cf18 void} CRendererVulkan::cullFaceAntiClockwise({\cf18 void})\par
00045     \{\par
00046 \par
00047     \}\par
00048 \par
00049     {\cf18 void} CRendererVulkan::cullFaceClockwise({\cf18 void})\par
00050     \{\par
00051 \par
00052     \}\par
00053 \par
00054     {\cf18 void} CRendererVulkan::cullFaceDisable({\cf18 void})\par
00055     \{\par
00056 \par
00057     \}\par
00058 \par
00059     {\cf18 void} CRendererVulkan::cullFaceEnable({\cf18 void})\par
00060     \{\par
00061 \par
00062     \}\par
00063 \par
00064     {\cf18 void} CRendererVulkan::depthTestDisable({\cf18 void})\par
00065     \{\par
00066 \par
00067     \}\par
00068 \par
00069     {\cf18 void} CRendererVulkan::depthTestEnable({\cf18 void})\par
00070     \{\par
00071 \par
00072     \}\par
00073 \par
00074     {\cf18 void} CRendererVulkan::pixelsRead({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels)\par
00075     \{\par
00076 \par
00077     \}\par
00078 \par
00079     {\cf18 void} CRendererVulkan::pixelsWrite({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels)\par
00080     \{\par
00081 \par
00082     \}\par
00083 \par
00084     {\cf18 void} CRendererVulkan::scissorTest({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight)\par
00085     \{\par
00086 \par
00087     \}\par
00088 \par
00089     {\cf18 void} CRendererVulkan::scissorTestEnable({\cf18 void})\par
00090     \{\par
00091 \par
00092     \}\par
00093 \par
00094     {\cf18 void} CRendererVulkan::scissorTestDisable({\cf18 void})\par
00095     \{\par
00096 \par
00097     \}\par
00098 \par
00099 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererVulkan.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererVulkan.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererVulkan.h}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "RendererBase.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CRendererVulkan}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b RendererVulkan.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RendererVulkan.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererVulkan.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/Renderers/RendererVulkan.h}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef RENDERERVULKAN_H}\par
00007 {\cf21 #define RENDERERVULKAN_H}\par
00008 \par
00009 {\cf21 #include "RendererBase.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00013     {\cf17 class }CRendererVulkan : {\cf17 public} CRendererBase\par
00014     \{\par
00015     {\cf17 public}:\par
00016         CRendererVulkan();\par
00017         ~CRendererVulkan();\par
00018 \par
00019         {\cf18 void} initialise({\cf18 unsigned} {\cf18 int} iWindowWidth, {\cf18 unsigned} {\cf18 int} iWindowHeight, {\cf17 const} std::string& strWindowTitle, {\cf18 bool} bFullscreen);\par
00020         {\cf18 void} shutdown({\cf18 void});\par
00021 \par
00022         {\cf18 void} blendDisable({\cf18 void});\par
00023         {\cf18 void} blendEnable({\cf18 void});\par
00024         {\cf18 void} blendFunction_SrcAlpha_One({\cf18 void});\par
00025         {\cf18 void} blendFunction_SrcAlpha_OneMinusSrcAlpha({\cf18 void});\par
00026 \par
00027         {\cf18 void} cullFaceAntiClockwise({\cf18 void});\par
00028         {\cf18 void} cullFaceClockwise({\cf18 void});\par
00029         {\cf18 void} cullFaceDisable({\cf18 void});\par
00030         {\cf18 void} cullFaceEnable({\cf18 void});\par
00031 \par
00032         {\cf18 void} depthTestDisable({\cf18 void});\par
00033         {\cf18 void} depthTestEnable({\cf18 void});\par
00034 \par
00035         {\cf18 void} pixelsRead({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels);\par
00036         {\cf18 void} pixelsWrite({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight, {\cf18 void}* pixels);\par
00037 \par
00038         {\cf18 void} scissorTest({\cf18 int} iPositionX, {\cf18 int} iPositionY, {\cf18 int} iWidth, {\cf18 int} iHeight);\par
00039         {\cf18 void} scissorTestDisable({\cf18 void});\par
00040         {\cf18 void} scissorTestEnable({\cf18 void});\par
00041 \par
00042     {\cf17 private}:\par
00043 \par
00044     \};\par
00045 \}   {\cf20 // namespace DCL}\par
00046 \par
00047 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OctTree.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTree.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTree.cpp}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "OctTree.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     COctTree::COctTree({\cf18 int} iMaxEntitiesPerNode, {\cf18 float} fSizeIncreaseMultiplier)\par
00007     \{\par
00008         _mpRootNode = 0;\par
00009         init(iMaxEntitiesPerNode, fSizeIncreaseMultiplier);\par
00010     \}\par
00011 \par
00012     {\cf18 void} COctTree::init({\cf18 int} iMaxEntitiesPerNode, {\cf18 float} fSizeIncreaseMultiplier)\par
00013     \{\par
00014         free();\par
00015 \par
00016         CAABB aabbInitialRootNodeRegion(CVector3f(-8, -8, -8), CVector3f(8, 8, 8));\par
00017 \par
00018         {\cf20 // Attempt to create root node, passing 0 as the pointer to the parent node}\par
00019         _mpRootNode = {\cf17 new} COctTreeNode(aabbInitialRootNodeRegion, 0, {\cf17 this});\par
00020         ThrowIfFalse(_mpRootNode, {\cf22 "COctTree::init() failed. Unable to allocate memory for root node."});\par
00021 \par
00022         {\cf20 // Make sure valid values were given}\par
00023         ThrowIfTrue(iMaxEntitiesPerNode < 1, {\cf22 "COctTree::init() failed. Given invalid number for iMaxEntitiesPerNode. Must be at least one."});\par
00024         ThrowIfTrue(fSizeIncreaseMultiplier < 2, {\cf22 "COctTree::init() failed. Given invalid number for fSizeIncreaseMultiplier. Must be at least 2.0f."});\par
00025 \par
00026         {\cf20 // Store settings}\par
00027         _miMaxEntitiesPerNode = iMaxEntitiesPerNode;\par
00028         _mfSizeIncreaseMultiplier = fSizeIncreaseMultiplier;\par
00029 \par
00030         {\cf20 // Current maximum node depth}\par
00031         _muiCurrentMaxNodeDepth = 0;\par
00032 \par
00033         {\cf20 // Compute maximum node depth before node division is forbidden.}\par
00034         _computeMaxNodeDepth();\par
00035     \}\par
00036 \par
00037     COctTree::~COctTree()\par
00038     \{\par
00039         free();\par
00040     \}\par
00041 \par
00042     {\cf18 void} COctTree::free({\cf18 void})\par
00043     \{\par
00044         {\cf20 // Delete root node, which will delete all children and their children and so on.}\par
00045         {\cf20 // Although this obviously removes the entities from the nodes, because the nodes themselves}\par
00046         {\cf20 // no longer exist, this does NOT delete the entity pointers. They are stored in this object's}\par
00047         {\cf20 // _mmapEntities hashmap.}\par
00048         {\cf19 if} (_mpRootNode)\par
00049         \{\par
00050             {\cf17 delete} _mpRootNode;\par
00051             _mpRootNode = 0;\par
00052         \}\par
00053 \par
00054         {\cf20 // Delete all entities}\par
00055         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.begin();\par
00056         {\cf19 while} (it != _mmapEntities.end())\par
00057         \{\par
00058             {\cf17 delete} it->second;\par
00059             it++;\par
00060         \}\par
00061         _mmapEntities.clear();\par
00062     \}\par
00063 \par
00064     {\cf20 /*}\par
00065 {\cf20     void COctTree::debugRender(CSMCamera& camera) const}\par
00066 {\cf20     \{}\par
00067 {\cf20         // Obtain required resources needed to render the node's as lines.}\par
00068 {\cf20         CResourceVertexBufferLine* pLine = x->pResource->getVertexBufferLine("X:default");}\par
00069 {\cf20         CResourceShader* pShader = x->pResource->getShader("X:VBCPT");}\par
00070 {\cf20         CResourceTexture2DFromFile* pTexture = x->pResource->getTexture2DFromFile("X:default_white");}\par
00071 {\cf20 }\par
00072 {\cf20         CMatrix matrixWorld;}\par
00073 {\cf20 }\par
00074 {\cf20         // Bind shader and set uniforms}\par
00075 {\cf20         pShader->bind();}\par
00076 {\cf20         pShader->setMat4("matrixWorld", matrixWorld);}\par
00077 {\cf20         pShader->setMat4("matrixView", camera.getViewMatrix());}\par
00078 {\cf20         pShader->setMat4("matrixProjection", camera.getProjectionMatrix());}\par
00079 {\cf20 }\par
00080 {\cf20         // Tell OpenGL, for each sampler, to which texture unit it belongs to}\par
00081 {\cf20         pShader->setInt("texture0", 0);}\par
00082 {\cf20 }\par
00083 {\cf20         // And bind the texture...}\par
00084 {\cf20         pTexture->bind();}\par
00085 {\cf20 }\par
00086 {\cf20         // Set the line vertex buffer rendering mode}\par
00087 {\cf20         pLine->setDrawModeAsLineList();}\par
00088 {\cf20         pLine->removeGeom();}\par
00089 {\cf20 }\par
00090 {\cf20         glEnable(GL_BLEND);}\par
00091 {\cf20 //      glDisable(GL_DEPTH_TEST);}\par
00092 {\cf20         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);}\par
00093 {\cf20 }\par
00094 {\cf20         // Call the root node's debugRender method which will render itself and it's children recursively}\par
00095 {\cf20         _mpRootNode->debugRenderNodes(pLine, CColour(1.0f, 1.0f, 1.0f, 1.0f));}\par
00096 {\cf20 }\par
00097 {\cf20         // Send geometry to be rendered}\par
00098 {\cf20         pLine->update();}\par
00099 {\cf20         pLine->render();}\par
00100 {\cf20 }\par
00101 {\cf20         // Cleanup}\par
00102 {\cf20         glDisable(GL_BLEND);}\par
00103 {\cf20 //      glEnable(GL_DEPTH_TEST);}\par
00104 {\cf20         pTexture->unbind();}\par
00105 {\cf20         pShader->unbind();}\par
00106 {\cf20     \}}\par
00107 {\cf20     */}\par
00108 \par
00109     {\cf20 /*}\par
00110 {\cf20     void COctTree::debugSetEntityColour(const std::string& strName, CColour& colour)}\par
00111 {\cf20     \{}\par
00112 {\cf20         // Find the entity}\par
00113 {\cf20         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.find(strName);}\par
00114 {\cf20         ThrowIfTrue(_mmapEntities.end() == it, "COctTree::debugSetEntityColour() failed. The entity name of " + strName + " doesn't exist.");}\par
00115 {\cf20         it->second->_mColDebug = colour;}\par
00116 {\cf20     \}}\par
00117 {\cf20 }\par
00118 {\cf20     void COctTree::debugSetAllEntitiesColour(CColour& colour)}\par
00119 {\cf20     \{}\par
00120 {\cf20         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.begin();}\par
00121 {\cf20         while (it != _mmapEntities.end())}\par
00122 {\cf20         \{}\par
00123 {\cf20             it->second->_mColDebug = colour;}\par
00124 {\cf20             it++;}\par
00125 {\cf20         \}}\par
00126 {\cf20     \}}\par
00127 {\cf20     */}\par
00128     {\cf18 void} COctTree::addEntity({\cf17 const} std::string& strName, {\cf17 const} CVector3f& vPosition, {\cf18 int} iUserData, {\cf18 void}* pUserData)\par
00129     \{\par
00130         {\cf20 // Make sure the entity doesn't already exist by checking the hashmap}\par
00131         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00132         ThrowIfTrue(_mmapEntities.end() != it, {\cf22 "COctTree::addEntity() failed. The entity name of "} + strName + {\cf22 " already exists."});\par
00133 \par
00134         {\cf20 // Create new entity, setting it's owner to 0}\par
00135         COctTreeEntity* pEntity = {\cf17 new} COctTreeEntity(strName, vPosition, 0, iUserData, pUserData);\par
00136         ThrowIfFalse(pEntity, {\cf22 "COctTree::addEntity() failed to allocate memory for new entity."});\par
00137 \par
00138         {\cf20 // Add entity to hashmap for fast lookup}\par
00139         _mmapEntities[strName] = pEntity;\par
00140 \par
00141         {\cf20 // Determine whether the given position of the entity fits in the root node}\par
00142         {\cf19 if} (!_mpRootNode->_mRegion.getPointIsInside(vPosition))\par
00143         \{\par
00144             {\cf20 // The position of the new entity doesn't fit within the root node's area}\par
00145             {\cf20 // We're going to have to recreate the entire tree}\par
00146 \par
00147             {\cf20 // Delete root node, which will delete all children and their children and so on.}\par
00148             {\cf20 // This does not delete the entities (As they're stored in the _mmapEntities hashmap)}\par
00149             {\cf20 // But before deleting the root node, get it's currently set region which we will multiply to get}\par
00150             {\cf20 // the root node's new dimensions}\par
00151             CAABB aabbOldRootNodeRegion = _mpRootNode->_mRegion;\par
00152             {\cf17 delete} _mpRootNode;\par
00153 \par
00154             {\cf20 // Inscrease the old root node's region size until the new entity's position fits within}\par
00155             {\cf18 bool} bNewPositionFits = {\cf17 false};\par
00156             {\cf19 while} (!bNewPositionFits)\par
00157             \{\par
00158                 aabbOldRootNodeRegion.resizeArea(_mfSizeIncreaseMultiplier);\par
00159                 bNewPositionFits = aabbOldRootNodeRegion.getPointIsInside(vPosition);\par
00160             \}\par
00161 \par
00162             {\cf20 // Now re-create the root node, passing 0 as the pointer to the parent node and the new region size}\par
00163             _mpRootNode = {\cf17 new} COctTreeNode(aabbOldRootNodeRegion, 0, {\cf17 this});\par
00164             ThrowIfFalse(_mpRootNode, {\cf22 "COctTree::addEntity() failed. Unable to allocate memory for new root node."});\par
00165 \par
00166             {\cf20 // Now re-insert all entities stored in the hash map back into the tree}\par
00167             {\cf20 // The new entity has already been added to the hash map, so no need to insert it seperately}\par
00168             it = _mmapEntities.begin();\par
00169             {\cf19 while} (it != _mmapEntities.end())\par
00170             \{\par
00171                 _mpRootNode->addEntity(it->second);\par
00172                 it++;\par
00173             \}\par
00174         \}\par
00175         {\cf19 else}  {\cf20 // The entity position does fit inside the area of this node, simply add it}\par
00176         \{\par
00177             _mpRootNode->addEntity(pEntity);\par
00178         \}\par
00179     \}\par
00180 \par
00181     {\cf18 void} COctTree::removeEntity({\cf17 const} std::string& strName)\par
00182     \{\par
00183         {\cf20 // Make sure the entity exists by checking the hashmap}\par
00184         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00185         ThrowIfTrue(_mmapEntities.end() == it, {\cf22 "COctTree::removeEntity() failed. The entity name of "} + strName + {\cf22 " doesn't exist."});\par
00186 \par
00187         {\cf20 // Get the node the entity is stored in to remove the entity from itself.}\par
00188         COctTreeNode* pNodeContainingRemovedEntity = it->second->_mpNodeOwner;\par
00189         pNodeContainingRemovedEntity->removeEntity(it->second);\par
00190 \par
00191         {\cf20 // Remove the entity from the hashmap and delete it}\par
00192         COctTreeEntity* pEntity = it->second;\par
00193         _mmapEntities.erase(it);\par
00194         {\cf17 delete} pEntity;\par
00195 \par
00196         {\cf20 // Now check to see if the node is now empty and if so, remove it}\par
00197         {\cf19 if} (!pNodeContainingRemovedEntity->hasEntitiesInThisAndAllChildren())\par
00198         \{\par
00199             {\cf20 // Is the node which held the removed entity, the root node}\par
00200             {\cf18 bool} bNodeIsRoot = _mpRootNode == pNodeContainingRemovedEntity;\par
00201 \par
00202             {\cf19 if} (!bNodeIsRoot)  {\cf20 // The node wasn't the root node and therefore pNodeParent will contain a valid pointer to it's parent node.}\par
00203             \{\par
00204                 {\cf20 // Store pointer to the parent}\par
00205                 COctTreeNode* pNodeParent = pNodeContainingRemovedEntity->_mpParentNode;\par
00206 \par
00207                 {\cf20 // We're done, except...}\par
00208                 {\cf20 // We need to traverse up to the root node and delete any NOW empty nodes, which may }\par
00209                 {\cf20 // have only existed to hold the now deleted node.}\par
00210                 {\cf20 // We also have to remove any parent node's _mpChildNode[8] pointers if we delete a node.}\par
00211                 {\cf19 while} (pNodeParent)\par
00212                 \{\par
00213                     {\cf20 // Go through each of the eight possible child nodes of the parent}\par
00214                     {\cf19 for} ({\cf18 int} i = 0; i < 8; i++)\par
00215                     \{\par
00216                         {\cf19 if} (pNodeParent->_mpChildNode[i])   {\cf20 // There is a child at this array position}\par
00217                         \{\par
00218                             {\cf19 if} (!pNodeParent->_mpChildNode[i]->hasEntitiesInThisAndAllChildren())   {\cf20 // Node is empty}\par
00219                             \{\par
00220                                 {\cf17 delete} pNodeParent->_mpChildNode[i];\par
00221                                 pNodeParent->_mpChildNode[i] = 0;\par
00222                             \}\par
00223                         \}\par
00224                     \}\par
00225                     pNodeParent = pNodeParent->_mpParentNode;\par
00226                 \}\par
00227 \par
00228                 {\cf20 // This will delete the node and all it's children.}\par
00229                 {\cf20 // No need to delete, as it's deleted above when deleting children.}\par
00230                 {\cf20 // If we attempted to delete again, all hell breaks loose!}\par
00231 {\cf20 //              delete pNodeContainingRemovedEntity;}\par
00232             \}\par
00233         \}\par
00234         {\cf20 // The node which contained the entity has other entities, leave it alone.}\par
00235     \}\par
00236 \par
00237     {\cf18 bool} COctTree::getEntityExists({\cf17 const} std::string& strName){\cf17  const}\par
00238 {\cf17     }\{\par
00239         {\cf20 // Check the hashmap}\par
00240         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00241         {\cf19 return}(_mmapEntities.end() != it);\par
00242     \}\par
00243 \par
00244     {\cf18 void} COctTree::removeAllEntities({\cf18 bool} bResetTree)\par
00245     \{\par
00246         {\cf20 // Go through each entity, asking each node which it's in to remove itself}\par
00247         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.begin();\par
00248         {\cf19 while} (it != _mmapEntities.end())\par
00249         \{\par
00250             {\cf20 // Get the node the entity is stored in to remove the entity from itself.}\par
00251             it->second->_mpNodeOwner->removeEntity(it->second);\par
00252 \par
00253             {\cf20 // Remove the entity from the hashmap and delete it}\par
00254             COctTreeEntity* pEntity = it->second;\par
00255             _mmapEntities.erase(it);\par
00256             {\cf17 delete} pEntity;\par
00257             it = _mmapEntities.begin();\par
00258         \}\par
00259 \par
00260         {\cf20 // Now all entities are removed and deleted, reset the tree if bResetTree desires it}\par
00261         {\cf19 if} (bResetTree)\par
00262         \{\par
00263             {\cf20 // Get the root node's AABB, so we can re-create it}\par
00264             CAABB aabbRootNode = _mpRootNode->_mRegion;\par
00265             {\cf17 delete} _mpRootNode;\par
00266             _mpRootNode = {\cf17 new} COctTreeNode(aabbRootNode, 0, {\cf17 this});\par
00267 \par
00268             {\cf20 // Reset current max node depth}\par
00269             _muiCurrentMaxNodeDepth = 0;\par
00270 \par
00271             {\cf20 // Compute new maximum node depth}\par
00272             _computeMaxNodeDepth();\par
00273         \}\par
00274     \}\par
00275 \par
00276     {\cf18 void} COctTree::setEntityPosition({\cf17 const} std::string& strName, {\cf17 const} CVector3f& vNewPosition)\par
00277     \{\par
00278         {\cf20 // First make sure the named entity exists}\par
00279         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00280         ThrowIfTrue(it == _mmapEntities.end(), {\cf22 "COctTree::setEntityPosition() failed. The named entity of "} + strName + {\cf22 " doesn't exist."});\par
00281 \par
00282         {\cf20 // First check to see if the new entity position still fits within it's current node}\par
00283         {\cf20 // If it does, we simply update the position}\par
00284         {\cf19 if} (it->second->_mpNodeOwner->_mRegion.getPointIsInside(vNewPosition))\par
00285         \{\par
00286             it->second->_mvPosition = vNewPosition;\par
00287             {\cf19 return};\par
00288         \}\par
00289 \par
00290         {\cf20 // If we get here, the new position doesn't fit within the entity's current node}\par
00291 \par
00292         {\cf20 // Remove the entity from the tree and then re-insert it}\par
00293         {\cf18 int} iUserData = it->second->miUserData;\par
00294         {\cf18 void}* pUserData = it->second->mpUserData;\par
00295         removeEntity(strName);\par
00296         addEntity(strName, vNewPosition, iUserData, pUserData);\par
00297     \}\par
00298 \par
00299     {\cf18 void} COctTree::getEntityPosition({\cf17 const} std::string& strName, CVector3f& vPosition){\cf17  const}\par
00300 {\cf17     }\{\par
00301         {\cf20 // First make sure the named entity exists}\par
00302         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00303         ThrowIfTrue(it == _mmapEntities.end(), {\cf22 "COctTree::getEntityPosition() failed. The named entity of "} + strName + {\cf22 " doesn't exist."});\par
00304         vPosition = it->second->_mvPosition;\par
00305     \}\par
00306 \par
00307     {\cf18 void} COctTree::_computeMaxNodeDepth({\cf18 void})\par
00308     \{\par
00309         {\cf20 // Obtain smallest dimension of root node}\par
00310         CVector3f vRootNodeDims = _mpRootNode->_mRegion.getDimensions();\par
00311         {\cf18 float} fSmallestDim = vRootNodeDims.x;\par
00312         {\cf19 if} (vRootNodeDims.y < fSmallestDim)\par
00313             fSmallestDim = vRootNodeDims.y;\par
00314         {\cf19 if} (vRootNodeDims.z < fSmallestDim)\par
00315             fSmallestDim = vRootNodeDims.z;\par
00316 \par
00317         {\cf20 // Now compute max node depth}\par
00318         _muiMaxNodeDepth = 0;\par
00319         {\cf19 while} (fSmallestDim > 2)\par
00320         \{\par
00321             fSmallestDim *= 0.5f;\par
00322             _muiMaxNodeDepth++;\par
00323         \}\par
00324     \}\par
00325 \par
00326     std::vector<COctTreeNode*> COctTree::getNodesWithEntities({\cf18 void}){\cf17  const}\par
00327 {\cf17     }\{\par
00328         std::vector<COctTreeNode*> vResult;\par
00329         _mpRootNode->getNodesWithEntities(vResult);\par
00330         {\cf19 return} vResult;\par
00331     \}\par
00332 \par
00333     std::vector<COctTreeNode*> COctTree::getNodesWithEntitiesWhichIntersect({\cf17 const} CAABB& aabb){\cf17  const}\par
00334 {\cf17     }\{\par
00335         std::vector<COctTreeNode*> vResult;\par
00336         _mpRootNode->getNodesWithEntitiesWhichIntersect(vResult, aabb);\par
00337         {\cf19 return} vResult;\par
00338     \}\par
00339 \par
00340     std::vector<COctTreeNode*> COctTree::getNodesWithEntitiesWhichIntersect({\cf17 const} CFrustum& frustum){\cf17  const}\par
00341 {\cf17     }\{\par
00342         std::vector<COctTreeNode*> vResult;\par
00343         _mpRootNode->getNodesWithEntitiesWhichIntersect(vResult, frustum);\par
00344         {\cf19 return} vResult;\par
00345     \}\par
00346 \par
00347     std::vector<COctTreeEntity*> COctTree::getEntitiesWithinRange({\cf17 const} CVector3f& vPosition, {\cf18 float} fRange){\cf17  const}\par
00348 {\cf17     }\{\par
00349         {\cf20 // Create an AABB which covers the maximum range from the given position}\par
00350         CAABB aabb;\par
00351         {\cf18 float} fRangeTimesTwo = fRange * 2.0f;\par
00352         aabb.setPosDims(vPosition, CVector3f(fRangeTimesTwo, fRangeTimesTwo, fRangeTimesTwo));\par
00353 \par
00354         {\cf20 // Go through the nodes and get a vector of nodes which intersect the AABB and have entities in them}\par
00355         std::vector<COctTreeNode*> vNodes = getNodesWithEntitiesWhichIntersect(aabb);\par
00356         std::vector<COctTreeEntity*> vResult;\par
00357         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vNodes.size(); ui++)\par
00358         \{\par
00359             {\cf20 // Go through each entity within each node and add them to the resulting vector}\par
00360             std::map<std::string, COctTreeEntity*>::iterator it = vNodes[ui]->_mmapEntities.begin();\par
00361             {\cf19 while} (it != vNodes[ui]->_mmapEntities.end())\par
00362             \{\par
00363                 vResult.push_back(it->second);\par
00364                 it++;\par
00365             \}\par
00366         \}\par
00367         {\cf19 return} vResult;\par
00368     \}\par
00369 \par
00370     std::vector<COctTreeEntity*> COctTree::getEntitiesWithinAABB({\cf17 const} CAABB& aabb){\cf17  const}\par
00371 {\cf17     }\{\par
00372         {\cf20 // Go through the nodes and get a vector of the nodes which intersect the AABB and have entities in them}\par
00373         std::vector<COctTreeNode*> vNodes = getNodesWithEntitiesWhichIntersect(aabb);\par
00374         std::vector<COctTreeEntity*> vResult;\par
00375         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vNodes.size(); ui++)\par
00376         \{\par
00377             {\cf20 // Go through each entity within each node and add them to the resulting vector}\par
00378             std::map<std::string, COctTreeEntity*>::iterator it = vNodes[ui]->_mmapEntities.begin();\par
00379             {\cf19 while} (it != vNodes[ui]->_mmapEntities.end())\par
00380             \{\par
00381                 vResult.push_back(it->second);\par
00382                 it++;\par
00383             \}\par
00384         \}\par
00385         {\cf19 return} vResult;\par
00386     \}\par
00387 \par
00388     std::vector<COctTreeEntity*> COctTree::getEntitiesWithinFrustum({\cf17 const} CFrustum& frustum){\cf17  const}\par
00389 {\cf17     }\{\par
00390         {\cf20 // Go through the nodes and get a vector of the nodes which intersect the frustum and have entities in them}\par
00391         std::vector<COctTreeNode*> vNodes = getNodesWithEntitiesWhichIntersect(frustum);\par
00392         std::vector<COctTreeEntity*> vResult;\par
00393         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vNodes.size(); ui++)\par
00394         \{\par
00395             {\cf20 // Go through each entity within each node and add them to the resulting vector}\par
00396             std::map<std::string, COctTreeEntity*>::iterator it = vNodes[ui]->_mmapEntities.begin();\par
00397             {\cf19 while} (it != vNodes[ui]->_mmapEntities.end())\par
00398             \{\par
00399                 vResult.push_back(it->second);\par
00400                 it++;\par
00401             \}\par
00402         \}\par
00403         {\cf19 return} vResult;\par
00404     \}\par
00405 \par
00406     {\cf18 unsigned} {\cf18 int} COctTree::getNodeDepthCurrent({\cf18 void})\par
00407     \{\par
00408         {\cf20 // We have to recompute this, so go through all nodes, get their depth and compare}\par
00409         _muiCurrentMaxNodeDepth = 0;\par
00410         _mpRootNode->getMaxNodeDepth(_muiCurrentMaxNodeDepth);\par
00411         {\cf19 return} _muiCurrentMaxNodeDepth;\par
00412     \}\par
00413 \par
00414     {\cf18 unsigned} {\cf18 int} COctTree::getNodeDepthMax({\cf18 void}){\cf17  const}\par
00415 {\cf17     }\{\par
00416         {\cf19 return} _muiMaxNodeDepth;\par
00417     \}\par
00418 \par
00419 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTree.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTree.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTree.h}
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D space partitioning }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "OctTreeNode.h"}\par
{\f2 #include "../Math/Frustum.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::COctTree}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D spatial partitioning class. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D space partitioning \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b OctTree.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OctTree.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTree.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTree.h}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef OCTTREE_H}\par
00007 {\cf21 #define OCTTREE_H}\par
00008 \par
00009 {\cf21 #include "OctTreeNode.h"}\par
00010 {\cf20 //#include "SMCamera.h"}\par
00011 {\cf21 #include "../Math/Frustum.h"}\par
00012 \par
00013 {\cf17 namespace }DCL\par
00014 \{\par
00044     {\cf17 class }COctTree\par
00045     \{\par
00046         {\cf17 friend} {\cf17 class }COctTreeNode;\par
00047         {\cf17 friend} {\cf17 class }COctTreeEntity;\par
00048     {\cf17 public}:\par
00061         COctTree({\cf18 int} iMaxEntitiesPerNode = 10, {\cf18 float} fSizeIncreaseMultiplier = 2.0f);\par
00062 \par
00066         ~COctTree();\par
00067 \par
00082         {\cf18 void} init({\cf18 int} iMaxEntitiesPerNode = 10, {\cf18 float} fSizeIncreaseMultiplier = 2.0f);\par
00083 \par
00085         {\cf18 void} free({\cf18 void});\par
00086 \par
00087         {\cf20 /*}\par
00088 {\cf20         // Debug rendering of the oct tree's nodes}\par
00089 {\cf20         void debugRender(CSMCamera& camera) const;}\par
00090 {\cf20         }\par
00091 {\cf20         // For debug rendering, sets the named entity's rendered colour}\par
00092 {\cf20         // If the named entity doesn't exist, an exception occurs.}\par
00093 {\cf20         void debugSetEntityColour(const std::string& strName, CColour& colour);}\par
00094 {\cf20 }\par
00095 {\cf20         // For debug rendering, sets all entities' rendered colour to the one given}\par
00096 {\cf20         void debugSetAllEntitiesColour(CColour& colour);}\par
00097 {\cf20         */}\par
00098 \par
00108         {\cf18 void} addEntity({\cf17 const} std::string& strName, {\cf17 const} CVector3f& vPosition, {\cf18 int} iUserData = 0, {\cf18 void}* pUserData = 0);\par
00109 \par
00114         {\cf18 void} removeEntity({\cf17 const} std::string& strName);\par
00115 \par
00120         {\cf18 bool} getEntityExists({\cf17 const} std::string& strName) {\cf17 const};\par
00121 \par
00125         {\cf18 void} removeAllEntities({\cf18 bool} bResetTree = {\cf17 false});\par
00126 \par
00131         {\cf18 void} setEntityPosition({\cf17 const} std::string& strName, {\cf17 const} CVector3f& vNewPosition);\par
00132 \par
00137         {\cf18 void} getEntityPosition({\cf17 const} std::string& strName, CVector3f &vPosition) {\cf17 const};\par
00138 \par
00142         std::vector<COctTreeNode*> getNodesWithEntities({\cf18 void}) {\cf17 const};\par
00143 \par
00148         std::vector<COctTreeNode*> getNodesWithEntitiesWhichIntersect({\cf17 const} CAABB& aabb) {\cf17 const};\par
00149 \par
00154         std::vector<COctTreeNode*> getNodesWithEntitiesWhichIntersect({\cf17 const} CFrustum& frustum) {\cf17 const};\par
00155 \par
00164         std::vector<COctTreeEntity*> getEntitiesWithinRange({\cf17 const} CVector3f& vPosition, {\cf18 float} fRange) {\cf17 const};\par
00165 \par
00173         std::vector<COctTreeEntity*> getEntitiesWithinAABB({\cf17 const} CAABB& aabb) {\cf17 const};\par
00174 \par
00180         std::vector<COctTreeEntity*> getEntitiesWithinFrustum({\cf17 const} CFrustum& frustum) {\cf17 const};\par
00181 \par
00192         {\cf18 unsigned} {\cf18 int} getNodeDepthCurrent({\cf18 void});\par
00193 \par
00205         {\cf18 unsigned} {\cf18 int} getNodeDepthMax({\cf18 void}) {\cf17 const};\par
00206 \par
00207     {\cf17 private}:\par
00208         COctTreeNode* _mpRootNode;      \par
00209 \par
00213         {\cf18 int} _miMaxEntitiesPerNode;\par
00214 \par
00220         {\cf18 float} _mfSizeIncreaseMultiplier;\par
00221 \par
00225         {\cf17 mutable} std::map<std::string, COctTreeEntity*> _mmapEntities;\par
00226 \par
00235         {\cf18 unsigned} {\cf18 int} _muiCurrentMaxNodeDepth;\par
00236 \par
00246         {\cf18 unsigned} {\cf18 int} _muiMaxNodeDepth;\par
00247 \par
00249         {\cf18 void} _computeMaxNodeDepth({\cf18 void});\par
00250     \};\par
00251 \par
00252 \}   {\cf20 // namespace DCL}\par
00253 \par
00254 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OctTreeEntity.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeEntity.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeEntity.cpp}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "OctTreeEntity.h"}\par
00002 {\cf21 #include "OctTreeNode.h"}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     COctTreeEntity::COctTreeEntity({\cf17 const} std::string& strName, {\cf17 const} CVector3f& vPosition, COctTreeNode* pNodeOwner, {\cf18 int} iUserData, {\cf18 void}* pUserData)\par
00007     \{\par
00008         _mstrName = strName;\par
00009         _mvPosition = vPosition;\par
00010         _mpNodeOwner = pNodeOwner;\par
00011 \par
00012         {\cf20 // Store user data}\par
00013         miUserData = iUserData;\par
00014         mpUserData = pUserData;\par
00015     \}\par
00016 \par
00017     {\cf20 /*}\par
00018 {\cf20     void COctTreeEntity::debugSetColour(CColour& colour)}\par
00019 {\cf20     \{}\par
00020 {\cf20         _mColDebug = colour;}\par
00021 {\cf20     \}}\par
00022 {\cf20     */}\par
00023 \par
00024     CVector3f COctTreeEntity::getPosition({\cf18 void})\par
00025     \{\par
00026         {\cf19 return} _mvPosition;;\par
00027     \}\par
00028 \par
00029     std::string COctTreeEntity::getName({\cf18 void})\par
00030     \{\par
00031         {\cf19 return} _mstrName;\par
00032     \}\par
00033 \par
00034 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeEntity.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeEntity.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeEntity.h}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../Math/Vector3f.h"}\par
{\f2 #include "../Core/Colourf.h"}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::COctTreeEntity}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into an {\b COctTreeNode}. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b OctTreeEntity.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OctTreeEntity.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeEntity.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeEntity.h}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef OCTTREEENTITY_H}\par
00007 {\cf21 #define OCTTREEENTITY_H}\par
00008 \par
00009 {\cf21 #include "../Math/Vector3f.h"}\par
00010 {\cf21 #include "../Core/Colourf.h"}\par
00011 \par
00012 {\cf21 #include <string>}\par
00013 \par
00014 {\cf17 namespace }DCL\par
00015 \{\par
00016     {\cf17 class }COctTreeNode;\par
00017 \par
00021     {\cf17 class }COctTreeEntity\par
00022     \{\par
00023         {\cf17 friend} {\cf17 class }COctTree;\par
00024         {\cf17 friend} {\cf17 class }COctTreeNode;\par
00025     {\cf17 public}:\par
00033         COctTreeEntity({\cf17 const} std::string& strName, {\cf17 const} CVector3f& vPosition, COctTreeNode* pNodeOwner, {\cf18 int} iUserData = 0, {\cf18 void}* pUserData = 0);\par
00034 \par
00036 {\cf20 //      void debugSetColour(CColour& colour);}\par
00037 \par
00041         CVector3f getPosition({\cf18 void});\par
00042 \par
00046         std::string getName({\cf18 void});\par
00047 \par
00048         {\cf20 // Below are members which may be set to store various information.}\par
00049         {\cf20 // They have nothing to do with the oct tree itself.}\par
00050         {\cf18 int} miUserData;         \par
00051         {\cf18 void}* mpUserData;       \par
00052 \par
00053     {\cf17 private}:\par
00054         std::string _mstrName;          \par
00055         CVector3f _mvPosition;          \par
00056         COctTreeNode* _mpNodeOwner;     \par
00057 {\cf20 //      CColour _mColDebug;             ///< The colour used when debug rendering this entity}\par
00058     \};\par
00059 \par
00060 \}   {\cf20 // namespace DCL}\par
00061 \par
00062 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OctTreeNode.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeNode.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeNode.cpp}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "OctTreeNode.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 {\cf21 #include "OctTree.h"}\par
00004 \par
00005 {\cf17 namespace }DCL\par
00006 \{\par
00007     COctTreeNode::COctTreeNode({\cf17 const} CAABB& region, COctTreeNode* pParentNode, COctTree* pOctTree)\par
00008     \{\par
00009         _mRegion = region;\par
00010         _mpParentNode = pParentNode;\par
00011         _mpOctTree = pOctTree;\par
00012         {\cf20 // Is this the root node?}\par
00013         {\cf19 if} (!pParentNode)\par
00014             _muiNodeDepth = 0;\par
00015         {\cf19 else}\par
00016             _muiNodeDepth = pParentNode->_muiNodeDepth + 1;\par
00017 \par
00018         {\cf19 if} (_muiNodeDepth > pOctTree->_muiCurrentMaxNodeDepth)\par
00019             pOctTree->_muiCurrentMaxNodeDepth = _muiNodeDepth;\par
00020 \par
00021         {\cf20 // No children yet}\par
00022         {\cf19 for} ({\cf18 int} i = 0; i < 8; i++)\par
00023             _mpChildNode[i] = 0;\par
00024     \}\par
00025 \par
00026     COctTreeNode::~COctTreeNode()\par
00027     \{\par
00028         {\cf20 // Destroy each child node}\par
00029         {\cf20 // This will recursively call each child node's destructor}\par
00030         {\cf19 for} ({\cf18 int} i = 0; i < 8; i++)\par
00031         \{\par
00032             {\cf20 // If child node exists}\par
00033             {\cf19 if} (_mpChildNode[i])\par
00034                 {\cf17 delete} _mpChildNode[i];\par
00035         \}\par
00036     \}\par
00037 \par
00038     {\cf20 /*}\par
00039 {\cf20     void COctTreeNode::debugRenderNodes(CResourceVertexBufferLine* pLine, CColour colour) const}\par
00040 {\cf20     \{}\par
00041 {\cf20         // Compute colour}\par
00042 {\cf20         float fDepthCol = (float)_mpOctTree->_muiMaxNodeDepth - float(_muiNodeDepth);}\par
00043 {\cf20         fDepthCol /= (float)_mpOctTree->_muiMaxNodeDepth;}\par
00044 {\cf20         clamp(fDepthCol, 0.75f, 1.0f);}\par
00045 {\cf20 }\par
00046 {\cf20         // Compute vertex positions for the AABB}\par
00047 {\cf20         CResourceVertexBufferLine::Vertex v[8];}\par
00048 {\cf20         for (int i = 0; i < 8; i++)}\par
00049 {\cf20         \{}\par
00050 {\cf20             v[i].colour.red = colour.red;}\par
00051 {\cf20             v[i].colour.green = colour.green;}\par
00052 {\cf20             v[i].colour.blue = colour.blue;}\par
00053 {\cf20             v[i].colour.alpha = fDepthCol;}\par
00054 {\cf20         \}}\par
00055 {\cf20         v[ChildNode::NEGX_NEGY_NEGZ].position = _mRegion.getMin();}\par
00056 {\cf20         v[ChildNode::POSX_POSY_POSZ].position = _mRegion.getMax();}\par
00057 {\cf20         v[ChildNode::NEGX_NEGY_POSZ].position.set(v[ChildNode::NEGX_NEGY_NEGZ].position.x, v[ChildNode::NEGX_NEGY_NEGZ].position.y, v[ChildNode::POSX_POSY_POSZ].position.z);}\par
00058 {\cf20         v[ChildNode::NEGX_POSY_NEGZ].position.set(v[ChildNode::NEGX_NEGY_NEGZ].position.x, v[ChildNode::POSX_POSY_POSZ].position.y, v[ChildNode::NEGX_NEGY_NEGZ].position.z);}\par
00059 {\cf20         v[ChildNode::NEGX_POSY_POSZ].position.set(v[ChildNode::NEGX_NEGY_NEGZ].position.x, v[ChildNode::POSX_POSY_POSZ].position.y, v[ChildNode::POSX_POSY_POSZ].position.z);}\par
00060 {\cf20         v[ChildNode::POSX_NEGY_NEGZ].position.set(v[ChildNode::POSX_POSY_POSZ].position.x, v[ChildNode::NEGX_NEGY_NEGZ].position.y, v[ChildNode::NEGX_NEGY_NEGZ].position.z);}\par
00061 {\cf20         v[ChildNode::POSX_NEGY_POSZ].position.set(v[ChildNode::POSX_POSY_POSZ].position.x, v[ChildNode::NEGX_NEGY_NEGZ].position.y, v[ChildNode::POSX_POSY_POSZ].position.z);}\par
00062 {\cf20         v[ChildNode::POSX_POSY_NEGZ].position.set(v[ChildNode::POSX_POSY_POSZ].position.x, v[ChildNode::POSX_POSY_POSZ].position.y, v[ChildNode::NEGX_NEGY_NEGZ].position.z);}\par
00063 {\cf20 }\par
00064 {\cf20         // Render this node's twelve edges}\par
00065 {\cf20         pLine->addLinePoint(v[NEGX_NEGY_NEGZ]); pLine->addLinePoint(v[POSX_NEGY_NEGZ]);     // Back, bottom, left to right}\par
00066 {\cf20         pLine->addLinePoint(v[NEGX_POSY_NEGZ]); pLine->addLinePoint(v[POSX_POSY_NEGZ]);     // Back, top, left to right}\par
00067 {\cf20         pLine->addLinePoint(v[NEGX_NEGY_POSZ]); pLine->addLinePoint(v[POSX_NEGY_POSZ]);     // Front, bottom, left to right}\par
00068 {\cf20         pLine->addLinePoint(v[NEGX_POSY_POSZ]); pLine->addLinePoint(v[POSX_POSY_POSZ]);     // Front, top, left to right}\par
00069 {\cf20         pLine->addLinePoint(v[NEGX_POSY_NEGZ]); pLine->addLinePoint(v[NEGX_NEGY_NEGZ]);     // Back, left, top to bottom}\par
00070 {\cf20         pLine->addLinePoint(v[POSX_POSY_NEGZ]); pLine->addLinePoint(v[POSX_NEGY_NEGZ]);     // Back, right, top to bottom}\par
00071 {\cf20         pLine->addLinePoint(v[NEGX_POSY_POSZ]); pLine->addLinePoint(v[NEGX_NEGY_POSZ]);     // Front, left, top to bottom}\par
00072 {\cf20         pLine->addLinePoint(v[POSX_POSY_POSZ]); pLine->addLinePoint(v[POSX_NEGY_POSZ]);     // Front, right, top to bottom}\par
00073 {\cf20         pLine->addLinePoint(v[NEGX_POSY_POSZ]); pLine->addLinePoint(v[NEGX_POSY_NEGZ]);     // Top, left, front to back}\par
00074 {\cf20         pLine->addLinePoint(v[POSX_POSY_POSZ]); pLine->addLinePoint(v[POSX_POSY_NEGZ]);     // Top, right, front to back}\par
00075 {\cf20         pLine->addLinePoint(v[NEGX_NEGY_POSZ]); pLine->addLinePoint(v[NEGX_NEGY_NEGZ]);     // Bottom, left, front to back}\par
00076 {\cf20         pLine->addLinePoint(v[POSX_NEGY_POSZ]); pLine->addLinePoint(v[POSX_NEGY_NEGZ]);     // Bottom, right, front to back}\par
00077 {\cf20 }\par
00078 {\cf20         // Render child nodes if they exist}\par
00079 {\cf20         for (int i = 0; i < 8; i++)}\par
00080 {\cf20         \{}\par
00081 {\cf20             if (_mpChildNode[i])}\par
00082 {\cf20                 _mpChildNode[i]->debugRenderNodes(pLine, colour);}\par
00083 {\cf20         \}}\par
00084 {\cf20     \}}\par
00085 {\cf20     */}\par
00086 \par
00087     {\cf20 /*}\par
00088 {\cf20     void COctTreeNode::debugRenderEntities(CResourceLine* pLine, int iCircleRadius, unsigned int uiCircleNumSegments) const}\par
00089 {\cf20     \{}\par
00090 {\cf20         // For each entity in this node}\par
00091 {\cf20         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.begin();}\par
00092 {\cf20         while (it != _mmapEntities.end())}\par
00093 {\cf20         \{}\par
00094 {\cf20             pLine->addCircle(it->second->_miPosX, it->second->_miPosY, (float)iCircleRadius, uiCircleNumSegments, it->second->_mColDebug);}\par
00095 {\cf20             it++;}\par
00096 {\cf20         \}}\par
00097 {\cf20 }\par
00098 {\cf20         // Render child nodes if they exist}\par
00099 {\cf20         for (int i = 0; i < 4; i++)}\par
00100 {\cf20         \{}\par
00101 {\cf20             if (_mpChildNode[i])}\par
00102 {\cf20                 _mpChildNode[i]->debugRenderEntities(pLine, iCircleRadius, uiCircleNumSegments);}\par
00103 {\cf20         \}}\par
00104 {\cf20     \}}\par
00105 {\cf20     */}\par
00106 \par
00107     {\cf18 bool} COctTreeNode::hasChildNode(ChildNode childNode){\cf17  const}\par
00108 {\cf17     }\{\par
00109         {\cf19 return} _mpChildNode[childNode];\par
00110     \}\par
00111 \par
00112     {\cf18 bool} COctTreeNode::hasAnyChildNodes({\cf18 void}){\cf17  const}\par
00113 {\cf17     }\{\par
00114         {\cf19 for} ({\cf18 int} i = 0; i < 8; i++)\par
00115         \{\par
00116             {\cf19 if} (_mpChildNode[i])\par
00117                 {\cf19 return} {\cf17 true};\par
00118         \}\par
00119         {\cf19 return} {\cf17 false};\par
00120     \}\par
00121 \par
00122     {\cf18 bool} COctTreeNode::hasEntitiesInThisAndAllChildren({\cf18 void}){\cf17  const}\par
00123 {\cf17     }\{\par
00124         {\cf20 // If this node has entities in}\par
00125         {\cf19 if} (_mmapEntities.size() > 0)\par
00126             {\cf19 return} {\cf17 true};\par
00127 \par
00128         {\cf20 // Now recursively go through any existing child nodes}\par
00129         {\cf19 for} ({\cf18 int} i = 0; i < 8; i++)\par
00130         \{\par
00131             {\cf20 // If node exists}\par
00132             {\cf19 if} (_mpChildNode[i])\par
00133             \{\par
00134                 {\cf19 if} (_mpChildNode[i]->hasEntitiesInThisAndAllChildren())\par
00135                     {\cf19 return} {\cf17 true};\par
00136             \}\par
00137         \}\par
00138 \par
00139         {\cf20 // If we get here, this node has no entities and neither does any of it's children nodes}\par
00140         {\cf19 return} {\cf17 false};\par
00141     \}\par
00142 \par
00143     {\cf18 void} COctTreeNode::createChildNode(ChildNode childNode)\par
00144     \{\par
00145         {\cf19 if} (hasChildNode(childNode))\par
00146             {\cf19 return};\par
00147 \par
00148         {\cf20 // Compute region of the new child node}\par
00149         CAABB childNodeRegion = computeChildNodeRegion(childNode);\par
00150 \par
00151         _mpChildNode[childNode] = {\cf17 new} COctTreeNode(childNodeRegion, {\cf17 this}, _mpOctTree);\par
00152         ThrowIfFalse(_mpChildNode[childNode], {\cf22 "COctTreeNode::createChildNode() failed. Unable to allocate memory for the new child node."});\par
00153     \}\par
00154 \par
00155     CAABB COctTreeNode::computeChildNodeRegion(ChildNode childNode){\cf17  const}\par
00156 {\cf17     }\{\par
00157         {\cf20 // Compute dimensions of new child node using the region of this parent node.}\par
00158         CVector3f vChildDims = _mRegion.getHalfDimensions();\par
00159         CVector3f vParentPosition = _mRegion.getPosition();\par
00160         CVector3f vHalfChildDims = vChildDims * 0.5f;\par
00161 \par
00162         {\cf20 // Calculate region of the child node}\par
00163         CAABB childNodeRegion;\par
00164         CVector3f vChildPosition = vParentPosition;\par
00165         {\cf19 switch} (childNode)\par
00166         \{\par
00167         {\cf19 case} ChildNode::NEGX_NEGY_NEGZ:\par
00168             vChildPosition.x -= vHalfChildDims.x;\par
00169             vChildPosition.y -= vHalfChildDims.y;\par
00170             vChildPosition.z -= vHalfChildDims.z;\par
00171             childNodeRegion.setPosDims(vChildPosition, vChildDims);\par
00172             {\cf19 break};\par
00173         {\cf19 case} ChildNode::NEGX_POSY_NEGZ:\par
00174             vChildPosition.x -= vHalfChildDims.x;\par
00175             vChildPosition.y += vHalfChildDims.y;\par
00176             vChildPosition.z -= vHalfChildDims.z;\par
00177             childNodeRegion.setPosDims(vChildPosition, vChildDims);\par
00178             {\cf19 break};\par
00179         {\cf19 case} ChildNode::NEGX_NEGY_POSZ:\par
00180             vChildPosition.x -= vHalfChildDims.x;\par
00181             vChildPosition.y -= vHalfChildDims.y;\par
00182             vChildPosition.z += vHalfChildDims.z;\par
00183             childNodeRegion.setPosDims(vChildPosition, vChildDims);\par
00184             {\cf19 break};\par
00185         {\cf19 case} ChildNode::NEGX_POSY_POSZ:\par
00186             vChildPosition.x -= vHalfChildDims.x;\par
00187             vChildPosition.y += vHalfChildDims.y;\par
00188             vChildPosition.z += vHalfChildDims.z;\par
00189             childNodeRegion.setPosDims(vChildPosition, vChildDims);\par
00190             {\cf19 break};\par
00191         {\cf19 case} ChildNode::POSX_NEGY_NEGZ:\par
00192             vChildPosition.x += vHalfChildDims.x;\par
00193             vChildPosition.y -= vHalfChildDims.y;\par
00194             vChildPosition.z -= vHalfChildDims.z;\par
00195             childNodeRegion.setPosDims(vChildPosition, vChildDims);\par
00196             {\cf19 break};\par
00197         {\cf19 case} ChildNode::POSX_POSY_NEGZ:\par
00198             vChildPosition.x += vHalfChildDims.x;\par
00199             vChildPosition.y += vHalfChildDims.y;\par
00200             vChildPosition.z -= vHalfChildDims.z;\par
00201             childNodeRegion.setPosDims(vChildPosition, vChildDims);\par
00202             {\cf19 break};\par
00203         {\cf19 case} ChildNode::POSX_NEGY_POSZ:\par
00204             vChildPosition.x += vHalfChildDims.x;\par
00205             vChildPosition.y -= vHalfChildDims.y;\par
00206             vChildPosition.z += vHalfChildDims.z;\par
00207             childNodeRegion.setPosDims(vChildPosition, vChildDims);\par
00208             {\cf19 break};\par
00209         {\cf19 case} ChildNode::POSX_POSY_POSZ:\par
00210             vChildPosition.x += vHalfChildDims.x;\par
00211             vChildPosition.y += vHalfChildDims.y;\par
00212             vChildPosition.z += vHalfChildDims.z;\par
00213             childNodeRegion.setPosDims(vChildPosition, vChildDims);\par
00214             {\cf19 break};\par
00215         {\cf19 default}:\par
00216             ThrowIfTrue(1, {\cf22 "COctTreeNode::computeChildNodeRegion() given invalid ChildNode to compute it's region."});\par
00217         \}\par
00218         {\cf19 return} childNodeRegion;\par
00219     \}\par
00220 \par
00221     {\cf18 void} COctTreeNode::addEntity(COctTreeEntity* pEntity)\par
00222     \{\par
00223         {\cf20 // If this node has no children, attempt to add the entity to this node}\par
00224         {\cf19 if} (!hasAnyChildNodes())\par
00225         \{\par
00226             {\cf20 // We haven't reached max capacity for this node}\par
00227             {\cf20 // OR we've reached maximum node depth with this node}\par
00228             {\cf19 if} (_mmapEntities.size() < _mpOctTree->_miMaxEntitiesPerNode ||\par
00229                 _muiNodeDepth == _mpOctTree->_muiMaxNodeDepth)\par
00230             \{\par
00231                 {\cf20 // Add the entity to this node}\par
00232                 {\cf20 // No need to check if the new entity name already exists, as COctTree::addEntity() has already checked}\par
00233                 _mmapEntities[pEntity->_mstrName] = pEntity;\par
00234                 pEntity->_mpNodeOwner = {\cf17 this};   {\cf20 // Set node owner for the entity}\par
00235                 {\cf19 return};\par
00236             \}\par
00237             {\cf20 // If we've reached maximum capacity for this node and max node depth hasn't been reached}\par
00238             {\cf19 if} (_mmapEntities.size() == _mpOctTree->_miMaxEntitiesPerNode)\par
00239             \{\par
00240                 {\cf20 // We need to create child node/s then move all the entities from this node into the children, }\par
00241                 {\cf20 // as well as the new entity}\par
00242 \par
00243                 {\cf20 // Compute potential child node regions}\par
00244                 CAABB aabbNNN = computeChildNodeRegion(ChildNode::NEGX_NEGY_NEGZ);\par
00245                 CAABB aabbNNP = computeChildNodeRegion(ChildNode::NEGX_NEGY_POSZ);\par
00246                 CAABB aabbNPN = computeChildNodeRegion(ChildNode::NEGX_POSY_NEGZ);\par
00247                 CAABB aabbNPP = computeChildNodeRegion(ChildNode::NEGX_POSY_POSZ);\par
00248                 CAABB aabbPNN = computeChildNodeRegion(ChildNode::POSX_NEGY_NEGZ);\par
00249                 CAABB aabbPNP = computeChildNodeRegion(ChildNode::POSX_NEGY_POSZ);\par
00250                 CAABB aabbPPN = computeChildNodeRegion(ChildNode::POSX_POSY_NEGZ);\par
00251                 CAABB aabbPPP = computeChildNodeRegion(ChildNode::POSX_POSY_POSZ);\par
00252 \par
00253                 {\cf20 // Add the new entity to this node's entity map, so it'll be moved to the correct child node below}\par
00254                 _mmapEntities[pEntity->_mstrName] = pEntity;\par
00255                 pEntity->_mpNodeOwner = {\cf17 this};   {\cf20 // Set node owner for the entity}\par
00256 \par
00257                 {\cf20 // Move all the entities from this node, into the child nodes}\par
00258                 std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.begin();\par
00259                 {\cf19 while} (it != _mmapEntities.end())\par
00260                 \{\par
00261                     {\cf20 // Determine which child node the entity fits in, regardless of whether the child node exists or not}\par
00262                     ChildNode childNode = ChildNode::NONE;\par
00263                     {\cf19 if} (aabbNNN.getPointIsInside(it->second->_mvPosition))\par
00264                         childNode = ChildNode::NEGX_NEGY_NEGZ;\par
00265                     {\cf19 else} {\cf19 if} (aabbNNP.getPointIsInside(it->second->_mvPosition))\par
00266                         childNode = ChildNode::NEGX_NEGY_POSZ;\par
00267                     {\cf19 else} {\cf19 if} (aabbNPN.getPointIsInside(it->second->_mvPosition))\par
00268                         childNode = ChildNode::NEGX_POSY_NEGZ;\par
00269                     {\cf19 else} {\cf19 if} (aabbNPP.getPointIsInside(it->second->_mvPosition))\par
00270                         childNode = ChildNode::NEGX_POSY_POSZ;\par
00271                     {\cf19 else} {\cf19 if} (aabbPNN.getPointIsInside(it->second->_mvPosition))\par
00272                         childNode = ChildNode::POSX_NEGY_NEGZ;\par
00273                     {\cf19 else} {\cf19 if} (aabbPNP.getPointIsInside(it->second->_mvPosition))\par
00274                         childNode = ChildNode::POSX_NEGY_POSZ;\par
00275                     {\cf19 else} {\cf19 if} (aabbPPN.getPointIsInside(it->second->_mvPosition))\par
00276                         childNode = ChildNode::POSX_POSY_NEGZ;\par
00277                     {\cf19 else} {\cf19 if} (aabbPPP.getPointIsInside(it->second->_mvPosition))\par
00278                         childNode = ChildNode::POSX_POSY_POSZ;\par
00279 \par
00280                     {\cf20 // Error checking, making sure the entity could fit in one of the eight possible children}\par
00281                     ThrowIfTrue(ChildNode::NONE == childNode, {\cf22 "COctTreeNode::addEntity() failed when trying to add entity "} + it->second->_mstrName + {\cf22 " to any of the eight child nodes as it's position doesn't fit inside any of them."});\par
00282 \par
00283                     {\cf20 // Create the child node if it doesn't exist}\par
00284                     {\cf19 if} (!_mpChildNode[childNode])\par
00285                     \{\par
00286                         _mpChildNode[childNode] = {\cf17 new} COctTreeNode(computeChildNodeRegion(childNode), {\cf17 this}, _mpOctTree);\par
00287                         ThrowIfFalse(_mpChildNode[childNode], {\cf22 "COctTreeNode::addEntity() failed when trying to add entity "} + it->second->_mstrName + {\cf22 " to any of the eight child nodes as it was unable to allocate memory for the child node."});\par
00288                     \}\par
00289                     _mpChildNode[childNode]->addEntity(it->second);\par
00290                     it++;\par
00291                 \}\par
00292                 {\cf20 // Remove all entities from this node as they are now stored in the children}\par
00293                 _mmapEntities.clear();\par
00294                 {\cf19 return};\par
00295             \}\par
00296         \}\par
00297 \par
00298         {\cf20 // If we get here, then this node has children, so add the new entity to one of those...}\par
00299         {\cf20 // Determine which child node the entity fits in}\par
00300         {\cf20 // Compute potential child node regions}\par
00301         CAABB aabbNNN = computeChildNodeRegion(ChildNode::NEGX_NEGY_NEGZ);\par
00302         CAABB aabbNNP = computeChildNodeRegion(ChildNode::NEGX_NEGY_POSZ);\par
00303         CAABB aabbNPN = computeChildNodeRegion(ChildNode::NEGX_POSY_NEGZ);\par
00304         CAABB aabbNPP = computeChildNodeRegion(ChildNode::NEGX_POSY_POSZ);\par
00305         CAABB aabbPNN = computeChildNodeRegion(ChildNode::POSX_NEGY_NEGZ);\par
00306         CAABB aabbPNP = computeChildNodeRegion(ChildNode::POSX_NEGY_POSZ);\par
00307         CAABB aabbPPN = computeChildNodeRegion(ChildNode::POSX_POSY_NEGZ);\par
00308         CAABB aabbPPP = computeChildNodeRegion(ChildNode::POSX_POSY_POSZ);\par
00309 \par
00310         ChildNode childNode = ChildNode::NONE;\par
00311         {\cf19 if} (aabbNNN.getPointIsInside(pEntity->_mvPosition))\par
00312             childNode = ChildNode::NEGX_NEGY_NEGZ;\par
00313         {\cf19 else} {\cf19 if} (aabbNNP.getPointIsInside(pEntity->_mvPosition))\par
00314             childNode = ChildNode::NEGX_NEGY_POSZ;\par
00315         {\cf19 else} {\cf19 if} (aabbNPN.getPointIsInside(pEntity->_mvPosition))\par
00316             childNode = ChildNode::NEGX_POSY_NEGZ;\par
00317         {\cf19 else} {\cf19 if} (aabbNPP.getPointIsInside(pEntity->_mvPosition))\par
00318             childNode = ChildNode::NEGX_POSY_POSZ;\par
00319         {\cf19 else} {\cf19 if} (aabbPNN.getPointIsInside(pEntity->_mvPosition))\par
00320             childNode = ChildNode::POSX_NEGY_NEGZ;\par
00321         {\cf19 else} {\cf19 if} (aabbPNP.getPointIsInside(pEntity->_mvPosition))\par
00322             childNode = ChildNode::POSX_NEGY_POSZ;\par
00323         {\cf19 else} {\cf19 if} (aabbPPN.getPointIsInside(pEntity->_mvPosition))\par
00324             childNode = ChildNode::POSX_POSY_NEGZ;\par
00325         {\cf19 else} {\cf19 if} (aabbPPP.getPointIsInside(pEntity->_mvPosition))\par
00326             childNode = ChildNode::POSX_POSY_POSZ;\par
00327 \par
00328         {\cf20 // Error checking, making sure the entity could fit in one of the eight possible children}\par
00329         ThrowIfTrue(ChildNode::NONE == childNode, {\cf22 "COctTreeNode::addEntity() failed when trying to add entity "} + pEntity->_mstrName + {\cf22 " to any of the eight child nodes as it's position doesn't fit inside any of them."});\par
00330 \par
00331         {\cf20 // Create the child node if it doesn't exist}\par
00332         {\cf19 if} (!_mpChildNode[childNode])\par
00333         \{\par
00334             _mpChildNode[childNode] = {\cf17 new} COctTreeNode(computeChildNodeRegion(childNode), {\cf17 this}, _mpOctTree);\par
00335             ThrowIfFalse(_mpChildNode[childNode], {\cf22 "COctTreeNode::addEntity() failed when trying to add entity "} + pEntity->_mstrName + {\cf22 " to any of the eight child nodes as it was unable to allocate memory for the child node."});\par
00336         \}\par
00337 \par
00338         {\cf20 // Add the new entity}\par
00339         _mpChildNode[childNode]->addEntity(pEntity);\par
00340     \}\par
00341 \par
00342     {\cf18 void} COctTreeNode::removeEntity(COctTreeEntity* pEntity)\par
00343     \{\par
00344         {\cf20 // Attempt to find the entity}\par
00345         std::map<std::string, COctTreeEntity*>::iterator it = _mmapEntities.find(pEntity->_mstrName);\par
00346         ThrowIfTrue(it == _mmapEntities.end(), {\cf22 "COctTreeNode::removeEntity() failed. The entity named "} + pEntity->_mstrName + {\cf22 " could not be found"});\par
00347         _mmapEntities.erase(it);\par
00348         {\cf20 // No need to delete entity, the COctTree::removeAllEntities() or COctTree::removeEntity() does this}\par
00349     \}\par
00350 \par
00351     {\cf18 void} COctTreeNode::getNodesWithEntities(std::vector<COctTreeNode*>& vecNodes)\par
00352     \{\par
00353         {\cf20 // If this node doesn't have any children, just check this node}\par
00354         {\cf19 if} (!hasAnyChildNodes())\par
00355         \{\par
00356             {\cf20 // If this node doesn't have any entities}\par
00357             {\cf19 if} (0 == _mmapEntities.size())\par
00358                 {\cf19 return};\par
00359 \par
00360             {\cf20 // Add this node}\par
00361             vecNodes.push_back({\cf17 this});\par
00362             {\cf19 return};\par
00363         \}\par
00364         {\cf19 else}  {\cf20 // This node has children, check those}\par
00365         \{\par
00366             {\cf19 for} ({\cf18 int} i = 0; i < 8; i++)\par
00367             \{\par
00368                 {\cf19 if} (_mpChildNode[i])\par
00369                     _mpChildNode[i]->getNodesWithEntities(vecNodes);\par
00370             \}\par
00371         \}\par
00372     \}\par
00373 \par
00374     {\cf18 void} COctTreeNode::getNodesWithEntitiesWhichIntersect(std::vector<COctTreeNode*>& vecNodes, {\cf17 const} CAABB& aabb)\par
00375     \{\par
00376         {\cf20 // If this node doesn't have any children, just check this node}\par
00377         {\cf19 if} (!hasAnyChildNodes())\par
00378         \{\par
00379             {\cf20 // If this node doesn't have any entities}\par
00380             {\cf19 if} (0 == _mmapEntities.size())\par
00381                 {\cf19 return};\par
00382 \par
00383             {\cf20 // If the AABB interects with this node, add this node}\par
00384             {\cf19 if} (_mRegion.getAABBintersects(aabb))\par
00385             \{\par
00386                 vecNodes.push_back({\cf17 this});\par
00387                 {\cf19 return};\par
00388             \}\par
00389         \}\par
00390         {\cf19 else}  {\cf20 // This node has children, check those}\par
00391         \{\par
00392             {\cf19 for} ({\cf18 int} i = 0; i < 8; i++)\par
00393             \{\par
00394                 {\cf19 if} (_mpChildNode[i])\par
00395                     _mpChildNode[i]->getNodesWithEntitiesWhichIntersect(vecNodes, aabb);\par
00396             \}\par
00397         \}\par
00398     \}\par
00399 \par
00400     {\cf18 void} COctTreeNode::getNodesWithEntitiesWhichIntersect(std::vector<COctTreeNode*>& vecNodes, {\cf17 const} CFrustum& frustum)\par
00401     \{\par
00402         {\cf20 // If this node doesn't have any children, just check this node}\par
00403         {\cf19 if} (!hasAnyChildNodes())\par
00404         \{\par
00405             {\cf20 // If this node doesn't have any entities}\par
00406             {\cf19 if} (0 == _mmapEntities.size())\par
00407                 {\cf19 return};\par
00408 \par
00409             {\cf20 // If the AABB interects with this node, add this node}\par
00410             {\cf19 if} (frustum.isAABBIntersecting(_mRegion))\par
00411             \{\par
00412                 vecNodes.push_back({\cf17 this});\par
00413                 {\cf19 return};\par
00414             \}\par
00415         \}\par
00416         {\cf19 else}  {\cf20 // This node has children, check those}\par
00417         \{\par
00418             {\cf19 for} ({\cf18 int} i = 0; i < 8; i++)\par
00419             \{\par
00420                 {\cf19 if} (_mpChildNode[i])\par
00421                     _mpChildNode[i]->getNodesWithEntitiesWhichIntersect(vecNodes, frustum);\par
00422             \}\par
00423         \}\par
00424     \}\par
00425 \par
00426     {\cf18 void} COctTreeNode::getMaxNodeDepth({\cf18 unsigned} {\cf18 int}& uiMaxNodeDepth)\par
00427     \{\par
00428         {\cf19 if} (_muiNodeDepth > uiMaxNodeDepth)\par
00429             uiMaxNodeDepth = _muiNodeDepth;\par
00430 \par
00431         {\cf20 // Call this method for all children of this node}\par
00432         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00433         \{\par
00434             {\cf19 if} (_mpChildNode[i])    {\cf20 // If child exists}\par
00435                 _mpChildNode[i]->getMaxNodeDepth(uiMaxNodeDepth);\par
00436         \}\par
00437     \}\par
00438 \par
00439 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeNode.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeNode.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeNode.h}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../Math/AABB.h"}\par
{\f2 #include "OctTreeEntity.h"}\par
{\f2 #include "../Math/Frustum.h"}\par
{\f2 #include <map>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::COctTreeNode}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b COctTree} class. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b OctTreeNode.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OctTreeNode.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeNode.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/OctTreeNode.h}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef OCTTREENODE_H}\par
00007 {\cf21 #define OCTTREENODE_H}\par
00008 \par
00009 {\cf21 #include "../Math/AABB.h"}\par
00010 {\cf21 #include "OctTreeEntity.h"}\par
00011 {\cf20 //#include "resourceManager.h"}\par
00012 {\cf21 #include "../Math/Frustum.h"}\par
00013 \par
00014 {\cf21 #include <map>}\par
00015 {\cf21 #include <vector>}\par
00016 \par
00017 {\cf17 namespace }DCL\par
00018 \{\par
00019     {\cf17 class }COctTree;\par
00020 \par
00022     {\cf17 class }COctTreeNode\par
00023     \{\par
00024         {\cf17 friend} {\cf17 class }COctTree;\par
00025     {\cf17 public}:\par
00027         {\cf17 enum} ChildNode\par
00028         \{\par
00029             NEGX_NEGY_NEGZ,\par
00030             NEGX_POSY_NEGZ,\par
00031             NEGX_NEGY_POSZ,\par
00032             NEGX_POSY_POSZ,\par
00033             POSX_NEGY_NEGZ,\par
00034             POSX_POSY_NEGZ,\par
00035             POSX_NEGY_POSZ,\par
00036             POSX_POSY_POSZ,\par
00037             NONE\par
00038         \};\par
00039 \par
00049         COctTreeNode({\cf17 const} CAABB& region, COctTreeNode* pParentNode, COctTree* pOctTree);\par
00050 \par
00057         ~COctTreeNode();\par
00058         \par
00063 {\cf20 //      void debugRenderNodes(CResourceVertexBufferLine* pLine, CColour colour) const;}\par
00064 \par
00065         {\cf20 /*}\par
00066 {\cf20         // Debug renders this node and it's child nodes' entities}\par
00067 {\cf20         // pLine is the CResourceLine object which is being used to add vertices to be rendered}\par
00068 {\cf20         void debugRenderEntities(CResourceLine* pLine, int iCircleRadius, unsigned int uiCircleNumSegments) const;}\par
00069 {\cf20         */}\par
00070 \par
00075         {\cf18 bool} hasChildNode(ChildNode childNode) {\cf17 const};\par
00076 \par
00080         {\cf18 bool} hasAnyChildNodes({\cf18 void}) {\cf17 const};\par
00081 \par
00085         {\cf18 bool} hasEntitiesInThisAndAllChildren({\cf18 void}) {\cf17 const};\par
00086 \par
00092         {\cf18 void} createChildNode(ChildNode childNode);\par
00093 \par
00098         CAABB computeChildNodeRegion(ChildNode childNode) {\cf17 const};\par
00099 \par
00103         {\cf18 void} addEntity(COctTreeEntity* pEntity);\par
00104 \par
00110         {\cf18 void} removeEntity(COctTreeEntity* pEntity);\par
00111 \par
00115         {\cf18 void} getNodesWithEntities(std::vector<COctTreeNode*>& vecNodes);\par
00116 \par
00121         {\cf18 void} getNodesWithEntitiesWhichIntersect(std::vector<COctTreeNode*>& vecNodes, {\cf17 const} CAABB& aabb);\par
00122 \par
00127         {\cf18 void} getNodesWithEntitiesWhichIntersect(std::vector<COctTreeNode*>& vecNodes, {\cf17 const} CFrustum& frustum);\par
00128 \par
00132         {\cf18 void} getMaxNodeDepth({\cf18 unsigned} {\cf18 int}& uiMaxNodeDepth);\par
00133     {\cf17 private}:\par
00136         CAABB _mRegion;\par
00137 \par
00139         COctTreeNode* _mpParentNode;\par
00140 \par
00144         COctTreeNode* _mpChildNode[8];\par
00145 \par
00147         COctTree* _mpOctTree;\par
00148 \par
00152         {\cf18 unsigned} {\cf18 int} _muiNodeDepth;\par
00153 \par
00157         {\cf17 mutable} std::map<std::string, COctTreeEntity*> _mmapEntities;\par
00158     \};\par
00159 \par
00160 \}   {\cf20 // namespace DCL}\par
00161 \par
00162 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QuadTree.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTree.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTree.cpp}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "QuadTree.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     CQuadTree::CQuadTree({\cf18 int} iMaxEntitiesPerNode, {\cf18 int} iRectSizeIncreaseMultiplier)\par
00007     \{\par
00008         _mpRootNode = 0;\par
00009 \par
00010         init(iMaxEntitiesPerNode, iRectSizeIncreaseMultiplier);\par
00011     \}\par
00012 \par
00013     {\cf18 void} CQuadTree::init({\cf18 int} iMaxEntitiesPerNode, {\cf18 int} iRectSizeIncreaseMultiplier)\par
00014     \{\par
00015         free();\par
00016 \par
00017         CRect rctInitialRootNodeRegion(-1024, -1024, 1024, 1024);\par
00018 \par
00019         {\cf20 // Attempt to create root node, passing 0 as the pointer to the parent node}\par
00020         _mpRootNode = {\cf17 new} CQuadTreeNode(rctInitialRootNodeRegion, 0, {\cf17 this});\par
00021         ThrowIfFalse(_mpRootNode, {\cf22 "CQuadTree::init() failed. Unable to allocate memory for root node."});\par
00022 \par
00023         {\cf20 // Make sure valid values were given}\par
00024         ThrowIfTrue(iMaxEntitiesPerNode < 1, {\cf22 "CQuadTree::init() failed. Given invalid number for iMaxEntitiesPerNode. Must be at least one."});\par
00025         ThrowIfTrue(iRectSizeIncreaseMultiplier < 2, {\cf22 "CQuadTree::init() failed. Given invalid number for iRectSizeIncreaseMultiplier. Must be at least 2."});\par
00026 \par
00027         {\cf20 // Store settings}\par
00028         _miMaxEntitiesPerNode = iMaxEntitiesPerNode;\par
00029         _miRectSizeIncreaseMultiplier = iRectSizeIncreaseMultiplier;\par
00030 \par
00031         {\cf20 // Current maximum node depth}\par
00032         _muiCurrentMaxNodeDepth = 0;\par
00033 \par
00034         {\cf20 // Compute maximum node depth before node division is forbidden.}\par
00035         _computeMaxNodeDepth();\par
00036     \}\par
00037 \par
00038     CQuadTree::~CQuadTree()\par
00039     \{\par
00040         free();\par
00041     \}\par
00042 \par
00043     {\cf18 void} CQuadTree::free({\cf18 void})\par
00044     \{\par
00045         {\cf20 // Delete root node, which will delete all children and their children and so on.}\par
00046         {\cf20 // Although this obviously removes the entities from the nodes, because the nodes themselves}\par
00047         {\cf20 // no longer exist, this does NOT delete the entity pointers. They are stored in this object's}\par
00048         {\cf20 // _mmapEntities hashmap.}\par
00049         {\cf19 if} (_mpRootNode)\par
00050         \{\par
00051             {\cf17 delete} _mpRootNode;\par
00052             _mpRootNode = 0;\par
00053         \}\par
00054 \par
00055         {\cf20 // Delete all entities}\par
00056         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.begin();\par
00057         {\cf19 while} (it != _mmapEntities.end())\par
00058         \{\par
00059             {\cf17 delete} it->second;\par
00060             it++;\par
00061         \}\par
00062         _mmapEntities.clear();\par
00063     \}\par
00064 \par
00065     {\cf20 /*}\par
00066 {\cf20     void CQuadTree::debugRender(const CVector3f& vCameraPosition, bool bRenderNodes, bool bRenderEntities, int iEntityCircleRadius, unsigned int uiEntityCircleNumSegments) const}\par
00067 {\cf20     \{}\par
00068 {\cf20         if (!bRenderNodes && !bRenderEntities)}\par
00069 {\cf20             return;}\par
00070 {\cf20 }\par
00071 {\cf20         // Obtain required resources needed to render the node's as lines.}\par
00072 {\cf20         CResourceVertexBufferLine* pLine = x->pResource->getVertexBufferLine("X:default");}\par
00073 {\cf20         CResourceShader* pShader = x->pResource->getShader("X:VBCPT");}\par
00074 {\cf20         CResourceTexture2DFromFile* pTexture = x->pResource->getTexture2DFromFile("X:default_white");}\par
00075 {\cf20 }\par
00076 {\cf20         // Setup orthographic projection matrix}\par
00077 {\cf20         CMatrix matrixWorld;}\par
00078 {\cf20         CMatrix matrixView;}\par
00079 {\cf20         CVector3f vTargetPos = vCameraPosition;}\par
00080 {\cf20         vTargetPos.z -= 100.0f;}\par
00081 {\cf20         matrixView.setViewLookat(vCameraPosition, vTargetPos, CVector3f(0.0f, 1.0f, 0.0f));}\par
00082 {\cf20 }\par
00083 {\cf20         CMatrix matrixProjection;}\par
00084 {\cf20         matrixProjection.setProjectionPerspective(55.0f, 1.0f, 10000.0f);}\par
00085 {\cf20 }\par
00086 {\cf20         // Bind shader and set uniforms}\par
00087 {\cf20         pShader->bind();}\par
00088 {\cf20         pShader->setMat4("matrixWorld", matrixWorld);}\par
00089 {\cf20         pShader->setMat4("matrixView", matrixView);}\par
00090 {\cf20         pShader->setMat4("matrixProjection", matrixProjection);}\par
00091 {\cf20 }\par
00092 {\cf20         // Tell OpenGL, for each sampler, to which texture unit it belongs to}\par
00093 {\cf20         pShader->setInt("texture0", 0);}\par
00094 {\cf20 }\par
00095 {\cf20         // And bind the texture...}\par
00096 {\cf20         pTexture->bind();}\par
00097 {\cf20 }\par
00098 {\cf20         // Set the line vertex buffer rendering mode}\par
00099 {\cf20         pLine->setDrawModeAsLineList();}\par
00100 {\cf20         pLine->removeGeom();}\par
00101 {\cf20 }\par
00102 {\cf20         glEnable(GL_BLEND);}\par
00103 {\cf20         glDisable(GL_DEPTH_TEST);}\par
00104 {\cf20         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);}\par
00105 {\cf20 }\par
00106 {\cf20         // Setup vertex we'll be using to render with}\par
00107 {\cf20         CResourceVertexBufferLine::Vertex vertex;}\par
00108 {\cf20         vertex.colour.set(1.0f, 1.0f, 1.0f, 1.0f);}\par
00109 {\cf20 }\par
00110 {\cf20         // Call the root node's debugRender method which will render itself and it's children recursively}\par
00111 {\cf20         if (bRenderNodes)}\par
00112 {\cf20             _mpRootNode->debugRenderNodes(pLine, vertex, CColour(1.0f, 1.0f, 1.0f, 1.0f));}\par
00113 {\cf20         if (bRenderEntities)}\par
00114 {\cf20             _mpRootNode->debugRenderEntities(pLine, iEntityCircleRadius, uiEntityCircleNumSegments);}\par
00115 {\cf20 }\par
00116 {\cf20         // Send geometry to be rendered}\par
00117 {\cf20         pLine->update();}\par
00118 {\cf20         pLine->render();}\par
00119 {\cf20 }\par
00120 {\cf20         // Cleanup}\par
00121 {\cf20         glDisable(GL_BLEND);}\par
00122 {\cf20         glEnable(GL_DEPTH_TEST);}\par
00123 {\cf20         pTexture->unbind();}\par
00124 {\cf20         pShader->unbind();}\par
00125 {\cf20     \}}\par
00126 {\cf20     */}\par
00127 \par
00128     {\cf20 /*}\par
00129 {\cf20     void CQuadTree::debugSetEntityColour(const std::string& strName, CColour& colour)}\par
00130 {\cf20     \{}\par
00131 {\cf20         // Find the entity}\par
00132 {\cf20         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.find(strName);}\par
00133 {\cf20         ThrowIfTrue(_mmapEntities.end() == it, "CQuadTree::debugSetEntityColour() failed. The entity name of " + strName + " doesn't exist.");}\par
00134 {\cf20         it->second->_mColDebug = colour;}\par
00135 {\cf20     \}}\par
00136 {\cf20     */}\par
00137 \par
00138     {\cf20 /*}\par
00139 {\cf20     void CQuadTree::debugSetAllEntitiesColour(CColour& colour)}\par
00140 {\cf20     \{}\par
00141 {\cf20         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.begin();}\par
00142 {\cf20         while (it != _mmapEntities.end())}\par
00143 {\cf20         \{}\par
00144 {\cf20             it->second->_mColDebug = colour;}\par
00145 {\cf20             it++;}\par
00146 {\cf20         \}}\par
00147 {\cf20     \}}\par
00148 {\cf20     */}\par
00149 \par
00150     {\cf18 void} CQuadTree::addEntity({\cf17 const} std::string& strName, {\cf18 int} iPosX, {\cf18 int} iPosY, {\cf18 int} iUserData, {\cf18 void}* pUserData)\par
00151     \{\par
00152         {\cf20 // Make sure the entity doesn't already exist by checking the hashmap}\par
00153         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00154         ThrowIfTrue(_mmapEntities.end() != it, {\cf22 "CQuadTree::addEntity() failed. The entity name of "} + strName + {\cf22 " already exists."});\par
00155 \par
00156         {\cf20 // Create new entity, setting it's owner to 0}\par
00157         CQuadTreeEntity* pEntity = {\cf17 new} CQuadTreeEntity(strName, iPosX, iPosY, 0, iUserData, pUserData);\par
00158         ThrowIfFalse(pEntity, {\cf22 "CQuadTree::addEntity() failed to allocate memory for new entity."});\par
00159 \par
00160         {\cf20 // Add entity to hashmap for fast lookup}\par
00161         _mmapEntities[strName] = pEntity;\par
00162 \par
00163         {\cf20 // Determine whether the given position of the entity fits in the root node}\par
00164         {\cf19 if} (!_mpRootNode->_mRectRegion.doesPositionFitWithin(iPosX, iPosY))\par
00165         \{\par
00166             {\cf20 // The position of the new entity doesn't fit within the root node's area}\par
00167             {\cf20 // We're going to have to recreate the entire tree}\par
00168 \par
00169             {\cf20 // Delete root node, which will delete all children and their children and so on.}\par
00170             {\cf20 // This does not delete the entities (As they're stored in the _mmapEntities hashmap)}\par
00171             {\cf20 // But before deleting the root node, get it's currently set region which we will multiply to get}\par
00172             {\cf20 // the root node's new dimensions}\par
00173             CRect rectOldRootNodeRegion = _mpRootNode->_mRectRegion;\par
00174             {\cf17 delete} _mpRootNode;\par
00175 \par
00176             {\cf20 // Inscrease the old root node's region size until the new entity's position fits within}\par
00177             {\cf18 bool} bNewPositionFits = {\cf17 false};\par
00178             {\cf19 while} (!bNewPositionFits)\par
00179             \{\par
00180                 rectOldRootNodeRegion.resizeArea(_miRectSizeIncreaseMultiplier);\par
00181                 bNewPositionFits = rectOldRootNodeRegion.doesPositionFitWithin(iPosX, iPosY);\par
00182             \}\par
00183 \par
00184             {\cf20 // Now re-create the root node, passing 0 as the pointer to the parent node and the new region size}\par
00185             _mpRootNode = {\cf17 new} CQuadTreeNode(rectOldRootNodeRegion, 0, {\cf17 this});\par
00186             ThrowIfFalse(_mpRootNode, {\cf22 "CQuadTree::addEntity() failed. Unable to allocate memory for new root node."});\par
00187 \par
00188             {\cf20 // Now re-insert all entities stored in the hash map back into the tree}\par
00189             {\cf20 // The new entity has already been added to the hash map, so no need to insert it seperately}\par
00190             it = _mmapEntities.begin();\par
00191             {\cf19 while} (it != _mmapEntities.end())\par
00192             \{\par
00193                 _mpRootNode->addEntity(it->second);\par
00194                 it++;\par
00195             \}\par
00196         \}\par
00197         {\cf19 else}  {\cf20 // The entity position does fit inside the rect of this node, simply add it}\par
00198         \{\par
00199             _mpRootNode->addEntity(pEntity);\par
00200         \}\par
00201     \}\par
00202 \par
00203     {\cf18 void} CQuadTree::removeEntity({\cf17 const} std::string& strName)\par
00204     \{\par
00205         {\cf20 // Make sure the entity exists by checking the hashmap}\par
00206         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00207         ThrowIfTrue(_mmapEntities.end() == it, {\cf22 "CQuadTree::removeEntity() failed. The entity name of "} + strName + {\cf22 " doesn't exist."});\par
00208 \par
00209         {\cf20 // Get the node the entity is stored in to remove the entity from itself.}\par
00210         CQuadTreeNode* pNodeContainingRemovedEntity = it->second->_mpNodeOwner;\par
00211         pNodeContainingRemovedEntity->removeEntity(it->second);\par
00212 \par
00213         {\cf20 // Remove the entity from the hashmap and delete it}\par
00214         CQuadTreeEntity* pEntity = it->second;\par
00215         _mmapEntities.erase(it);\par
00216         {\cf17 delete} pEntity;\par
00217 \par
00218         {\cf20 // Now check to see if the node is now empty and if so, remove it}\par
00219         {\cf19 if} (!pNodeContainingRemovedEntity->hasEntitiesInThisAndAllChildren())\par
00220         \{\par
00221             {\cf20 // Is the node which held the removed entity, the root node}\par
00222             {\cf18 bool} bNodeIsRoot = _mpRootNode == pNodeContainingRemovedEntity;\par
00223 \par
00224             {\cf19 if} (!bNodeIsRoot)  {\cf20 // The node wasn't the root node and therefore pNodeParent will contain a valid pointer to it's parent node.}\par
00225             \{\par
00226                 {\cf20 // Store pointer to the parent}\par
00227                 CQuadTreeNode* pNodeParent = pNodeContainingRemovedEntity->_mpParentNode;\par
00228 \par
00229                 {\cf20 // We're done, except...}\par
00230                 {\cf20 // We need to traverse up to the root node and delete any NOW empty nodes, which may }\par
00231                 {\cf20 // have only existed to hold the now deleted node.}\par
00232                 {\cf20 // We also have to remove any parent node's _mpChildNode[4] pointers if we delete a node.}\par
00233                 {\cf19 while} (pNodeParent)\par
00234                 \{\par
00235                     {\cf20 // Go through each of the four possible child nodes of the parent}\par
00236                     {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00237                     \{\par
00238                         {\cf19 if} (pNodeParent->_mpChildNode[i])   {\cf20 // There is a child at this array position}\par
00239                         \{\par
00240                             {\cf19 if} (!pNodeParent->_mpChildNode[i]->hasEntitiesInThisAndAllChildren())   {\cf20 // Node is empty}\par
00241                             \{\par
00242                                 {\cf17 delete} pNodeParent->_mpChildNode[i];\par
00243                                 pNodeParent->_mpChildNode[i] = 0;\par
00244                             \}\par
00245                         \}\par
00246                     \}\par
00247                     pNodeParent = pNodeParent->_mpParentNode;\par
00248                 \}\par
00249 \par
00250                 {\cf20 // This will delete the node and all it's children.}\par
00251                 {\cf20 // No need to delete, as it's deleted above when deleting children.}\par
00252                 {\cf20 // If we attempted to delete again, all hell breaks loose!}\par
00253 {\cf20 //              delete pNodeContainingRemovedEntity;}\par
00254             \}\par
00255         \}   \par
00256         {\cf20 // The node which contained the entity has other entities, leave it alone.}\par
00257     \}\par
00258 \par
00259     {\cf18 bool} CQuadTree::getEntityExists({\cf17 const} std::string& strName){\cf17  const}\par
00260 {\cf17     }\{\par
00261         {\cf20 // Check the hashmap}\par
00262         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00263         {\cf19 return}(_mmapEntities.end() != it);\par
00264     \}\par
00265 \par
00266     {\cf18 void} CQuadTree::removeAllEntities({\cf18 bool} bResetTree)\par
00267     \{\par
00268         {\cf20 // Go through each entity, asking each node which it's in to remove itself}\par
00269         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.begin();\par
00270         {\cf19 while} (it != _mmapEntities.end())\par
00271         \{\par
00272             {\cf20 // Get the node the entity is stored in to remove the entity from itself.}\par
00273             it->second->_mpNodeOwner->removeEntity(it->second);\par
00274 \par
00275             {\cf20 // Remove the entity from the hashmap and delete it}\par
00276             CQuadTreeEntity* pEntity = it->second;\par
00277             _mmapEntities.erase(it);\par
00278             {\cf17 delete} pEntity;\par
00279             it = _mmapEntities.begin();\par
00280         \}\par
00281 \par
00282         {\cf20 // Now all entities are removed and deleted, reset the tree if bResetTree desires it}\par
00283         {\cf19 if} (bResetTree)\par
00284         \{\par
00285             {\cf20 // Get the root node's rect, so we can re-create it}\par
00286             CRect rectRootNode = _mpRootNode->_mRectRegion;\par
00287             {\cf17 delete} _mpRootNode;\par
00288             _mpRootNode = {\cf17 new} CQuadTreeNode(rectRootNode, 0, {\cf17 this});\par
00289 \par
00290             {\cf20 // Reset current max node depth}\par
00291             _muiCurrentMaxNodeDepth = 0;\par
00292 \par
00293             {\cf20 // Compute new maximum node depth}\par
00294             _computeMaxNodeDepth();\par
00295         \}\par
00296     \}\par
00297 \par
00298     {\cf18 void} CQuadTree::setEntityPosition({\cf17 const} std::string& strName, {\cf18 int} iNewPosX, {\cf18 int} iNewPosY)\par
00299     \{\par
00300         {\cf20 // First make sure the named entity exists}\par
00301         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00302         ThrowIfTrue(it == _mmapEntities.end(), {\cf22 "CQuadTree::setEntityPosition() failed. The named entity of "} + strName + {\cf22 " doesn't exist."});\par
00303 \par
00304         {\cf20 // First check to see if the new entity position still fits within it's current node}\par
00305         {\cf20 // If it does, we simply update the position}\par
00306         {\cf19 if} (it->second->_mpNodeOwner->_mRectRegion.doesPositionFitWithin(iNewPosX, iNewPosY))\par
00307         \{\par
00308             it->second->_miPosX = iNewPosX;\par
00309             it->second->_miPosY = iNewPosY;\par
00310             {\cf19 return};\par
00311         \}\par
00312 \par
00313         {\cf20 // If we get here, the new position doesn't fit within the entity's current node}\par
00314 \par
00315         {\cf20 // Remove the entity from the tree and then re-insert it}\par
00316         {\cf18 int} iUserData = it->second->miUserData;\par
00317         {\cf18 void}* pUserData = it->second->mpUserData;\par
00318         removeEntity(strName);\par
00319         addEntity(strName, iNewPosX, iNewPosY, iUserData, pUserData);\par
00320     \}\par
00321 \par
00322     {\cf18 void} CQuadTree::getEntityPosition({\cf17 const} std::string& strName, {\cf18 int}& iPosX, {\cf18 int}& iPosY){\cf17  const}\par
00323 {\cf17     }\{\par
00324         {\cf20 // First make sure the named entity exists}\par
00325         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.find(strName);\par
00326         ThrowIfTrue(it == _mmapEntities.end(), {\cf22 "CQuadTree::getEntityPosition() failed. The named entity of "} + strName + {\cf22 " doesn't exist."});\par
00327         iPosX = it->second->_miPosX;\par
00328         iPosY = it->second->_miPosY;\par
00329     \}\par
00330 \par
00331     {\cf18 void} CQuadTree::_computeMaxNodeDepth({\cf18 void})\par
00332     \{\par
00333         {\cf20 // Obtain smallest dimension of root node}\par
00334         {\cf18 int} iDimOfRootX = _mpRootNode->_mRectRegion.miMaxX - _mpRootNode->_mRectRegion.miMinX;\par
00335         {\cf18 int} iDimOfRootY = _mpRootNode->_mRectRegion.miMaxY - _mpRootNode->_mRectRegion.miMinY;\par
00336         {\cf18 int} iSmallestDim = iDimOfRootX;\par
00337         {\cf19 if} (iDimOfRootY < iDimOfRootX)\par
00338             iSmallestDim = iDimOfRootY;\par
00339         {\cf20 // Now compute max node depth}\par
00340         _muiMaxNodeDepth = 0;\par
00341         {\cf19 while} (iSmallestDim > 2)\par
00342         \{\par
00343             iSmallestDim /= 2;\par
00344             _muiMaxNodeDepth++;\par
00345         \}\par
00346     \}\par
00347 \par
00348     std::vector<CQuadTreeNode*> CQuadTree::getNodesWithEntities({\cf18 void}){\cf17  const}\par
00349 {\cf17     }\{\par
00350         std::vector<CQuadTreeNode*> vResult;\par
00351         _mpRootNode->getNodesWithEntities(vResult);\par
00352         {\cf19 return} vResult;\par
00353     \}\par
00354 \par
00355     std::vector<CQuadTreeNode*> CQuadTree::getNodesWithEntitiesWhichIntersect({\cf17 const} CRect& rect){\cf17  const}\par
00356 {\cf17     }\{\par
00357         std::vector<CQuadTreeNode*> vResult;\par
00358         _mpRootNode->getNodesWithEntitiesWhichIntersect(vResult, rect);\par
00359         {\cf19 return} vResult;\par
00360     \}\par
00361 \par
00362     std::vector<CQuadTreeEntity*> CQuadTree::getEntitiesWithinRange({\cf18 int} iPosX, {\cf18 int} iPosY, {\cf18 int} iRange){\cf17  const}\par
00363 {\cf17     }\{\par
00364         {\cf20 // Create a rect which covers the maximum range from the given position}\par
00365         CRect rectRange;\par
00366         rectRange.miMinX = iPosX - iRange;\par
00367         rectRange.miMaxX = iPosX + iRange;\par
00368         rectRange.miMinY = iPosY - iRange;\par
00369         rectRange.miMaxY = iPosY + iRange;\par
00370 \par
00371         {\cf20 // Go through the nodes and get a vector of nodes which intersect the rect and have entities in them}\par
00372         std::vector<CQuadTreeNode*> vNodes = getNodesWithEntitiesWhichIntersect(rectRange);\par
00373         std::vector<CQuadTreeEntity*> vResult;\par
00374         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vNodes.size(); ui++)\par
00375         \{\par
00376             {\cf20 // Go through each entity within each node and add them to the resulting vector}\par
00377             std::map<std::string, CQuadTreeEntity*>::iterator it = vNodes[ui]->_mmapEntities.begin();\par
00378             {\cf19 while} (it != vNodes[ui]->_mmapEntities.end())\par
00379             \{\par
00380                 vResult.push_back(it->second);\par
00381                 it++;\par
00382             \}\par
00383         \}\par
00384         {\cf19 return} vResult;\par
00385     \}\par
00386 \par
00387     std::vector<CQuadTreeEntity*> CQuadTree::getEntitiesWithinRect({\cf17 const} CRect& rect){\cf17  const}\par
00388 {\cf17     }\{\par
00389         {\cf20 // Go through the nodes and get a vector of the nodes which intersect the rect and have entities in them}\par
00390         std::vector<CQuadTreeNode*> vNodes = getNodesWithEntitiesWhichIntersect(rect);\par
00391         std::vector<CQuadTreeEntity*> vResult;\par
00392         {\cf19 for} ({\cf18 unsigned} {\cf18 int} ui = 0; ui < vNodes.size(); ui++)\par
00393         \{\par
00394             {\cf20 // Go through each entity within each node and add them to the resulting vector}\par
00395             std::map<std::string, CQuadTreeEntity*>::iterator it = vNodes[ui]->_mmapEntities.begin();\par
00396             {\cf19 while} (it != vNodes[ui]->_mmapEntities.end())\par
00397             \{\par
00398                 vResult.push_back(it->second);\par
00399                 it++;\par
00400             \}\par
00401         \}\par
00402         {\cf19 return} vResult;\par
00403     \}\par
00404 \par
00405     {\cf18 unsigned} {\cf18 int} CQuadTree::getNodeDepthCurrent({\cf18 void})\par
00406     \{\par
00407         {\cf20 // We have to recompute this, so go through all nodes, get their depth and compare}\par
00408         _muiCurrentMaxNodeDepth = 0;\par
00409         _mpRootNode->getMaxNodeDepth(_muiCurrentMaxNodeDepth);\par
00410         {\cf19 return} _muiCurrentMaxNodeDepth;\par
00411     \}\par
00412 \par
00413     {\cf18 unsigned} {\cf18 int} CQuadTree::getNodeDepthMax({\cf18 void}){\cf17  const}\par
00414 {\cf17     }\{\par
00415         {\cf19 return} _muiMaxNodeDepth;\par
00416     \}\par
00417 \par
00418 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTree.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTree.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTree.h}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "QuadTreeNode.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CQuadTree}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a 2D spatial partitioning class. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b QuadTree.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QuadTree.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTree.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTree.h}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef QUADTREE_H}\par
00007 {\cf21 #define QUADTREE_H}\par
00008 \par
00009 {\cf21 #include "QuadTreeNode.h"}\par
00010 \par
00011 {\cf17 namespace }DCL\par
00012 \{\par
00046     {\cf17 class }CQuadTree\par
00047     \{\par
00048         {\cf17 friend} {\cf17 class }CQuadTreeNode;\par
00049         {\cf17 friend} {\cf17 class }CQuadTreeEntity;\par
00050     {\cf17 public}:\par
00063         CQuadTree({\cf18 int} iMaxEntitiesPerNode = 10, {\cf18 int} iRectSizeIncreaseMultiplier = 2);\par
00064 \par
00068         ~CQuadTree();\par
00069 \par
00084         {\cf18 void} init({\cf18 int} iMaxEntitiesPerNode = 10, {\cf18 int} iRectSizeIncreaseMultiplier = 2);\par
00085 \par
00087         {\cf18 void} free({\cf18 void});\par
00088 \par
00089         {\cf20 // Debug rendering of the oct tree's nodes and entities}\par
00090 {\cf20 //      void debugRender(const CVector3f& vCameraPosition = CVector3f(0.0f, 0.0f, 0.0f), bool bRenderNodes = true, bool bRenderEntities = true, int iEntityCircleRadius = 8, unsigned int uiEntityCircleNumSegments = 6) const;}\par
00091 \par
00092         {\cf20 // For debug rendering, sets the named entity's rendered colour}\par
00093         {\cf20 // If the named entity doesn't exist, an exception occurs.}\par
00094 {\cf20 //      void debugSetEntityColour(const std::string& strName, CColour& colour);}\par
00095 \par
00096         {\cf20 // For debug rendering, sets all entities' rendered colour to the one given}\par
00097 {\cf20 //      void debugSetAllEntitiesColour(CColour& colour);}\par
00098 \par
00109         {\cf18 void} addEntity({\cf17 const} std::string& strName, {\cf18 int} iPosX, {\cf18 int} iPosY, {\cf18 int} iUserData = 0, {\cf18 void} *pUserData = 0);\par
00110 \par
00115         {\cf18 void} removeEntity({\cf17 const} std::string& strName);\par
00116 \par
00121         {\cf18 bool} getEntityExists({\cf17 const} std::string& strName) {\cf17 const};\par
00122 \par
00126         {\cf18 void} removeAllEntities({\cf18 bool} bResetTree = {\cf17 false});\par
00127 \par
00133         {\cf18 void} setEntityPosition({\cf17 const} std::string& strName, {\cf18 int} iNewPosX, {\cf18 int} iNewPosY);\par
00134 \par
00140         {\cf18 void} getEntityPosition({\cf17 const} std::string& strName, {\cf18 int} &iPosX, {\cf18 int} &iPosY) {\cf17 const};\par
00141 \par
00145         std::vector<CQuadTreeNode*> getNodesWithEntities({\cf18 void}) {\cf17 const};\par
00146 \par
00151         std::vector<CQuadTreeNode*> getNodesWithEntitiesWhichIntersect({\cf17 const} CRect& rect) {\cf17 const};\par
00152 \par
00162         std::vector<CQuadTreeEntity*> getEntitiesWithinRange({\cf18 int} iPosX, {\cf18 int} iPosY, {\cf18 int} iRange) {\cf17 const};\par
00163 \par
00171         std::vector<CQuadTreeEntity*> getEntitiesWithinRect({\cf17 const} CRect& rect) {\cf17 const};\par
00172 \par
00183         {\cf18 unsigned} {\cf18 int} getNodeDepthCurrent({\cf18 void});\par
00184 \par
00196         {\cf18 unsigned} {\cf18 int} getNodeDepthMax({\cf18 void}) {\cf17 const};\par
00197 \par
00198     {\cf17 private}:\par
00200         CQuadTreeNode* _mpRootNode;\par
00201 \par
00205         {\cf18 int} _miMaxEntitiesPerNode;\par
00206 \par
00212         {\cf18 int} _miRectSizeIncreaseMultiplier;\par
00213 \par
00217         {\cf17 mutable} std::map<std::string, CQuadTreeEntity*> _mmapEntities;\par
00218 \par
00227         {\cf18 unsigned} {\cf18 int} _muiCurrentMaxNodeDepth;\par
00228 \par
00238         {\cf18 unsigned} {\cf18 int} _muiMaxNodeDepth;\par
00239 \par
00241         {\cf18 void} _computeMaxNodeDepth({\cf18 void});\par
00242     \};\par
00243 \par
00244 \}   {\cf20 // namespace DCL}\par
00245 \par
00246 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QuadTreeEntity.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeEntity.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeEntity.cpp}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "QuadTreeEntity.h"}\par
00002 {\cf21 #include "QuadTreeNode.h"}\par
00003 \par
00004 {\cf17 namespace }DCL\par
00005 \{\par
00006     CQuadTreeEntity::CQuadTreeEntity({\cf17 const} std::string& strName, {\cf18 int} iPosX, {\cf18 int} iPosY, CQuadTreeNode* pNodeOwner, {\cf18 int} iUserData, {\cf18 void}* pUserData)\par
00007     \{\par
00008         _mstrName = strName;\par
00009         _miPosX = iPosX;\par
00010         _miPosY = iPosY;\par
00011         _mpNodeOwner = pNodeOwner;\par
00012 \par
00013         {\cf20 // Store user data}\par
00014         miUserData = iUserData;\par
00015         mpUserData = pUserData;\par
00016     \}\par
00017 \par
00018     {\cf20 /*}\par
00019 {\cf20     void CQuadTreeEntity::debugSetColour(CColour& colour)}\par
00020 {\cf20     \{}\par
00021 {\cf20         _mColDebug = colour;}\par
00022 {\cf20     \}}\par
00023 {\cf20     */}\par
00024 \par
00025     CVector2f CQuadTreeEntity::getPosition({\cf18 void})\par
00026     \{\par
00027         CVector2f v;\par
00028         v.x = float(_miPosX);\par
00029         v.y = float(_miPosY);\par
00030         {\cf19 return} v;\par
00031     \}\par
00032 \par
00033     std::string CQuadTreeEntity::getName({\cf18 void})\par
00034     \{\par
00035         {\cf19 return} _mstrName;\par
00036     \}\par
00037 \par
00038 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeEntity.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeEntity.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeEntity.h}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../Math/Vector2f.h"}\par
{\f2 #include "../Core/Colourf.h"}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CQuadTreeEntity}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An entity which is assigned into a {\b CQuadTreeNode}. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b QuadTreeEntity.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QuadTreeEntity.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeEntity.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeEntity.h}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef QUADTREEENTITY_H}\par
00007 {\cf21 #define QUADTREEENTITY_H}\par
00008 \par
00009 {\cf21 #include "../Math/Vector2f.h"}\par
00010 {\cf21 #include "../Core/Colourf.h"}\par
00011 \par
00012 {\cf21 #include <string>}\par
00013 \par
00014 {\cf17 namespace }DCL\par
00015 \{\par
00016     {\cf17 class }CQuadTreeNode;\par
00017 \par
00021     {\cf17 class }CQuadTreeEntity\par
00022     \{\par
00023         {\cf17 friend} {\cf17 class }CQuadTree;\par
00024         {\cf17 friend} {\cf17 class }CQuadTreeNode;\par
00025     {\cf17 public}:\par
00034         CQuadTreeEntity({\cf17 const} std::string& strName, {\cf18 int} iPosX, {\cf18 int} iPosY, CQuadTreeNode* pNodeOwner, {\cf18 int} iUserData = 0, {\cf18 void} *pUserData = 0);\par
00035 \par
00037 {\cf20 //      void debugSetColour(CColour& colour);}\par
00038 \par
00042         CVector2f getPosition({\cf18 void});\par
00043 \par
00047         std::string getName({\cf18 void});\par
00048 \par
00049         {\cf20 // Below are members which may be set to store various information.}\par
00050         {\cf20 // They have nothing to do with the quad tree itself.}\par
00051         {\cf18 int} miUserData;         \par
00052         {\cf18 void}* mpUserData;       \par
00053 \par
00054     {\cf17 private}:\par
00055         std::string _mstrName;          \par
00056         {\cf18 int} _miPosX;                    \par
00057         {\cf18 int} _miPosY;                    \par
00058         CQuadTreeNode* _mpNodeOwner;    \par
00059 {\cf20 //      CColour _mColDebug;             ///< The colour used when debug rendering this entity}\par
00060     \};\par
00061 \par
00062 \}   {\cf20 // namespace DCL}\par
00063 \par
00064 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QuadTreeNode.cpp\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeNode.cpp}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeNode.cpp}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "QuadTreeNode.h"}\par
00002 {\cf21 #include "../Core/Exceptions.h"}\par
00003 {\cf21 #include "QuadTree.h"}\par
00004 \par
00005 {\cf17 namespace }DCL\par
00006 \{\par
00007     CQuadTreeNode::CQuadTreeNode({\cf17 const} CRect& rectRegion, CQuadTreeNode* pParentNode, CQuadTree* pQuadTree)\par
00008     \{\par
00009         _mRectRegion = rectRegion;\par
00010         _mpParentNode = pParentNode;\par
00011         _mpQuadTree = pQuadTree;\par
00012         {\cf20 // Is this the root node?}\par
00013         {\cf19 if} (!pParentNode)\par
00014             _muiNodeDepth = 0;\par
00015         {\cf19 else}\par
00016             _muiNodeDepth = pParentNode->_muiNodeDepth + 1;\par
00017 \par
00018         {\cf19 if} (_muiNodeDepth > pQuadTree->_muiCurrentMaxNodeDepth)\par
00019             pQuadTree->_muiCurrentMaxNodeDepth = _muiNodeDepth;\par
00020 \par
00021         {\cf20 // No children yet}\par
00022         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00023             _mpChildNode[i] = 0;\par
00024     \}\par
00025 \par
00026     CQuadTreeNode::~CQuadTreeNode()\par
00027     \{\par
00028         {\cf20 // Destroy each child node}\par
00029         {\cf20 // This will recursively call each child node's destructor}\par
00030         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00031         \{\par
00032             {\cf20 // If child node exists}\par
00033             {\cf19 if} (_mpChildNode[i])\par
00034                 {\cf17 delete} _mpChildNode[i];\par
00035         \}\par
00036     \}\par
00037 \par
00038     {\cf20 /*}\par
00039 {\cf20     void CQuadTreeNode::debugRenderNodes(CResourceVertexBufferLine* pLine, CResourceVertexBufferLine::Vertex& vertex, CColour colour) const}\par
00040 {\cf20     \{}\par
00041 {\cf20         // Compute colour}\par
00042 {\cf20         float fDepthCol = (float)_mpQuadTree->_muiMaxNodeDepth - float(_muiNodeDepth);}\par
00043 {\cf20         fDepthCol /= (float)_mpQuadTree->_muiMaxNodeDepth;}\par
00044 {\cf20         clamp(fDepthCol, 0.1f, 1.0f);}\par
00045 {\cf20         vertex.colour = colour;}\par
00046 {\cf20         vertex.colour.alpha = fDepthCol;}\par
00047 {\cf20 }\par
00048 {\cf20         // Render this node's four edges}\par
00049 {\cf20         // Left}\par
00050 {\cf20         vertex.position.set((float)_mRectRegion.miMinX, (float)_mRectRegion.miMinY, 0.0f);  pLine->addLinePoint(vertex);}\par
00051 {\cf20         vertex.position.set((float)_mRectRegion.miMinX, (float)_mRectRegion.miMaxY, 0.0f);  pLine->addLinePoint(vertex);}\par
00052 {\cf20         // Right}\par
00053 {\cf20         vertex.position.set((float)_mRectRegion.miMaxX, (float)_mRectRegion.miMinY, 0.0f);  pLine->addLinePoint(vertex);}\par
00054 {\cf20         vertex.position.set((float)_mRectRegion.miMaxX, (float)_mRectRegion.miMaxY, 0.0f);  pLine->addLinePoint(vertex);}\par
00055 {\cf20         // Top}\par
00056 {\cf20         vertex.position.set((float)_mRectRegion.miMinX, (float)_mRectRegion.miMaxY, 0.0f);  pLine->addLinePoint(vertex);}\par
00057 {\cf20         vertex.position.set((float)_mRectRegion.miMaxX, (float)_mRectRegion.miMaxY, 0.0f);  pLine->addLinePoint(vertex);}\par
00058 {\cf20         // Bottom}\par
00059 {\cf20         vertex.position.set((float)_mRectRegion.miMinX, (float)_mRectRegion.miMinY, 0.0f);  pLine->addLinePoint(vertex);}\par
00060 {\cf20         vertex.position.set((float)_mRectRegion.miMaxX, (float)_mRectRegion.miMinY, 0.0f);  pLine->addLinePoint(vertex);}\par
00061 {\cf20 }\par
00062 {\cf20         // Render child nodes if they exist}\par
00063 {\cf20         if (_mpChildNode[ChildNode::BL])}\par
00064 {\cf20         \{}\par
00065 {\cf20             colour.set(0, 0, 1, 1);}\par
00066 {\cf20             _mpChildNode[ChildNode::BL]->debugRenderNodes(pLine, vertex, colour);}\par
00067 {\cf20         \}}\par
00068 {\cf20         if (_mpChildNode[ChildNode::BR])}\par
00069 {\cf20         \{}\par
00070 {\cf20             colour.set(1, 1, 0, 1);}\par
00071 {\cf20             _mpChildNode[ChildNode::BR]->debugRenderNodes(pLine, vertex, colour);}\par
00072 {\cf20         \}}\par
00073 {\cf20         if (_mpChildNode[ChildNode::TL])}\par
00074 {\cf20         \{}\par
00075 {\cf20             colour.set(1, 0, 0, 1);}\par
00076 {\cf20             _mpChildNode[ChildNode::TL]->debugRenderNodes(pLine, vertex, colour);}\par
00077 {\cf20         \}}\par
00078 {\cf20         if (_mpChildNode[ChildNode::TR])}\par
00079 {\cf20         \{}\par
00080 {\cf20             colour.set(0, 1, 0, 1);}\par
00081 {\cf20             _mpChildNode[ChildNode::TR]->debugRenderNodes(pLine, vertex, colour);}\par
00082 {\cf20         \}}\par
00083 {\cf20     \}}\par
00084 {\cf20     */}\par
00085 \par
00086     {\cf20 /*}\par
00087 {\cf20     void CQuadTreeNode::debugRenderEntities(CResourceVertexBufferLine* pLine, int iCircleRadius, unsigned int uiCircleNumSegments) const}\par
00088 {\cf20     \{}\par
00089 {\cf20         // For each entity in this node}\par
00090 {\cf20         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.begin();}\par
00091 {\cf20         while (it != _mmapEntities.end())}\par
00092 {\cf20         \{}\par
00093 {\cf20             pLine->addCircle(it->second->_miPosX, it->second->_miPosY, (float)iCircleRadius, uiCircleNumSegments, it->second->_mColDebug);}\par
00094 {\cf20             it++;}\par
00095 {\cf20         \}}\par
00096 {\cf20 }\par
00097 {\cf20         // Render child nodes if they exist}\par
00098 {\cf20         for (int i = 0; i < 4; i++)}\par
00099 {\cf20         \{}\par
00100 {\cf20             if (_mpChildNode[i])}\par
00101 {\cf20                 _mpChildNode[i]->debugRenderEntities(pLine, iCircleRadius, uiCircleNumSegments);}\par
00102 {\cf20         \}}\par
00103 {\cf20     \}}\par
00104 {\cf20     */}\par
00105 \par
00106     {\cf18 bool} CQuadTreeNode::hasChildNode(ChildNode childNode){\cf17  const}\par
00107 {\cf17     }\{\par
00108         {\cf19 return} _mpChildNode[childNode];\par
00109     \}\par
00110 \par
00111     {\cf18 bool} CQuadTreeNode::hasAnyChildNodes({\cf18 void}){\cf17  const}\par
00112 {\cf17     }\{\par
00113         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00114         \{\par
00115             {\cf19 if} (_mpChildNode[i])\par
00116                 {\cf19 return} {\cf17 true};\par
00117         \}\par
00118         {\cf19 return} {\cf17 false};\par
00119     \}\par
00120 \par
00121     {\cf18 bool} CQuadTreeNode::hasEntitiesInThisAndAllChildren({\cf18 void}){\cf17  const}\par
00122 {\cf17     }\{\par
00123         {\cf20 // If this node has entities in}\par
00124         {\cf19 if} (_mmapEntities.size() > 0)\par
00125             {\cf19 return} {\cf17 true};\par
00126 \par
00127         {\cf20 // Now recursively go through any existing child nodes}\par
00128         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00129         \{\par
00130             {\cf20 // If node exists}\par
00131             {\cf19 if} (_mpChildNode[i])\par
00132             \{\par
00133                 {\cf19 if} (_mpChildNode[i]->hasEntitiesInThisAndAllChildren())\par
00134                     {\cf19 return} {\cf17 true};\par
00135             \}\par
00136         \}\par
00137 \par
00138         {\cf20 // If we get here, this node has no entities and neither does any of it's children nodes}\par
00139         {\cf19 return} {\cf17 false};\par
00140     \}\par
00141 \par
00142     {\cf18 void} CQuadTreeNode::createChildNode(ChildNode childNode)\par
00143     \{\par
00144         {\cf19 if} (hasChildNode(childNode))\par
00145             {\cf19 return};\par
00146 \par
00147         {\cf20 // Compute rect area of the new child node}\par
00148         CRect childNodeRect = computeChildNodeRegion(childNode);\par
00149 \par
00150         _mpChildNode[childNode] = {\cf17 new} CQuadTreeNode(childNodeRect, {\cf17 this}, _mpQuadTree);\par
00151         ThrowIfFalse(_mpChildNode[childNode], {\cf22 "CQuadTreeNode::createChildNode() failed. Unable to allocate memory for the new child node."});\par
00152     \}\par
00153 \par
00154     CRect CQuadTreeNode::computeChildNodeRegion(ChildNode childNode){\cf17  const}\par
00155 {\cf17     }\{\par
00156         {\cf20 // Compute dimensions of new child node using the rect region of this parent node.}\par
00157         {\cf18 int} iChildDimsX = _mRectRegion.miMaxX - _mRectRegion.miMinX;\par
00158         {\cf18 int} iChildDimsY = _mRectRegion.miMaxY - _mRectRegion.miMinY;\par
00159         iChildDimsX /= 2;\par
00160         iChildDimsY /= 2;\par
00161 \par
00162         {\cf20 // Calculate region of the child node}\par
00163         CRect childNodeRegion;\par
00164         {\cf19 switch} (childNode)\par
00165         \{\par
00166         {\cf19 case} ChildNode::BL:\par
00167             childNodeRegion.miMinX = _mRectRegion.miMinX;\par
00168             childNodeRegion.miMaxX = _mRectRegion.miMinX + iChildDimsX;\par
00169             childNodeRegion.miMinY = _mRectRegion.miMinY;\par
00170             childNodeRegion.miMaxY = _mRectRegion.miMinY + iChildDimsY;\par
00171             {\cf19 break};\par
00172         {\cf19 case} ChildNode::BR:\par
00173             childNodeRegion.miMinX = _mRectRegion.miMinX + iChildDimsX;\par
00174             childNodeRegion.miMaxX = _mRectRegion.miMaxX;\par
00175             childNodeRegion.miMinY = _mRectRegion.miMinY;\par
00176             childNodeRegion.miMaxY = _mRectRegion.miMinY + iChildDimsY;\par
00177             {\cf19 break};\par
00178         {\cf19 case} ChildNode::TL:\par
00179             childNodeRegion.miMinX = _mRectRegion.miMinX;\par
00180             childNodeRegion.miMaxX = _mRectRegion.miMinX + iChildDimsX;\par
00181             childNodeRegion.miMinY = _mRectRegion.miMinY + iChildDimsY;\par
00182             childNodeRegion.miMaxY = _mRectRegion.miMaxY;\par
00183             {\cf19 break};\par
00184         {\cf19 case} ChildNode::TR:\par
00185             childNodeRegion.miMinX = _mRectRegion.miMinX + iChildDimsX;\par
00186             childNodeRegion.miMaxX = _mRectRegion.miMaxX;\par
00187             childNodeRegion.miMinY = _mRectRegion.miMinY + iChildDimsY;\par
00188             childNodeRegion.miMaxY = _mRectRegion.miMaxY;\par
00189             {\cf19 break};\par
00190         {\cf19 default}:\par
00191             ThrowIfTrue(1, {\cf22 "CQuadTreeNode::computeChildNodeRegion() given invalid ChildNode to compute it's region."});\par
00192         \}\par
00193         {\cf19 return} childNodeRegion;\par
00194     \}\par
00195 \par
00196     {\cf18 void} CQuadTreeNode::addEntity(CQuadTreeEntity* pEntity)\par
00197     \{\par
00198         {\cf20 // If this node has no children, attempt to add the entity to this node}\par
00199         {\cf19 if} (!hasAnyChildNodes())\par
00200         \{\par
00201             {\cf20 // We haven't reached max capacity for this node}\par
00202             {\cf20 // OR we've reached maximum node depth with this node}\par
00203             {\cf19 if} (_mmapEntities.size() < _mpQuadTree->_miMaxEntitiesPerNode ||\par
00204                 _muiNodeDepth == _mpQuadTree->_muiMaxNodeDepth)\par
00205             \{\par
00206                 {\cf20 // Add the entity to this node}\par
00207                 {\cf20 // No need to check if the new entity name already exists, as CQuadTree::addEntity() has already checked}\par
00208                 _mmapEntities[pEntity->_mstrName] = pEntity;\par
00209                 pEntity->_mpNodeOwner = {\cf17 this};   {\cf20 // Set node owner for the entity}\par
00210                 {\cf19 return};\par
00211             \}\par
00212             {\cf20 // If we've reached maximum capacity for this node and max node depth hasn't been reached}\par
00213             {\cf19 if} (_mmapEntities.size() == _mpQuadTree->_miMaxEntitiesPerNode)\par
00214             \{\par
00215                 {\cf20 // We need to create child node/s then move all the entities from this node into the children, }\par
00216                 {\cf20 // as well as the new entity}\par
00217 \par
00218                 {\cf20 // Compute potential child node rects}\par
00219                 CRect rctBL = computeChildNodeRegion(ChildNode::BL);\par
00220                 CRect rctBR = computeChildNodeRegion(ChildNode::BR);\par
00221                 CRect rctTL = computeChildNodeRegion(ChildNode::TL);\par
00222                 CRect rctTR = computeChildNodeRegion(ChildNode::TR);\par
00223 \par
00224                 {\cf20 // Add the new entity to this node's entity map, so it'll be moved to the correct child node below}\par
00225                 _mmapEntities[pEntity->_mstrName] = pEntity;\par
00226                 pEntity->_mpNodeOwner = {\cf17 this};   {\cf20 // Set node owner for the entity}\par
00227 \par
00228                 {\cf20 // Move all the entities from this node, into the child nodes}\par
00229                 std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.begin();\par
00230                 {\cf19 while} (it != _mmapEntities.end())\par
00231                 \{\par
00232                     {\cf20 // Determine which child node the entity fits in, regardless of whether the child node exists or not}\par
00233                     ChildNode childNode = ChildNode::NONE;\par
00234                     {\cf19 if} (rctBL.doesPositionFitWithin(it->second->_miPosX, it->second->_miPosY))\par
00235                         childNode = ChildNode::BL;\par
00236                     {\cf19 else} {\cf19 if} (rctBR.doesPositionFitWithin(it->second->_miPosX, it->second->_miPosY))\par
00237                         childNode = ChildNode::BR;\par
00238                     {\cf19 else} {\cf19 if} (rctTL.doesPositionFitWithin(it->second->_miPosX, it->second->_miPosY))\par
00239                         childNode = ChildNode::TL;\par
00240                     {\cf19 else} {\cf19 if} (rctTR.doesPositionFitWithin(it->second->_miPosX, it->second->_miPosY))\par
00241                         childNode = ChildNode::TR;\par
00242 \par
00243                     {\cf20 // Error checking, making sure the entity could fit in one of the four possible children}\par
00244                     ThrowIfTrue(ChildNode::NONE == childNode, {\cf22 "CQuadTreeNode::addEntity() failed when trying to add entity "} + it->second->_mstrName + {\cf22 " to any of the four child nodes as it's position doesn't fit inside any of them."});\par
00245 \par
00246                     {\cf20 // Create the child node if it doesn't exist}\par
00247                     {\cf19 if} (!_mpChildNode[childNode])\par
00248                     \{\par
00249                         _mpChildNode[childNode] = {\cf17 new} CQuadTreeNode(computeChildNodeRegion(childNode), {\cf17 this}, _mpQuadTree);\par
00250                         ThrowIfFalse(_mpChildNode[childNode], {\cf22 "CQuadTreeNode::addEntity() failed when trying to add entity "} + it->second->_mstrName + {\cf22 " to any of the four child nodes as it was unable to allocate memory for the child node."});\par
00251                     \}\par
00252                     _mpChildNode[childNode]->addEntity(it->second);\par
00253                     it++;\par
00254                 \}\par
00255                 {\cf20 // Remove all entities from this node as they are now stored in the children}\par
00256                 _mmapEntities.clear();\par
00257                 {\cf19 return};\par
00258             \}\par
00259         \}\par
00260 \par
00261         {\cf20 // If we get here, then this node has children, so add the new entity to one of those...}\par
00262         {\cf20 // Determine which child node the entity fits in}\par
00263         {\cf20 // Compute potential child node rects}\par
00264         CRect rctBL = computeChildNodeRegion(ChildNode::BL);\par
00265         CRect rctBR = computeChildNodeRegion(ChildNode::BR);\par
00266         CRect rctTL = computeChildNodeRegion(ChildNode::TL);\par
00267         CRect rctTR = computeChildNodeRegion(ChildNode::TR);\par
00268 \par
00269         ChildNode childNode = ChildNode::NONE;\par
00270         {\cf19 if} (rctBL.doesPositionFitWithin(pEntity->_miPosX, pEntity->_miPosY))\par
00271             childNode = ChildNode::BL;\par
00272         {\cf19 else} {\cf19 if} (rctBR.doesPositionFitWithin(pEntity->_miPosX, pEntity->_miPosY))\par
00273             childNode = ChildNode::BR;\par
00274         {\cf19 else} {\cf19 if} (rctTL.doesPositionFitWithin(pEntity->_miPosX, pEntity->_miPosY))\par
00275             childNode = ChildNode::TL;\par
00276         {\cf19 else} {\cf19 if} (rctTR.doesPositionFitWithin(pEntity->_miPosX, pEntity->_miPosY))\par
00277             childNode = ChildNode::TR;\par
00278         {\cf20 // Error checking, making sure the entity could fit in one of the four possible children}\par
00279         ThrowIfTrue(ChildNode::NONE == childNode, {\cf22 "CQuadTreeNode::addEntity() failed when trying to add entity "} + pEntity->_mstrName + {\cf22 " to any of the four child nodes as it's position doesn't fit inside any of them."});\par
00280 \par
00281         {\cf20 // Create the child node if it doesn't exist}\par
00282         {\cf19 if} (!_mpChildNode[childNode])\par
00283         \{\par
00284             _mpChildNode[childNode] = {\cf17 new} CQuadTreeNode(computeChildNodeRegion(childNode), {\cf17 this}, _mpQuadTree);\par
00285             ThrowIfFalse(_mpChildNode[childNode], {\cf22 "CQuadTreeNode::addEntity() failed when trying to add entity "} + pEntity->_mstrName + {\cf22 " to any of the four child nodes as it was unable to allocate memory for the child node."});\par
00286         \}\par
00287 \par
00288         {\cf20 // Add the new entity}\par
00289         _mpChildNode[childNode]->addEntity(pEntity);\par
00290     \}\par
00291 \par
00292     {\cf18 void} CQuadTreeNode::removeEntity(CQuadTreeEntity* pEntity)\par
00293     \{\par
00294         {\cf20 // Attempt to find the entity}\par
00295         std::map<std::string, CQuadTreeEntity*>::iterator it = _mmapEntities.find(pEntity->_mstrName);\par
00296         ThrowIfTrue(it == _mmapEntities.end(), {\cf22 "CQuadTreeNode::removeEntity() failed. The entity named "} + pEntity->_mstrName + {\cf22 " could not be found"});\par
00297         _mmapEntities.erase(it);\par
00298         {\cf20 // No need to delete entity, the CQuadTree::removeAllEntities() or CQuadTree::removeEntity() does this}\par
00299     \}\par
00300 \par
00301     {\cf18 void} CQuadTreeNode::getNodesWithEntities(std::vector<CQuadTreeNode*>& vecNodes)\par
00302     \{\par
00303         {\cf20 // If this node doesn't have any children, just check this node}\par
00304         {\cf19 if} (!hasAnyChildNodes())\par
00305         \{\par
00306             {\cf20 // If this node doesn't have any entities}\par
00307             {\cf19 if} (0 == _mmapEntities.size())\par
00308                 {\cf19 return};\par
00309 \par
00310             {\cf20 // Add this node}\par
00311             vecNodes.push_back({\cf17 this});\par
00312             {\cf19 return};\par
00313         \}\par
00314         {\cf19 else}  {\cf20 // This node has children, check those}\par
00315         \{\par
00316             {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00317             \{\par
00318                 {\cf19 if} (_mpChildNode[i])\par
00319                     _mpChildNode[i]->getNodesWithEntities(vecNodes);\par
00320             \}\par
00321         \}\par
00322     \}\par
00323 \par
00324     {\cf18 void} CQuadTreeNode::getNodesWithEntitiesWhichIntersect(std::vector<CQuadTreeNode*>& vecNodes, {\cf17 const} CRect& rect)\par
00325     \{\par
00326         {\cf20 // If this node doesn't have any children, just check this node}\par
00327         {\cf19 if} (!hasAnyChildNodes())\par
00328         \{\par
00329             {\cf20 // If this node doesn't have any entities}\par
00330             {\cf19 if} (0 == _mmapEntities.size())\par
00331                 {\cf19 return};\par
00332 \par
00333             {\cf20 // If the rect interects with this node, add this node}\par
00334             {\cf19 if} (_mRectRegion.intersects(rect))\par
00335             \{\par
00336                 vecNodes.push_back({\cf17 this});\par
00337                 {\cf19 return};\par
00338             \}\par
00339         \}\par
00340         {\cf19 else}  {\cf20 // This node has children, check those}\par
00341         \{\par
00342             {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00343             \{\par
00344                 {\cf19 if} (_mpChildNode[i])\par
00345                     _mpChildNode[i]->getNodesWithEntitiesWhichIntersect(vecNodes, rect);\par
00346             \}\par
00347         \}\par
00348     \}\par
00349 \par
00350     {\cf18 void} CQuadTreeNode::getMaxNodeDepth({\cf18 unsigned} {\cf18 int}& uiMaxNodeDepth)\par
00351     \{\par
00352         {\cf19 if} (_muiNodeDepth > uiMaxNodeDepth)\par
00353             uiMaxNodeDepth = _muiNodeDepth;\par
00354 \par
00355         {\cf20 // Call this method for all children of this node}\par
00356         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00357         \{\par
00358             {\cf19 if} (_mpChildNode[i])    {\cf20 // If child exists}\par
00359                 _mpChildNode[i]->getMaxNodeDepth(uiMaxNodeDepth);\par
00360         \}\par
00361     \}\par
00362 \par
00363 \}   {\cf20 // namespace DCL}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeNode.h File Reference\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeNode.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeNode.h}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../Math/Rect.h"}\par
{\f2 #include "QuadTreeEntity.h"}\par
{\f2 #include <map>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCL::CQuadTreeNode}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A node used by the {\b CQuadTree} class. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b DCL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace in which everything within Dave's Code Library is stored inside. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brief description for the file goes here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detailed description text goes here. \par
}{
Definition in file {\b QuadTreeNode.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QuadTreeNode.h\par \pard\plain 
{\tc\tcl2 \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeNode.h}
{\xe \v X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/SpatialPartitioning/QuadTreeNode.h}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 \par
00006 {\cf21 #ifndef QUADTREENODE_H}\par
00007 {\cf21 #define QUADTREENODE_H}\par
00008 \par
00009 {\cf21 #include "../Math/Rect.h"}\par
00010 {\cf21 #include "QuadTreeEntity.h"}\par
00011 {\cf20 //#include "resourceManager.h"}\par
00012 \par
00013 {\cf21 #include <map>}\par
00014 {\cf21 #include <vector>}\par
00015 \par
00016 {\cf17 namespace }DCL\par
00017 \{\par
00018     {\cf17 class }CQuadTree;\par
00019 \par
00021     {\cf17 class }CQuadTreeNode\par
00022     \{\par
00023         {\cf17 friend} {\cf17 class }CQuadTree;\par
00024     {\cf17 public}:\par
00026         {\cf17 enum} ChildNode\par
00027         \{\par
00028             BL, \par
00029             BR, \par
00030             TL, \par
00031             TR, \par
00032             NONE\par
00033         \};\par
00034 \par
00044         CQuadTreeNode({\cf17 const} CRect& rectRegion, CQuadTreeNode* pParentNode, CQuadTree* pQuadTree);\par
00045 \par
00052         ~CQuadTreeNode();\par
00053 \par
00058 {\cf20 //      void debugRenderNodes(CResourceVertexBufferLine* pLine, CResourceVertexBufferLine::Vertex& vertex, CColour colour) const;}\par
00059 \par
00063 {\cf20 //      void debugRenderEntities(CResourceVertexBufferLine* pLine, int iCircleRadius, unsigned int uiCircleNumSegments) const;}\par
00064 \par
00069         {\cf18 bool} hasChildNode(ChildNode childNode) {\cf17 const};\par
00070 \par
00074         {\cf18 bool} hasAnyChildNodes({\cf18 void}) {\cf17 const};\par
00075 \par
00079         {\cf18 bool} hasEntitiesInThisAndAllChildren({\cf18 void}) {\cf17 const};\par
00080 \par
00086         {\cf18 void} createChildNode(ChildNode childNode);\par
00087 \par
00092         CRect computeChildNodeRegion(ChildNode childNode) {\cf17 const};\par
00093 \par
00097         {\cf18 void} addEntity(CQuadTreeEntity* pEntity);\par
00098 \par
00104         {\cf18 void} removeEntity(CQuadTreeEntity* pEntity);\par
00105 \par
00109         {\cf18 void} getNodesWithEntities(std::vector<CQuadTreeNode*>& vecNodes);\par
00110 \par
00115         {\cf18 void} getNodesWithEntitiesWhichIntersect(std::vector<CQuadTreeNode*>& vecNodes, {\cf17 const} CRect& rect);\par
00116 \par
00120         {\cf18 void} getMaxNodeDepth({\cf18 unsigned} {\cf18 int}& uiMaxNodeDepth);\par
00121     {\cf17 private}:\par
00124         CRect _mRectRegion;\par
00125 \par
00126         {\cf20 // \\brief Pointer to the parent of this node. May be 0 if this is the root node}\par
00127         CQuadTreeNode* _mpParentNode;\par
00128 \par
00129         {\cf20 // \\brief Pointer to the four possible child nodes.}\par
00130         {\cf20 // A pointer may be 0 for no child node allocated yet.}\par
00131         {\cf20 // Use the ChildNode enum with this array to access the correct child node.}\par
00132         CQuadTreeNode* _mpChildNode[4];\par
00133 \par
00134         {\cf20 // \\brief The quad tree which owns this node, this is passed to the constructor}\par
00135         CQuadTree* _mpQuadTree;\par
00136 \par
00140         {\cf18 unsigned} {\cf18 int} _muiNodeDepth;\par
00141 \par
00142         {\cf20 // \\brief Hashmap holding pointers to each of the added entities, until}\par
00143         {\cf20 // this node has children, in which case this would be empty as }\par
00144         {\cf20 // the child nodes now own the entities (or their siblings)}\par
00145         {\cf17 mutable} std::map<std::string, CQuadTreeEntity*> _mmapEntities;\par
00146     \};\par
00147 \par
00148 \}   {\cf20 // namespace DCL}\par
00149 \par
00150 {\cf21 #endif  }{\cf20 // #ifndef FILENAME_H}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
