<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Daves Coding Paradise: DCL::CGeneticsTraining Class Reference</title>
<link rel="icon" href="DCP_icon.PNG" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="DCP_logo.PNG"/></td>
  <td id="projectalign">
   <div id="projectname">Daves Coding Paradise<span id="projectnumber">&#160;0.1.1</span>
   </div>
   <div id="projectbrief">Daves Coding Paradise</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_d_c_l_1_1_c_genetics_training.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_d_c_l_1_1_c_genetics_training-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DCL::CGeneticsTraining Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This is the genetics training class which is used with the neural network class to train the weights of that class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_genetic_algorithm_8h_source.html">GeneticAlgorithm.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa71e55bb08e663caee2df9d78879dc2" id="r_aaa71e55bb08e663caee2df9d78879dc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa71e55bb08e663caee2df9d78879dc2">rouletteWheelSelection</a> (const std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;vecPopulation) const</td></tr>
<tr class="memdesc:aaa71e55bb08e663caee2df9d78879dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of CGenomes representing a all the neural networks and their fitness of an entire population, performs roulette wheel selection and returns a selected <a class="el" href="class_d_c_l_1_1_c_genome.html" title="This is used with the CGeneticsTraining class with methods which are used to create an entire new pop...">CGenome</a>.  <br /></td></tr>
<tr class="separator:aaa71e55bb08e663caee2df9d78879dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8833ee8a01f48bfcbc550459eba171" id="r_a5e8833ee8a01f48bfcbc550459eba171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e8833ee8a01f48bfcbc550459eba171">computeFitness</a> (const std::vector&lt; double &gt; &amp;vecPopulationFitness, double &amp;dWorstFitness, double &amp;dAverageFitness, double &amp;dBestFitness, double &amp;dTotalFitness) const</td></tr>
<tr class="memdesc:a5e8833ee8a01f48bfcbc550459eba171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of doubles representing the fitness of each member within a population, calculates the best, worst, average and total fitness of the population and stores those results in the given variables.  <br /></td></tr>
<tr class="separator:a5e8833ee8a01f48bfcbc550459eba171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25431b91819454ea535cf1657c7fe27" id="r_af25431b91819454ea535cf1657c7fe27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af25431b91819454ea535cf1657c7fe27">computeFitness</a> (const std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;vecPopulation, double &amp;dWorstFitness, double &amp;dAverageFitness, double &amp;dBestFitness, double &amp;dTotalFitness) const</td></tr>
<tr class="memdesc:af25431b91819454ea535cf1657c7fe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of <a class="el" href="class_d_c_l_1_1_c_genome.html" title="This is used with the CGeneticsTraining class with methods which are used to create an entire new pop...">CGenome</a> objects, calculates the best, worst, average and total fitness of the population and stores those results in the given variables.  <br /></td></tr>
<tr class="separator:af25431b91819454ea535cf1657c7fe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6010e749b9bd8096f2f0a33f5b76bb" id="r_abb6010e749b9bd8096f2f0a33f5b76bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb6010e749b9bd8096f2f0a33f5b76bb">crossover</a> (std::vector&lt; double &gt; &amp;vecMumWeights, std::vector&lt; double &gt; &amp;vecDadWeights, std::vector&lt; double &gt; &amp;vecChildAWeights, std::vector&lt; double &gt; &amp;vecChildBWeights, double dCrossoverRate=0.7) const</td></tr>
<tr class="memdesc:abb6010e749b9bd8096f2f0a33f5b76bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the weights of two networks (the parents), performs a basic crossover of their weights and creates two child network weights from them.  <br /></td></tr>
<tr class="separator:abb6010e749b9bd8096f2f0a33f5b76bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279fd1e029073c82def71be183bf413f" id="r_a279fd1e029073c82def71be183bf413f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a279fd1e029073c82def71be183bf413f">crossoverBetweenNeurons</a> (std::vector&lt; double &gt; &amp;vecMumWeights, std::vector&lt; double &gt; &amp;vecDadWeights, std::vector&lt; double &gt; &amp;vecChildAWeights, std::vector&lt; double &gt; &amp;vecChildBWeights, const std::vector&lt; int &gt; &amp;vecSplitPoints, double dCrossoverRate=0.7) const</td></tr>
<tr class="memdesc:a279fd1e029073c82def71be183bf413f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the weights of two networks (the parents), performs a crossover of their weights between each neuron and creates two child network weights from them.  <br /></td></tr>
<tr class="separator:a279fd1e029073c82def71be183bf413f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee030498322a0bbdc8e4d6632d6732d4" id="r_aee030498322a0bbdc8e4d6632d6732d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee030498322a0bbdc8e4d6632d6732d4">mutate</a> (std::vector&lt; double &gt; &amp;vecNetworkWeights, double dMutationProbability=0.001, double dMutationMaxAmount=0.3) const</td></tr>
<tr class="memdesc:aee030498322a0bbdc8e4d6632d6732d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the weights of a neural network, mutates them depending upon the given values.  <br /></td></tr>
<tr class="separator:aee030498322a0bbdc8e4d6632d6732d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f199db4716f1402a67413a9cdd8f87" id="r_ad1f199db4716f1402a67413a9cdd8f87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1f199db4716f1402a67413a9cdd8f87">insertElite</a> (std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;vecOldPop, std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;vecNewPop, int iNumberOfElite=2, int iNumCopiesOfEachElite=1) const</td></tr>
<tr class="memdesc:ad1f199db4716f1402a67413a9cdd8f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs elitism.  <br /></td></tr>
<tr class="separator:ad1f199db4716f1402a67413a9cdd8f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704ca44c67ed68d9eb1f5dcd1996c57c" id="r_a704ca44c67ed68d9eb1f5dcd1996c57c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a704ca44c67ed68d9eb1f5dcd1996c57c">createNewGeneration</a> (const std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;genomes, const std::vector&lt; int &gt; &amp;vecSplitsPoints, double dMutationProbability=0.001, double dMutationMaxAmount=0.3, double dCrossoverRate=0.7, int iNumberOfElite=2, int iNumCopiesOfEachElite=1) const</td></tr>
<tr class="memdesc:a704ca44c67ed68d9eb1f5dcd1996c57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of CGenomes holding each neural network and their fitness scores, generates and returns a vector of CGenomes which contain a new generation.  <br /></td></tr>
<tr class="separator:a704ca44c67ed68d9eb1f5dcd1996c57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the genetics training class which is used with the neural network class to train the weights of that class. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo</a></b></dt><dd>Re-read chapter five (Building a better genetic algorithm) of the "AI techniques for game programming" book to get some better methods </dd></dl>
<p>A neural network has weights for each of it's neurons and they need to be set to correct values, or trained, so that the network produces our desired behaviour.</p>
<p>The process goes like this... Say we wish to create a network which flees and enemy entity in a 2D world. We create a population of networks, say 100 of them, initially with random weights/genes. We then run the simulation, passing each network it's inputs, calculating their outputs and applying those outputs to each entity in the simulation. Whilst the simulation is running, we compute a fitness score for each network depending upon how it is performing. Increasing the fitness if it is doing what we want (It is far away from predators), reducing if not (It gets eaten). After a certain time has passed, this class then creates an entirely new generation of the population of networks from the existing population to run in the next run. This class uses the fitness of each network to determine how the new child networks are generated. This process repeats until, hopefully, most of the networks are performing well. We then take the best performing networks, save them out for loading into our program at a later date for use.</p>
<p>When creating the new generation of networks, there are a few ways this class can choose how to create the child population. It takes the networks from the best performing networks and use those as parents, to create children from their weights/genes. It also takes non-best performing networks too, to help keep the population's networks varies to allow for variation in behaviour which allows new behaviours to evolve in the population.</p>
<p>Typically, after a certain number of runs, the population's differences converge so that they all roughly have the same weights, but we don't want this to happen before an optimal behaviour has been found, so this class has ways of preventing this from happening too quickly.</p>
<p>There is mutation, which changes the genes/weights and may produce good behaviour, but may not. This helps diversify the population and create new behaviours. There is gene/weight crossover which determines which genes the children networks get from their parents. There are different types of crossover methods, each with subtly differences. </p>

<p class="definition">Definition at line <a class="el" href="_genetic_algorithm_8h_source.html#l00108">108</a> of file <a class="el" href="_genetic_algorithm_8h_source.html">GeneticAlgorithm.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af25431b91819454ea535cf1657c7fe27" name="af25431b91819454ea535cf1657c7fe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25431b91819454ea535cf1657c7fe27">&#9670;&#160;</a></span>computeFitness() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCL::CGeneticsTraining::computeFitness </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecPopulation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>dWorstFitness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>dAverageFitness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>dBestFitness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>dTotalFitness</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of <a class="el" href="class_d_c_l_1_1_c_genome.html" title="This is used with the CGeneticsTraining class with methods which are used to create an entire new pop...">CGenome</a> objects, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vecPopulation</td><td>Vector holding the genomes of an entire population </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dWorstFitness</td><td>Will hold the worst fitness found in all the fitness scores </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dAverageFitness</td><td>Will hold the average fitness computed from all the fitness scores </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dBestFitness</td><td>Will hold the best fitness found from all the fitness scores </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dTotalFitness</td><td>Will hold the accumulated total of all the fitness scores </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_genetic_algorithm_8cpp_source.html#l00095">95</a> of file <a class="el" href="_genetic_algorithm_8cpp_source.html">GeneticAlgorithm.cpp</a>.</p>

</div>
</div>
<a id="a5e8833ee8a01f48bfcbc550459eba171" name="a5e8833ee8a01f48bfcbc550459eba171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8833ee8a01f48bfcbc550459eba171">&#9670;&#160;</a></span>computeFitness() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCL::CGeneticsTraining::computeFitness </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecPopulationFitness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>dWorstFitness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>dAverageFitness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>dBestFitness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>dTotalFitness</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of doubles representing the fitness of each member within a population, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vecPopulationFitness</td><td>Vector holding the fitness score of each genome. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dWorstFitness</td><td>Will hold the worst fitness found in all the fitness scores </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dAverageFitness</td><td>Will hold the average fitness computed from all the fitness scores </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dBestFitness</td><td>Will hold the best fitness found from all the fitness scores </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dTotalFitness</td><td>Will hold the accumulated total of all the fitness scores </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_genetic_algorithm_8cpp_source.html#l00071">71</a> of file <a class="el" href="_genetic_algorithm_8cpp_source.html">GeneticAlgorithm.cpp</a>.</p>

</div>
</div>
<a id="a704ca44c67ed68d9eb1f5dcd1996c57c" name="a704ca44c67ed68d9eb1f5dcd1996c57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704ca44c67ed68d9eb1f5dcd1996c57c">&#9670;&#160;</a></span>createNewGeneration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; DCL::CGeneticsTraining::createNewGeneration </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>genomes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecSplitsPoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dMutationProbability</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.001</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dMutationMaxAmount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.3</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dCrossoverRate</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.7</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iNumberOfElite</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iNumCopiesOfEachElite</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of CGenomes holding each neural network and their fitness scores, generates and returns a vector of CGenomes which contain a new generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">genomes</td><td>A vector of <a class="el" href="class_d_c_l_1_1_c_genome.html" title="This is used with the CGeneticsTraining class with methods which are used to create an entire new pop...">CGenome</a> which represent the current population which is used to generate the new population. </td></tr>
    <tr><td class="paramname">vecSplitsPoints</td><td>The split points which need to be obtained from either parent by calling calculateSplitPoints(). </td></tr>
    <tr><td class="paramname">dMutationProbability</td><td>The mutation rate is the probability that a gene will be changed. This is typically a very small value of around 0.001 or so. </td></tr>
    <tr><td class="paramname">dMutationMaxAmount</td><td>The maximum amount of deviation from the weight's current value if mutation occurs. </td></tr>
    <tr><td class="paramname">dCrossoverRate</td><td>The crossover rate. A random value between 0 and 1 is generated and if the value is lower than the crossover rate, then the weights are crossed over when creating the children. </td></tr>
    <tr><td class="paramname">iNumberOfElite</td><td></td></tr>
    <tr><td class="paramname">iNumCopiesOfEachElite</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of CGenomes holding the new population.</dd></dl>
<p>This new generation creation method uses <a class="el" href="#a279fd1e029073c82def71be183bf413f" title="Given the weights of two networks (the parents), performs a crossover of their weights between each n...">crossoverBetweenNeurons()</a>, <a class="el" href="#aee030498322a0bbdc8e4d6632d6732d4" title="Given the weights of a neural network, mutates them depending upon the given values.">mutate()</a>, <a class="el" href="#aaa71e55bb08e663caee2df9d78879dc2" title="Given a vector of CGenomes representing a all the neural networks and their fitness of an entire popu...">rouletteWheelSelection()</a> and <a class="el" href="#ad1f199db4716f1402a67413a9cdd8f87" title="Performs elitism.">insertElite()</a> to generate the new population. </p>

<p class="definition">Definition at line <a class="el" href="_genetic_algorithm_8cpp_source.html#l00267">267</a> of file <a class="el" href="_genetic_algorithm_8cpp_source.html">GeneticAlgorithm.cpp</a>.</p>

</div>
</div>
<a id="abb6010e749b9bd8096f2f0a33f5b76bb" name="abb6010e749b9bd8096f2f0a33f5b76bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6010e749b9bd8096f2f0a33f5b76bb">&#9670;&#160;</a></span>crossover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCL::CGeneticsTraining::crossover </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecMumWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecDadWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecChildAWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecChildBWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dCrossoverRate</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.7</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the weights of two networks (the parents), performs a basic crossover of their weights and creates two child network weights from them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecMumWeights</td><td>The weights of the first parent (the mum!) </td></tr>
    <tr><td class="paramname">vecDadWeights</td><td>The weights of the second parent (the dad!) </td></tr>
    <tr><td class="paramname">vecChildAWeights</td><td>Will hold the weights of the 1st child. </td></tr>
    <tr><td class="paramname">vecChildBWeights</td><td>Will hold the weights of the 2nd child. </td></tr>
    <tr><td class="paramname">dCrossoverRate</td><td>The crossover rate. A random value between 0 and 1 is generated and if the value is lower than the crossover rate, then the weights are crossed over when creating the children.</td></tr>
  </table>
  </dd>
</dl>
<p>If any of the given vectors' sizes for the parents are not all the same, an exception occurs. The child vectors are cleared before doing anything, as they are the outputs. This is the simplest type of crossover and can mess up each neuron's weight values, similar to mutation. It's probably best to not use this and instead use <a class="el" href="#a279fd1e029073c82def71be183bf413f" title="Given the weights of two networks (the parents), performs a crossover of their weights between each n...">crossoverBetweenNeurons()</a> instead. The crossover rate is simply a value between 0 and 1. It's used to swap genes between two parents when creating their children. We compute a random value between 0 and 1 and if this value is lower than the crossover rate, then the genes are swapped at another random value which represents a position among all the genes. A value of around 0.7 is pretty good, in certain cases however, a different value may produce better results. </p>

<p class="definition">Definition at line <a class="el" href="_genetic_algorithm_8cpp_source.html#l00119">119</a> of file <a class="el" href="_genetic_algorithm_8cpp_source.html">GeneticAlgorithm.cpp</a>.</p>

</div>
</div>
<a id="a279fd1e029073c82def71be183bf413f" name="a279fd1e029073c82def71be183bf413f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279fd1e029073c82def71be183bf413f">&#9670;&#160;</a></span>crossoverBetweenNeurons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCL::CGeneticsTraining::crossoverBetweenNeurons </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecMumWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecDadWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecChildAWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecChildBWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecSplitPoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dCrossoverRate</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.7</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the weights of two networks (the parents), performs a crossover of their weights between each neuron and creates two child network weights from them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecMumWeights</td><td>The weights of the first parent (the mum!) </td></tr>
    <tr><td class="paramname">vecDadWeights</td><td>The weights of the second parent (the dad!) </td></tr>
    <tr><td class="paramname">vecChildAWeights</td><td>Will hold the weights of the 1st child. </td></tr>
    <tr><td class="paramname">vecChildBWeights</td><td>Will hold the weights of the 2nd child. </td></tr>
    <tr><td class="paramname">vecSplitPoints</td><td>The split points which need to be obtained from either parent by calling calculateSplitPoints(). </td></tr>
    <tr><td class="paramname">dCrossoverRate</td><td>The crossover rate. A random value between 0 and 1 is generated and if the value is lower than the crossover rate, then the weights are crossed over when creating the children.</td></tr>
  </table>
  </dd>
</dl>
<p>vecSplitPoints needs to be obtained from one of the parent neural networks with a call to it's calculateSplitPoints() method. If any of the given vectors' sizes for the parents are not all the same, an exception occurs. The child vectors are cleared before doing anything, as they are the outputs. This crossover takes into consideration the number of weights in each neuron and only splits the weight between those. The crossover rate is simply a value between 0 and 1. It's used to swap genes between two parents when creating their children. We compute a random value between 0 and 1 and if this value is lower than the crossover rate, then the genes are swapped at another random value which represents a position among all the genes. A value of around 0.7 is pretty good, in certain cases however, a different value may produce better results. </p>

<p class="definition">Definition at line <a class="el" href="_genetic_algorithm_8cpp_source.html#l00169">169</a> of file <a class="el" href="_genetic_algorithm_8cpp_source.html">GeneticAlgorithm.cpp</a>.</p>

</div>
</div>
<a id="ad1f199db4716f1402a67413a9cdd8f87" name="ad1f199db4716f1402a67413a9cdd8f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f199db4716f1402a67413a9cdd8f87">&#9670;&#160;</a></span>insertElite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCL::CGeneticsTraining::insertElite </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecOldPop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecNewPop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iNumberOfElite</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iNumCopiesOfEachElite</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs elitism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecOldPop</td><td>A vector of <a class="el" href="class_d_c_l_1_1_c_genome.html" title="This is used with the CGeneticsTraining class with methods which are used to create an entire new pop...">CGenome</a> representing the old population </td></tr>
    <tr><td class="paramname">vecNewPop</td><td>A vector of <a class="el" href="class_d_c_l_1_1_c_genome.html" title="This is used with the CGeneticsTraining class with methods which are used to create an entire new pop...">CGenome</a> which will represent the new population with the elite </td></tr>
    <tr><td class="paramname">iNumberOfElite</td><td>The number of elite from the top to copy. </td></tr>
    <tr><td class="paramname">iNumCopiesOfEachElite</td><td>How many copies of each iNumberOfElite to place.</td></tr>
  </table>
  </dd>
</dl>
<p>Given two vectors of CGenomes representing the old population and the new population. iNumberOfElite is the number of elite from the top to copy. iNumCopiesOfEachElite is how many copies of each iNumberOfElite to place. As long as the new population's size is less than the size of the old population, will choose a certain number of genomes with the best fitness and inserts them into the new population. This is typically called fom inside a createNewGeneration method. This will sort the old population vector so that the genomes with the greatest fitness are twoards the end of the vector. We don't want the number of elites and number of copies to be too high, otherwise the population's diversity will suffer. These values all depend upon the size of the population. </p>

<p class="definition">Definition at line <a class="el" href="_genetic_algorithm_8cpp_source.html#l00243">243</a> of file <a class="el" href="_genetic_algorithm_8cpp_source.html">GeneticAlgorithm.cpp</a>.</p>

</div>
</div>
<a id="aee030498322a0bbdc8e4d6632d6732d4" name="aee030498322a0bbdc8e4d6632d6732d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee030498322a0bbdc8e4d6632d6732d4">&#9670;&#160;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCL::CGeneticsTraining::mutate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecNetworkWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dMutationProbability</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.001</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dMutationMaxAmount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.3</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the weights of a neural network, mutates them depending upon the given values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vecNetworkWeights</td><td>The network weights which are to be mutated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dMutationProbability</td><td>The mutation rate is the probability that a gene will be changed. This is typically a very small value of around 0.001 or so. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dMutationMaxAmount</td><td>The maximum amount of deviation from the weight's current value if mutation occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>The mutation rate is the probability that a gene will be changed. This is typically a very small value of around 0.001 or so. We generate a random value between 0 and 1 for each weight in the given vector and if this value is less than dMutationProbability, the weight is mutated by a maximum of dMaxMutationAmount. </p>

<p class="definition">Definition at line <a class="el" href="_genetic_algorithm_8cpp_source.html#l00230">230</a> of file <a class="el" href="_genetic_algorithm_8cpp_source.html">GeneticAlgorithm.cpp</a>.</p>

</div>
</div>
<a id="aaa71e55bb08e663caee2df9d78879dc2" name="aaa71e55bb08e663caee2df9d78879dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa71e55bb08e663caee2df9d78879dc2">&#9670;&#160;</a></span>rouletteWheelSelection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> DCL::CGeneticsTraining::rouletteWheelSelection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_d_c_l_1_1_c_genome.html">CGenome</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecPopulation</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of CGenomes representing a all the neural networks and their fitness of an entire population, performs roulette wheel selection and returns a selected <a class="el" href="class_d_c_l_1_1_c_genome.html" title="This is used with the CGeneticsTraining class with methods which are used to create an entire new pop...">CGenome</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vecPopulation</td><td>a vector of each genome representing an entire population of neuron weights and their fitness scores. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The selected genome.</dd></dl>
<p>If the given vector is empty, an exception occurs. Roulette wheel selection is a method of choosing a member from the entire population in a way that is proportional to their fitness. Imagine a roulette wheel, or pie chart which is divided into portions, each assigned to a member in the population. The size of each portion is related to each member's fitness score with higher fitness getting a larger portion of the pie/wheel. The wheel is then spun until the ball stops at a position and then that member is chosen. It does not guarantee that a member with a high fitness will be chosen, but it increases the odds that it will be. Note: This may not return any best performing members, so it's probably best to use elitism if using this when selecting members. </p>

<p class="definition">Definition at line <a class="el" href="_genetic_algorithm_8cpp_source.html#l00038">38</a> of file <a class="el" href="_genetic_algorithm_8cpp_source.html">GeneticAlgorithm.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/<a class="el" href="_genetic_algorithm_8h_source.html">GeneticAlgorithm.h</a></li>
<li>X:/Projects/c++/2024/DCP/ProjectFiles/StaticLibs/DavesCodeLib/ArtificialIntelligence/<a class="el" href="_genetic_algorithm_8cpp_source.html">GeneticAlgorithm.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_d_c_l.html">DCL</a></li><li class="navelem"><a class="el" href="class_d_c_l_1_1_c_genetics_training.html">CGeneticsTraining</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
