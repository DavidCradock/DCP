\doxysection{DCL\+::CGenetics\+Training Class Reference}
\hypertarget{class_d_c_l_1_1_c_genetics_training}{}\label{class_d_c_l_1_1_c_genetics_training}\index{DCL::CGeneticsTraining@{DCL::CGeneticsTraining}}


This is the genetics training class which is used with the neural network class to train the weights of that class.  




{\ttfamily \#include $<$Genetic\+Algorithm.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} \mbox{\hyperlink{class_d_c_l_1_1_c_genetics_training_aaa71e55bb08e663caee2df9d78879dc2}{roulette\+Wheel\+Selection}} (const std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&vec\+Population) const
\begin{DoxyCompactList}\small\item\em Given a vector of CGenomes representing a all the neural networks and their fitness of an entire population, performs roulette wheel selection and returns a selected \doxylink{class_d_c_l_1_1_c_genome}{CGenome}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_d_c_l_1_1_c_genetics_training_a5e8833ee8a01f48bfcbc550459eba171}{compute\+Fitness}} (const std\+::vector$<$ double $>$ \&vec\+Population\+Fitness, double \&d\+Worst\+Fitness, double \&d\+Average\+Fitness, double \&d\+Best\+Fitness, double \&d\+Total\+Fitness) const
\begin{DoxyCompactList}\small\item\em Given a vector of doubles representing the fitness of each member within a population, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_d_c_l_1_1_c_genetics_training_af25431b91819454ea535cf1657c7fe27}{compute\+Fitness}} (const std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&vec\+Population, double \&d\+Worst\+Fitness, double \&d\+Average\+Fitness, double \&d\+Best\+Fitness, double \&d\+Total\+Fitness) const
\begin{DoxyCompactList}\small\item\em Given a vector of \doxylink{class_d_c_l_1_1_c_genome}{CGenome} objects, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_d_c_l_1_1_c_genetics_training_abb6010e749b9bd8096f2f0a33f5b76bb}{crossover}} (std\+::vector$<$ double $>$ \&vec\+Mum\+Weights, std\+::vector$<$ double $>$ \&vec\+Dad\+Weights, std\+::vector$<$ double $>$ \&vec\+Child\+AWeights, std\+::vector$<$ double $>$ \&vec\+Child\+BWeights, double d\+Crossover\+Rate=0.\+7) const
\begin{DoxyCompactList}\small\item\em Given the weights of two networks (the parents), performs a basic crossover of their weights and creates two child network weights from them. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_d_c_l_1_1_c_genetics_training_a279fd1e029073c82def71be183bf413f}{crossover\+Between\+Neurons}} (std\+::vector$<$ double $>$ \&vec\+Mum\+Weights, std\+::vector$<$ double $>$ \&vec\+Dad\+Weights, std\+::vector$<$ double $>$ \&vec\+Child\+AWeights, std\+::vector$<$ double $>$ \&vec\+Child\+BWeights, const std\+::vector$<$ int $>$ \&vec\+Split\+Points, double d\+Crossover\+Rate=0.\+7) const
\begin{DoxyCompactList}\small\item\em Given the weights of two networks (the parents), performs a crossover of their weights between each neuron and creates two child network weights from them. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_d_c_l_1_1_c_genetics_training_aee030498322a0bbdc8e4d6632d6732d4}{mutate}} (std\+::vector$<$ double $>$ \&vec\+Network\+Weights, double d\+Mutation\+Probability=0.\+001, double d\+Mutation\+Max\+Amount=0.\+3) const
\begin{DoxyCompactList}\small\item\em Given the weights of a neural network, mutates them depending upon the given values. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_d_c_l_1_1_c_genetics_training_ad1f199db4716f1402a67413a9cdd8f87}{insert\+Elite}} (std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&vec\+Old\+Pop, std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&vec\+New\+Pop, int i\+Number\+Of\+Elite=2, int i\+Num\+Copies\+Of\+Each\+Elite=1) const
\begin{DoxyCompactList}\small\item\em Performs elitism. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \mbox{\hyperlink{class_d_c_l_1_1_c_genetics_training_a704ca44c67ed68d9eb1f5dcd1996c57c}{create\+New\+Generation}} (const std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&genomes, const std\+::vector$<$ int $>$ \&vec\+Splits\+Points, double d\+Mutation\+Probability=0.\+001, double d\+Mutation\+Max\+Amount=0.\+3, double d\+Crossover\+Rate=0.\+7, int i\+Number\+Of\+Elite=2, int i\+Num\+Copies\+Of\+Each\+Elite=1) const
\begin{DoxyCompactList}\small\item\em Given a vector of CGenomes holding each neural network and their fitness scores, generates and returns a vector of CGenomes which contain a new generation. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This is the genetics training class which is used with the neural network class to train the weights of that class. 

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000002}{Todo}}]Re-\/read chapter five (Building a better genetic algorithm) of the "{}\+AI techniques for game programming"{} book to get some better methods \end{DoxyRefDesc}


A neural network has weights for each of it\textquotesingle{}s neurons and they need to be set to correct values, or trained, so that the network produces our desired behaviour.

The process goes like this... Say we wish to create a network which flees and enemy entity in a 2D world. We create a population of networks, say 100 of them, initially with random weights/genes. We then run the simulation, passing each network it\textquotesingle{}s inputs, calculating their outputs and applying those outputs to each entity in the simulation. Whilst the simulation is running, we compute a fitness score for each network depending upon how it is performing. Increasing the fitness if it is doing what we want (It is far away from predators), reducing if not (It gets eaten). After a certain time has passed, this class then creates an entirely new generation of the population of networks from the existing population to run in the next run. This class uses the fitness of each network to determine how the new child networks are generated. This process repeats until, hopefully, most of the networks are performing well. We then take the best performing networks, save them out for loading into our program at a later date for use.

When creating the new generation of networks, there are a few ways this class can choose how to create the child population. It takes the networks from the best performing networks and use those as parents, to create children from their weights/genes. It also takes non-\/best performing networks too, to help keep the population\textquotesingle{}s networks varies to allow for variation in behaviour which allows new behaviours to evolve in the population.

Typically, after a certain number of runs, the population\textquotesingle{}s differences converge so that they all roughly have the same weights, but we don\textquotesingle{}t want this to happen before an optimal behaviour has been found, so this class has ways of preventing this from happening too quickly.

There is mutation, which changes the genes/weights and may produce good behaviour, but may not. This helps diversify the population and create new behaviours. There is gene/weight crossover which determines which genes the children networks get from their parents. There are different types of crossover methods, each with subtly differences. 

Definition at line \mbox{\hyperlink{_genetic_algorithm_8h_source_l00108}{108}} of file \mbox{\hyperlink{_genetic_algorithm_8h_source}{Genetic\+Algorithm.\+h}}.



\doxysubsection{Member Function Documentation}
\Hypertarget{class_d_c_l_1_1_c_genetics_training_af25431b91819454ea535cf1657c7fe27}\index{DCL::CGeneticsTraining@{DCL::CGeneticsTraining}!computeFitness@{computeFitness}}
\index{computeFitness@{computeFitness}!DCL::CGeneticsTraining@{DCL::CGeneticsTraining}}
\doxysubsubsection{\texorpdfstring{computeFitness()}{computeFitness()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_d_c_l_1_1_c_genetics_training_af25431b91819454ea535cf1657c7fe27} 
void DCL\+::\+CGenetics\+Training\+::compute\+Fitness (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&}]{vec\+Population}{, }\item[{double \&}]{d\+Worst\+Fitness}{, }\item[{double \&}]{d\+Average\+Fitness}{, }\item[{double \&}]{d\+Best\+Fitness}{, }\item[{double \&}]{d\+Total\+Fitness}{}\end{DoxyParamCaption}) const}



Given a vector of \doxylink{class_d_c_l_1_1_c_genome}{CGenome} objects, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vec\+Population} & Vector holding the genomes of an entire population \\
\hline
\mbox{\texttt{ out}}  & {\em d\+Worst\+Fitness} & Will hold the worst fitness found in all the fitness scores \\
\hline
\mbox{\texttt{ out}}  & {\em d\+Average\+Fitness} & Will hold the average fitness computed from all the fitness scores \\
\hline
\mbox{\texttt{ out}}  & {\em d\+Best\+Fitness} & Will hold the best fitness found from all the fitness scores \\
\hline
\mbox{\texttt{ out}}  & {\em d\+Total\+Fitness} & Will hold the accumulated total of all the fitness scores \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{_genetic_algorithm_8cpp_source_l00095}{95}} of file \mbox{\hyperlink{_genetic_algorithm_8cpp_source}{Genetic\+Algorithm.\+cpp}}.

\Hypertarget{class_d_c_l_1_1_c_genetics_training_a5e8833ee8a01f48bfcbc550459eba171}\index{DCL::CGeneticsTraining@{DCL::CGeneticsTraining}!computeFitness@{computeFitness}}
\index{computeFitness@{computeFitness}!DCL::CGeneticsTraining@{DCL::CGeneticsTraining}}
\doxysubsubsection{\texorpdfstring{computeFitness()}{computeFitness()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_d_c_l_1_1_c_genetics_training_a5e8833ee8a01f48bfcbc550459eba171} 
void DCL\+::\+CGenetics\+Training\+::compute\+Fitness (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ double $>$ \&}]{vec\+Population\+Fitness}{, }\item[{double \&}]{d\+Worst\+Fitness}{, }\item[{double \&}]{d\+Average\+Fitness}{, }\item[{double \&}]{d\+Best\+Fitness}{, }\item[{double \&}]{d\+Total\+Fitness}{}\end{DoxyParamCaption}) const}



Given a vector of doubles representing the fitness of each member within a population, calculates the best, worst, average and total fitness of the population and stores those results in the given variables. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vec\+Population\+Fitness} & Vector holding the fitness score of each genome. \\
\hline
\mbox{\texttt{ out}}  & {\em d\+Worst\+Fitness} & Will hold the worst fitness found in all the fitness scores \\
\hline
\mbox{\texttt{ out}}  & {\em d\+Average\+Fitness} & Will hold the average fitness computed from all the fitness scores \\
\hline
\mbox{\texttt{ out}}  & {\em d\+Best\+Fitness} & Will hold the best fitness found from all the fitness scores \\
\hline
\mbox{\texttt{ out}}  & {\em d\+Total\+Fitness} & Will hold the accumulated total of all the fitness scores \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{_genetic_algorithm_8cpp_source_l00071}{71}} of file \mbox{\hyperlink{_genetic_algorithm_8cpp_source}{Genetic\+Algorithm.\+cpp}}.

\Hypertarget{class_d_c_l_1_1_c_genetics_training_a704ca44c67ed68d9eb1f5dcd1996c57c}\index{DCL::CGeneticsTraining@{DCL::CGeneticsTraining}!createNewGeneration@{createNewGeneration}}
\index{createNewGeneration@{createNewGeneration}!DCL::CGeneticsTraining@{DCL::CGeneticsTraining}}
\doxysubsubsection{\texorpdfstring{createNewGeneration()}{createNewGeneration()}}
{\footnotesize\ttfamily \label{class_d_c_l_1_1_c_genetics_training_a704ca44c67ed68d9eb1f5dcd1996c57c} 
std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ DCL\+::\+CGenetics\+Training\+::create\+New\+Generation (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&}]{genomes}{, }\item[{const std\+::vector$<$ int $>$ \&}]{vec\+Splits\+Points}{, }\item[{double}]{d\+Mutation\+Probability}{ = {\ttfamily 0.001}, }\item[{double}]{d\+Mutation\+Max\+Amount}{ = {\ttfamily 0.3}, }\item[{double}]{d\+Crossover\+Rate}{ = {\ttfamily 0.7}, }\item[{int}]{i\+Number\+Of\+Elite}{ = {\ttfamily 2}, }\item[{int}]{i\+Num\+Copies\+Of\+Each\+Elite}{ = {\ttfamily 1}}\end{DoxyParamCaption}) const}



Given a vector of CGenomes holding each neural network and their fitness scores, generates and returns a vector of CGenomes which contain a new generation. 


\begin{DoxyParams}{Parameters}
{\em genomes} & A vector of \doxylink{class_d_c_l_1_1_c_genome}{CGenome} which represent the current population which is used to generate the new population. \\
\hline
{\em vec\+Splits\+Points} & The split points which need to be obtained from either parent by calling calculate\+Split\+Points(). \\
\hline
{\em d\+Mutation\+Probability} & The mutation rate is the probability that a gene will be changed. This is typically a very small value of around 0.\+001 or so. \\
\hline
{\em d\+Mutation\+Max\+Amount} & The maximum amount of deviation from the weight\textquotesingle{}s current value if mutation occurs. \\
\hline
{\em d\+Crossover\+Rate} & The crossover rate. A random value between 0 and 1 is generated and if the value is lower than the crossover rate, then the weights are crossed over when creating the children. \\
\hline
{\em i\+Number\+Of\+Elite} & \\
\hline
{\em i\+Num\+Copies\+Of\+Each\+Elite} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector of CGenomes holding the new population.
\end{DoxyReturn}
This new generation creation method uses \doxylink{class_d_c_l_1_1_c_genetics_training_a279fd1e029073c82def71be183bf413f}{crossover\+Between\+Neurons()}, \doxylink{class_d_c_l_1_1_c_genetics_training_aee030498322a0bbdc8e4d6632d6732d4}{mutate()}, \doxylink{class_d_c_l_1_1_c_genetics_training_aaa71e55bb08e663caee2df9d78879dc2}{roulette\+Wheel\+Selection()} and \doxylink{class_d_c_l_1_1_c_genetics_training_ad1f199db4716f1402a67413a9cdd8f87}{insert\+Elite()} to generate the new population. 

Definition at line \mbox{\hyperlink{_genetic_algorithm_8cpp_source_l00267}{267}} of file \mbox{\hyperlink{_genetic_algorithm_8cpp_source}{Genetic\+Algorithm.\+cpp}}.

\Hypertarget{class_d_c_l_1_1_c_genetics_training_abb6010e749b9bd8096f2f0a33f5b76bb}\index{DCL::CGeneticsTraining@{DCL::CGeneticsTraining}!crossover@{crossover}}
\index{crossover@{crossover}!DCL::CGeneticsTraining@{DCL::CGeneticsTraining}}
\doxysubsubsection{\texorpdfstring{crossover()}{crossover()}}
{\footnotesize\ttfamily \label{class_d_c_l_1_1_c_genetics_training_abb6010e749b9bd8096f2f0a33f5b76bb} 
void DCL\+::\+CGenetics\+Training\+::crossover (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{vec\+Mum\+Weights}{, }\item[{std\+::vector$<$ double $>$ \&}]{vec\+Dad\+Weights}{, }\item[{std\+::vector$<$ double $>$ \&}]{vec\+Child\+AWeights}{, }\item[{std\+::vector$<$ double $>$ \&}]{vec\+Child\+BWeights}{, }\item[{double}]{d\+Crossover\+Rate}{ = {\ttfamily 0.7}}\end{DoxyParamCaption}) const}



Given the weights of two networks (the parents), performs a basic crossover of their weights and creates two child network weights from them. 


\begin{DoxyParams}{Parameters}
{\em vec\+Mum\+Weights} & The weights of the first parent (the mum!) \\
\hline
{\em vec\+Dad\+Weights} & The weights of the second parent (the dad!) \\
\hline
{\em vec\+Child\+AWeights} & Will hold the weights of the 1st child. \\
\hline
{\em vec\+Child\+BWeights} & Will hold the weights of the 2nd child. \\
\hline
{\em d\+Crossover\+Rate} & The crossover rate. A random value between 0 and 1 is generated and if the value is lower than the crossover rate, then the weights are crossed over when creating the children.\\
\hline
\end{DoxyParams}
If any of the given vectors\textquotesingle{} sizes for the parents are not all the same, an exception occurs. The child vectors are cleared before doing anything, as they are the outputs. This is the simplest type of crossover and can mess up each neuron\textquotesingle{}s weight values, similar to mutation. It\textquotesingle{}s probably best to not use this and instead use \doxylink{class_d_c_l_1_1_c_genetics_training_a279fd1e029073c82def71be183bf413f}{crossover\+Between\+Neurons()} instead. The crossover rate is simply a value between 0 and 1. It\textquotesingle{}s used to swap genes between two parents when creating their children. We compute a random value between 0 and 1 and if this value is lower than the crossover rate, then the genes are swapped at another random value which represents a position among all the genes. A value of around 0.\+7 is pretty good, in certain cases however, a different value may produce better results. 

Definition at line \mbox{\hyperlink{_genetic_algorithm_8cpp_source_l00119}{119}} of file \mbox{\hyperlink{_genetic_algorithm_8cpp_source}{Genetic\+Algorithm.\+cpp}}.

\Hypertarget{class_d_c_l_1_1_c_genetics_training_a279fd1e029073c82def71be183bf413f}\index{DCL::CGeneticsTraining@{DCL::CGeneticsTraining}!crossoverBetweenNeurons@{crossoverBetweenNeurons}}
\index{crossoverBetweenNeurons@{crossoverBetweenNeurons}!DCL::CGeneticsTraining@{DCL::CGeneticsTraining}}
\doxysubsubsection{\texorpdfstring{crossoverBetweenNeurons()}{crossoverBetweenNeurons()}}
{\footnotesize\ttfamily \label{class_d_c_l_1_1_c_genetics_training_a279fd1e029073c82def71be183bf413f} 
void DCL\+::\+CGenetics\+Training\+::crossover\+Between\+Neurons (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{vec\+Mum\+Weights}{, }\item[{std\+::vector$<$ double $>$ \&}]{vec\+Dad\+Weights}{, }\item[{std\+::vector$<$ double $>$ \&}]{vec\+Child\+AWeights}{, }\item[{std\+::vector$<$ double $>$ \&}]{vec\+Child\+BWeights}{, }\item[{const std\+::vector$<$ int $>$ \&}]{vec\+Split\+Points}{, }\item[{double}]{d\+Crossover\+Rate}{ = {\ttfamily 0.7}}\end{DoxyParamCaption}) const}



Given the weights of two networks (the parents), performs a crossover of their weights between each neuron and creates two child network weights from them. 


\begin{DoxyParams}{Parameters}
{\em vec\+Mum\+Weights} & The weights of the first parent (the mum!) \\
\hline
{\em vec\+Dad\+Weights} & The weights of the second parent (the dad!) \\
\hline
{\em vec\+Child\+AWeights} & Will hold the weights of the 1st child. \\
\hline
{\em vec\+Child\+BWeights} & Will hold the weights of the 2nd child. \\
\hline
{\em vec\+Split\+Points} & The split points which need to be obtained from either parent by calling calculate\+Split\+Points(). \\
\hline
{\em d\+Crossover\+Rate} & The crossover rate. A random value between 0 and 1 is generated and if the value is lower than the crossover rate, then the weights are crossed over when creating the children.\\
\hline
\end{DoxyParams}
vec\+Split\+Points needs to be obtained from one of the parent neural networks with a call to it\textquotesingle{}s calculate\+Split\+Points() method. If any of the given vectors\textquotesingle{} sizes for the parents are not all the same, an exception occurs. The child vectors are cleared before doing anything, as they are the outputs. This crossover takes into consideration the number of weights in each neuron and only splits the weight between those. The crossover rate is simply a value between 0 and 1. It\textquotesingle{}s used to swap genes between two parents when creating their children. We compute a random value between 0 and 1 and if this value is lower than the crossover rate, then the genes are swapped at another random value which represents a position among all the genes. A value of around 0.\+7 is pretty good, in certain cases however, a different value may produce better results. 

Definition at line \mbox{\hyperlink{_genetic_algorithm_8cpp_source_l00169}{169}} of file \mbox{\hyperlink{_genetic_algorithm_8cpp_source}{Genetic\+Algorithm.\+cpp}}.

\Hypertarget{class_d_c_l_1_1_c_genetics_training_ad1f199db4716f1402a67413a9cdd8f87}\index{DCL::CGeneticsTraining@{DCL::CGeneticsTraining}!insertElite@{insertElite}}
\index{insertElite@{insertElite}!DCL::CGeneticsTraining@{DCL::CGeneticsTraining}}
\doxysubsubsection{\texorpdfstring{insertElite()}{insertElite()}}
{\footnotesize\ttfamily \label{class_d_c_l_1_1_c_genetics_training_ad1f199db4716f1402a67413a9cdd8f87} 
void DCL\+::\+CGenetics\+Training\+::insert\+Elite (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&}]{vec\+Old\+Pop}{, }\item[{std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&}]{vec\+New\+Pop}{, }\item[{int}]{i\+Number\+Of\+Elite}{ = {\ttfamily 2}, }\item[{int}]{i\+Num\+Copies\+Of\+Each\+Elite}{ = {\ttfamily 1}}\end{DoxyParamCaption}) const}



Performs elitism. 


\begin{DoxyParams}{Parameters}
{\em vec\+Old\+Pop} & A vector of \doxylink{class_d_c_l_1_1_c_genome}{CGenome} representing the old population \\
\hline
{\em vec\+New\+Pop} & A vector of \doxylink{class_d_c_l_1_1_c_genome}{CGenome} which will represent the new population with the elite \\
\hline
{\em i\+Number\+Of\+Elite} & The number of elite from the top to copy. \\
\hline
{\em i\+Num\+Copies\+Of\+Each\+Elite} & How many copies of each i\+Number\+Of\+Elite to place.\\
\hline
\end{DoxyParams}
Given two vectors of CGenomes representing the old population and the new population. i\+Number\+Of\+Elite is the number of elite from the top to copy. i\+Num\+Copies\+Of\+Each\+Elite is how many copies of each i\+Number\+Of\+Elite to place. As long as the new population\textquotesingle{}s size is less than the size of the old population, will choose a certain number of genomes with the best fitness and inserts them into the new population. This is typically called fom inside a create\+New\+Generation method. This will sort the old population vector so that the genomes with the greatest fitness are twoards the end of the vector. We don\textquotesingle{}t want the number of elites and number of copies to be too high, otherwise the population\textquotesingle{}s diversity will suffer. These values all depend upon the size of the population. 

Definition at line \mbox{\hyperlink{_genetic_algorithm_8cpp_source_l00243}{243}} of file \mbox{\hyperlink{_genetic_algorithm_8cpp_source}{Genetic\+Algorithm.\+cpp}}.

\Hypertarget{class_d_c_l_1_1_c_genetics_training_aee030498322a0bbdc8e4d6632d6732d4}\index{DCL::CGeneticsTraining@{DCL::CGeneticsTraining}!mutate@{mutate}}
\index{mutate@{mutate}!DCL::CGeneticsTraining@{DCL::CGeneticsTraining}}
\doxysubsubsection{\texorpdfstring{mutate()}{mutate()}}
{\footnotesize\ttfamily \label{class_d_c_l_1_1_c_genetics_training_aee030498322a0bbdc8e4d6632d6732d4} 
void DCL\+::\+CGenetics\+Training\+::mutate (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{vec\+Network\+Weights}{, }\item[{double}]{d\+Mutation\+Probability}{ = {\ttfamily 0.001}, }\item[{double}]{d\+Mutation\+Max\+Amount}{ = {\ttfamily 0.3}}\end{DoxyParamCaption}) const}



Given the weights of a neural network, mutates them depending upon the given values. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em vec\+Network\+Weights} & The network weights which are to be mutated \\
\hline
 & {\em d\+Mutation\+Probability} & The mutation rate is the probability that a gene will be changed. This is typically a very small value of around 0.\+001 or so. \\
\hline
 & {\em d\+Mutation\+Max\+Amount} & The maximum amount of deviation from the weight\textquotesingle{}s current value if mutation occurs.\\
\hline
\end{DoxyParams}
The mutation rate is the probability that a gene will be changed. This is typically a very small value of around 0.\+001 or so. We generate a random value between 0 and 1 for each weight in the given vector and if this value is less than d\+Mutation\+Probability, the weight is mutated by a maximum of d\+Max\+Mutation\+Amount. 

Definition at line \mbox{\hyperlink{_genetic_algorithm_8cpp_source_l00230}{230}} of file \mbox{\hyperlink{_genetic_algorithm_8cpp_source}{Genetic\+Algorithm.\+cpp}}.

\Hypertarget{class_d_c_l_1_1_c_genetics_training_aaa71e55bb08e663caee2df9d78879dc2}\index{DCL::CGeneticsTraining@{DCL::CGeneticsTraining}!rouletteWheelSelection@{rouletteWheelSelection}}
\index{rouletteWheelSelection@{rouletteWheelSelection}!DCL::CGeneticsTraining@{DCL::CGeneticsTraining}}
\doxysubsubsection{\texorpdfstring{rouletteWheelSelection()}{rouletteWheelSelection()}}
{\footnotesize\ttfamily \label{class_d_c_l_1_1_c_genetics_training_aaa71e55bb08e663caee2df9d78879dc2} 
\mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} DCL\+::\+CGenetics\+Training\+::roulette\+Wheel\+Selection (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_d_c_l_1_1_c_genome}{CGenome}} $>$ \&}]{vec\+Population}{}\end{DoxyParamCaption}) const}



Given a vector of CGenomes representing a all the neural networks and their fitness of an entire population, performs roulette wheel selection and returns a selected \doxylink{class_d_c_l_1_1_c_genome}{CGenome}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vec\+Population} & a vector of each genome representing an entire population of neuron weights and their fitness scores. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The selected genome.
\end{DoxyReturn}
If the given vector is empty, an exception occurs. Roulette wheel selection is a method of choosing a member from the entire population in a way that is proportional to their fitness. Imagine a roulette wheel, or pie chart which is divided into portions, each assigned to a member in the population. The size of each portion is related to each member\textquotesingle{}s fitness score with higher fitness getting a larger portion of the pie/wheel. The wheel is then spun until the ball stops at a position and then that member is chosen. It does not guarantee that a member with a high fitness will be chosen, but it increases the odds that it will be. Note\+: This may not return any best performing members, so it\textquotesingle{}s probably best to use elitism if using this when selecting members. 

Definition at line \mbox{\hyperlink{_genetic_algorithm_8cpp_source_l00038}{38}} of file \mbox{\hyperlink{_genetic_algorithm_8cpp_source}{Genetic\+Algorithm.\+cpp}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
X\+:/\+Projects/c++/2024/\+DCP/\+Project\+Files/\+Static\+Libs/\+Daves\+Code\+Lib/\+Artificial\+Intelligence/\mbox{\hyperlink{_genetic_algorithm_8h}{Genetic\+Algorithm.\+h}}\item 
X\+:/\+Projects/c++/2024/\+DCP/\+Project\+Files/\+Static\+Libs/\+Daves\+Code\+Lib/\+Artificial\+Intelligence/Genetic\+Algorithm.\+cpp\end{DoxyCompactItemize}
